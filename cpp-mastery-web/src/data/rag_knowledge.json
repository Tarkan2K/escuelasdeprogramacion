[
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"main\"></a>C++ Core Guidelines",
    "content": "# <a name=\"main\"></a>C++ Core Guidelines\n\nJul 8, 2025\n\nEditors:\n\n* [Bjarne Stroustrup](https://www.stroustrup.com)\n* [Herb Sutter](https://herbsutter.com/)\n\nThis is a living document under continuous improvement.\nHad it been an open-source (code) project, this would have been release 0.8.\nCopying, use, modification, and creation of derivative works from this project is licensed under an MIT-style license.\nContributing to this project requires agreeing to a Contributor License. See the accompanying [LICENSE](https://github.com/isocpp/CppCoreGuidelines/blob/master/LICENSE) file for details.\nWe make this project available to \"friendly users\" to use, copy, modify, and derive from, hoping for constructive input.\n\nComments and suggestions for improvements are most welcome.\nWe plan to modify and extend this document as our understanding improves and the language and the set of available libraries improve.\nWhen commenting, please note [the introduction](#s-introduction) that outlines our aims and general approach.\nThe list of contributors is [here](#ss-ack).\n\nProblems:\n\n* The sets of rules have not been completely checked for completeness, consistency, or enforceability.\n* Triple question marks (???) mark known missing information.\n* Update reference sections; many pre-C++11 sources are too old.\n* For a more-or-less up-to-date to-do list see: [To-do: Unclassified proto-rules](#s-unclassified).\n\nYou can [read an explanation of the scope and structure of this Guide](#s-abstract) or just jump straight in:\n\n* [In: Introduction](#s-introduction)\n* [P: Philosophy](#s-philosophy)\n* [I: Interfaces](#s-interfaces)\n* [F: Functions](#s-functions)\n* [C: Classes and class hierarchies](#s-class)\n* [Enum: Enumerations](#s-enum)\n* [R: Resource management](#s-resource)\n* [ES: Expressions and statements](#s-expr)\n* [Per: Performance](#s-performance)\n* [CP: Concurrency and parallelism](#s-concurrency)\n* [E: Error handling](#s-errors)\n* [Con: Constants and immutability](#s-const)\n* [T: Templates and generic programming](#s-templates)\n* [CPL: C-style programming](#s-cpl)\n* [SF: Source files](#s-source)\n* [SL: The Standard Library](#sl-the-standard-library)\n\nSupporting sections:\n\n* [A: Architectural ideas](#s-a)\n* [NR: Non-Rules and myths](#s-not)\n* [RF: References](#s-references)\n* [Pro: Profiles](#s-profile)\n* [GSL: Guidelines support library](#s-gsl)\n* [NL: Naming and layout suggestions](#s-naming)\n* [FAQ: Answers to frequently asked questions](#s-faq)\n* [Appendix A: Libraries](#s-libraries)\n* [Appendix B: Modernizing code](#s-modernizing)\n* [Appendix C: Discussion](#s-discussion)\n* [Appendix D: Supporting tools](#s-tools)\n* [Glossary](#s-glossary)\n* [To-do: Unclassified proto-rules](#s-unclassified)\n\nYou can sample rules for specific language features:\n\n* assignment:\n[regular types](#rc-regular) --\n[prefer initialization](#rc-initialize) --\n[copy](#rc-copy-semantic) --\n[move](#rc-move-semantic) --\n[other operations](#rc-matched) --\n[default](#rc-eqdefault)\n* `class`:\n[data](#rc-org) --\n[invariant](#rc-struct) --\n[members](#rc-member) --\n[helpers](#rc-helper) --\n[concrete types](#ss-concrete) --\n[ctors, =, and dtors](#s-ctor) --\n[hierarchy](#ss-hier) --\n[operators](#ss-overload)\n* `concept`:\n[rules](#ss-concepts) --\n[in generic programming](#rt-raise) --\n[template arguments](#rt-concepts) --\n[semantics](#rt-low)\n* constructor:\n[invariant](#rc-struct) --\n[establish invariant](#rc-ctor) --\n[`throw`](#rc-throw) --\n[default](#rc-default0) --\n[not needed](#rc-default) --\n[`explicit`](#rc-explicit) --\n[delegating](#rc-delegating) --\n[`virtual`](#rc-ctor-virtual)\n* derived `class`:\n[when to use](#rh-domain) --\n[as interface](#rh-abstract) --\n[destructors](#rh-dtor) --\n[copy](#rh-copy) --\n[getters and setters](#rh-get) --\n[multiple inheritance](#rh-mi-interface) --\n[overloading](#rh-using) --\n[slicing](#rc-copy-virtual) --\n[`dynamic_cast`](#rh-dynamic_cast)\n* destructor:\n[and constructors](#rc-matched) --\n[when needed?](#rc-dtor) --\n[must not fail](#rc-dtor-fail)\n* exception:\n[errors](#s-errors) --\n[`throw`](#re-throw) --\n[for errors only](#re-errors) --\n[`noexcept`](#re-noexcept) --\n[minimize `try`](#re-catch) --\n[what if no exceptions?](#re-no-throw-codes)\n* `for`:\n[range-for and for](#res-for-range) --\n[for and while](#res-for-while) --\n[for-initializer](#res-for-init) --\n[empty body](#res-empty) --\n[loop variable](#res-loop-counter) --\n[loop variable type ???](#res-???)\n* function:\n[naming](#rf-package) --\n[single operation](#rf-logical) --\n[no throw](#rf-noexcept) --\n[arguments](#rf-smart) --\n[argument passing](#rf-conventional) --\n[multiple return values](#rf-out-multi) --\n[pointers](#rf-return-ptr) --\n[lambdas](#rf-capture-vs-overload)\n* `inline`:\n[small functions](#rf-inline) --\n[in headers](#rs-inline)\n* initialization:\n[always](#res-always) --\n[prefer `{}`](#res-list) --\n[lambdas](#res-lambda-init) --\n[default member initializers](#rc-in-class-initializer) --\n[class members](#rc-initialize) --\n[factory functions](#rc-factory)\n* lambda expression:\n[when to use](#ss-lambdas)\n* operator:\n[conventional](#ro-conventional) --\n[avoid conversion operators](#ro-conversion) --\n[and lambdas](#ro-lambda)\n* `public`, `private`, and `protected`:\n[information hiding](#rc-private) --\n[consistency](#rh-public) --\n[`protected`](#rh-protected)\n* `static_assert`:\n[compile-time checking](#rp-compile-time) --\n[and concepts](#rt-check-class)\n* `struct`:\n[for organizing data](#rc-org) --\n[use if no invariant](#rc-struct) --\n[no private members](#rc-class)\n* `template`:\n[abstraction](#rt-raise) --\n[containers](#rt-cont) --\n[concepts](#rt-concepts)\n* `unsigned`:\n[and signed](#res-mix) --\n[bit manipulation](#res-unsigned)\n* `virtual`:\n[interfaces](#ri-abstract) --\n[not `virtual`](#rc-concrete) --\n[destructor](#rc-dtor-virtual) --\n[never fail](#rc-dtor-fail)\n\nYou can look at design concepts used to express the rules:\n\n* assertion: ???\n* error: ???\n* exception: exception guarantee (???)\n* failure: ???\n* invariant: ???\n* leak: ???\n* library: ???\n* precondition: ???\n* postcondition: ???\n* resource: ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-abstract\"></a>Abstract",
    "content": "# <a name=\"s-abstract\"></a>Abstract\n\nThis document is a set of guidelines for using C++ well.\nThe aim of this document is to help people to use modern C++ effectively.\nBy \"modern C++\" we mean effective use of the ISO C++ standard (currently C++20, but almost all of our recommendations also apply to C++17, C++14 and C++11).\nIn other words, what would you like your code to look like in 5 years' time, given that you can start now? In 10 years' time?\n\nThe guidelines are focused on relatively high-level issues, such as interfaces, resource management, memory management, and concurrency.\nSuch rules affect application architecture and library design.\nFollowing the rules will lead to code that is statically type safe, has no resource leaks, and catches many more programming logic errors than is common in code today.\nAnd it will run fast -- you can afford to do things right.\n\nWe are less concerned with low-level issues, such as naming conventions and indentation style.\nHowever, no topic that can help a programmer is out of bounds.\n\nOur initial set of rules emphasizes safety (of various forms) and simplicity.\nThey might very well be too strict.\nWe expect to have to introduce more exceptions to better accommodate real-world needs.\nWe also need more rules.\n\nYou will find some of the rules contrary to your expectations or even contrary to your experience.\nIf we haven't suggested you change your coding style in any way, we have failed!\nPlease try to verify or disprove rules!\nIn particular, we'd really like to have some of our rules backed up with measurements or better examples.\n\nYou will find some of the rules obvious or even trivial.\nPlease remember that one purpose of a guideline is to help someone who is less experienced or coming from a different background or language to get up to speed.\n\nMany of the rules are designed to be supported by an analysis tool.\nViolations of rules will be flagged with references (or links) to the relevant rule.\nWe do not expect you to memorize all the rules before trying to write code.\nOne way of thinking about these guidelines is as a specification for tools that happens to be readable by humans.\n\nThe rules are meant for gradual introduction into a code base.\nWe plan to build tools for that and hope others will too.\n\nComments and suggestions for improvements are most welcome.\nWe plan to modify and extend this document as our understanding improves and the language and the set of available libraries improve.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-introduction\"></a>In: Introduction",
    "content": "# <a name=\"s-introduction\"></a>In: Introduction\n\nThis is a set of core guidelines for modern C++ (currently C++20 and C++17) taking likely future enhancements and ISO Technical Specifications (TSs) into account.\nThe aim is to help C++ programmers to write simpler, more efficient, more maintainable code.\n\nIntroduction summary:\n\n* [In.target: Target readership](#ss-readers)\n* [In.aims: Aims](#ss-aims)\n* [In.not: Non-aims](#ss-non)\n* [In.force: Enforcement](#ss-force)\n* [In.struct: The structure of this document](#ss-struct)\n* [In.sec: Major sections](#ss-sec)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-readers\"></a>In.target: Target readership",
    "content": "## <a name=\"ss-readers\"></a>In.target: Target readership\n\nAll C++ programmers. This includes [programmers who might consider C](#s-cpl).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-aims\"></a>In.aims: Aims",
    "content": "## <a name=\"ss-aims\"></a>In.aims: Aims\n\nThe purpose of this document is to help developers to adopt modern C++ (currently C++20 and C++17) and to achieve a more uniform style across code bases.\n\nWe do not suffer the delusion that every one of these rules can be effectively applied to every code base. Upgrading old systems is hard. However, we do believe that a program that uses a rule is less error-prone and more maintainable than one that does not. Often, rules also lead to faster/easier initial development.\nAs far as we can tell, these rules lead to code that performs as well or better than older, more conventional techniques; they are meant to follow the zero-overhead principle (\"what you don't use, you don't pay for\" or \"when you use an abstraction mechanism appropriately, you get at least as good performance as if you had handcoded using lower-level language constructs\").\nConsider these rules ideals for new code, opportunities to exploit when working on older code, and try to approximate these ideals as closely as feasible.\nRemember:\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"r0\"></a>In.0: Don't panic!",
    "content": "### <a name=\"r0\"></a>In.0: Don't panic!\n\nTake the time to understand the implications of a guideline rule on your program.\n\nThese guidelines are designed according to the \"subset of superset\" principle ([Stroustrup05](#Stroustrup05)).\nThey do not simply define a subset of C++ to be used (for reliability, safety, performance, or whatever).\nInstead, they strongly recommend the use of a few simple \"extensions\" ([library components](#gsl-guidelines-support-library))\nthat make the use of the most error-prone features of C++ redundant, so that they can be banned (in our set of rules).\n\nThe rules emphasize static type safety and resource safety.\nFor that reason, they emphasize possibilities for range checking, for avoiding dereferencing `nullptr`, for avoiding dangling pointers, and the systematic use of exceptions (via RAII).\nPartly to achieve that and partly to minimize obscure code as a source of errors, the rules also emphasize simplicity and the hiding of necessary complexity behind well-specified interfaces.\n\nMany of the rules are prescriptive.\nWe are uncomfortable with rules that simply state \"don't do that!\" without offering an alternative.\nOne consequence of that is that some rules can be supported only by heuristics, rather than precise and mechanically verifiable checks.\nOther rules articulate general principles. For these more general rules, more detailed and specific rules provide partial checking.\n\nThese guidelines address the core of C++ and its use.\nWe expect that most large organizations, specific application areas, and even large projects will need further rules, possibly further restrictions, and further library support.\nFor example, hard-real-time programmers typically can't use free store (dynamic memory) freely and will be restricted in their choice of libraries.\nWe encourage the development of such more specific rules as addenda to these core guidelines.\nBuild your ideal small foundation library and use that, rather than lowering your level of programming to glorified assembly code.\n\nThe rules are designed to allow [gradual adoption](#s-modernizing).\n\nSome rules aim to increase various forms of safety while others aim to reduce the likelihood of accidents, many do both.\nThe guidelines aimed at preventing accidents often ban perfectly legal C++.\nHowever, when there are two ways of expressing an idea and one has shown itself a common source of errors and the other has not, we try to guide programmers towards the latter.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-non\"></a>In.not: Non-aims",
    "content": "## <a name=\"ss-non\"></a>In.not: Non-aims\n\nThe rules are not intended to be minimal or orthogonal.\nIn particular, general rules can be simple, but unenforceable.\nAlso, it is often hard to understand the implications of a general rule.\nMore specialized rules are often easier to understand and to enforce, but without general rules, they would just be a long list of special cases.\nWe provide rules aimed at helping novices as well as rules supporting expert use.\nSome rules can be completely enforced, but others are based on heuristics.\n\nThese rules are not meant to be read serially, like a book.\nYou can browse through them using the links.\nHowever, their main intended use is to be targets for tools.\nThat is, a tool looks for violations and the tool returns links to violated rules.\nThe rules then provide reasons, examples of potential consequences of the violation, and suggested remedies.\n\nThese guidelines are not intended to be a substitute for a tutorial treatment of C++.\nIf you need a tutorial for some given level of experience, see [the references](#s-references).\n\nThis is not a guide on how to convert old C++ code to more modern code.\nIt is meant to articulate ideas for new code in a concrete fashion.\nHowever, see [the modernization section](#s-modernizing) for some possible approaches to modernizing/rejuvenating/upgrading.\nImportantly, the rules support gradual adoption: It is typically infeasible to completely convert a large code base all at once.\n\nThese guidelines are not meant to be complete or exact in every language-technical detail.\nFor the final word on language definition issues, including every exception to general rules and every feature, see the ISO C++ standard.\n\nThe rules are not intended to force you to write in an impoverished subset of C++.\nThey are *emphatically* not meant to define a, say, Java-like subset of C++.\nThey are not meant to define a single \"one true C++\" language.\nWe value expressiveness and uncompromised performance.\n\nThe rules are not value-neutral.\nThey are meant to make code simpler and more correct/safer than most existing C++ code, without loss of performance.\nThey are meant to inhibit perfectly valid C++ code that correlates with errors, spurious complexity, and poor performance.\n\nThe rules are not precise to the point where a person (or machine) can follow them without thinking.\nThe enforcement parts try to be that, but we would rather leave a rule or a definition a bit vague\nand open to interpretation than specify something precisely and wrong.\nSometimes, precision comes only with time and experience.\nDesign is not (yet) a form of Math.\n\nThe rules are not perfect.\nA rule can do harm by prohibiting something that is useful in a given situation.\nA rule can do harm by failing to prohibit something that enables a serious error in a given situation.\nA rule can do a lot of harm by being vague, ambiguous, unenforceable, or by enabling every solution to a problem.\nIt is impossible to completely meet the \"do no harm\" criteria.\nInstead, our aim is the less ambitious: \"Do the most good for most programmers\";\nif you cannot live with a rule, object to it, ignore it, but don't water it down until it becomes meaningless.\nAlso, suggest an improvement.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-force\"></a>In.force: Enforcement",
    "content": "## <a name=\"ss-force\"></a>In.force: Enforcement\n\nRules with no enforcement are unmanageable for large code bases.\nEnforcement of all rules is possible only for a small weak set of rules or for a specific user community.\n\n* But we want lots of rules, and we want rules that everybody can use.\n* But different people have different needs.\n* But people don't like to read lots of rules.\n* But people can't remember many rules.\n\nSo, we need subsetting to meet a variety of needs.\n\n* But arbitrary subsetting leads to chaos.\n\nWe want guidelines that help a lot of people, make code more uniform, and strongly encourage people to modernize their code.\nWe want to encourage best practices, rather than leave all to individual choices and management pressures.\nThe ideal is to use all rules; that gives the greatest benefits.\n\nThis adds up to quite a few dilemmas.\nWe try to resolve those using tools.\nEach rule has an **Enforcement** section listing ideas for enforcement.\nEnforcement might be done by code review, by static analysis, by compiler, or by run-time checks.\nWherever possible, we prefer \"mechanical\" checking (humans are slow, inaccurate, and bore easily) and static checking.\nRun-time checks are suggested only rarely where no alternative exists; we do not want to introduce \"distributed bloat\".\nWhere appropriate, we label a rule (in the **Enforcement** sections) with the name of groups of related rules (called \"profiles\").\nA rule can be part of several profiles, or none.\nFor a start, we have a few profiles corresponding to common needs (desires, ideals):\n\n* **type**: No type violations (reinterpreting a `T` as a `U` through casts, unions, or varargs)\n* **bounds**: No bounds violations (accessing beyond the range of an array)\n* **lifetime**: No leaks (failing to `delete` or multiple `delete`) and no access to invalid objects (dereferencing `nullptr`, using a dangling reference).\n\nThe profiles are intended to be used by tools, but also serve as an aid to the human reader.\nWe do not limit our comment in the **Enforcement** sections to things we know how to enforce; some comments are mere wishes that might inspire some tool builder.\n\nTools that implement these rules shall respect the following syntax to explicitly suppress a rule:\n\n    [[gsl::suppress(\"tag\")]]\n\nand optionally with a message (following usual C++11 standard attribute syntax):\n\n    [[gsl::suppress(\"tag\", justification: \"message\")]]\n\nwhere\n\n* `\"tag\"` is a string literal with the anchor name of the item where the Enforcement rule appears (e.g., for [C.134](#rh-public) it is \"rh-public\"), the\nname of a profile group-of-rules (\"type\", \"bounds\", or \"lifetime\"),\nor a specific rule in a profile ([type.4](#pro-type-cstylecast), or [bounds.2](#pro-bounds-arrayindex)). Any text that is not one of those should be rejected.\n\n* `\"message\"` is a string literal\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-struct\"></a>In.struct: The structure of this document",
    "content": "## <a name=\"ss-struct\"></a>In.struct: The structure of this document\n\nEach rule (guideline, suggestion) can have several parts:\n\n* The rule itself -- e.g., **no naked `new`**\n* A rule reference number -- e.g., **C.7** (the 7th rule related to classes).\n  Since the major sections are not inherently ordered, we use letters as the first part of a rule reference \"number\".\n  We leave gaps in the numbering to minimize \"disruption\" when we add or remove rules.\n* **Reason**s (rationales) -- because programmers find it hard to follow rules they don't understand\n* **Example**s -- because rules are hard to understand in the abstract; can be positive or negative\n* **Alternative**s -- for \"don't do this\" rules\n* **Exception**s -- we prefer simple general rules. However, many rules apply widely, but not universally, so exceptions must be listed\n* **Enforcement** -- ideas about how the rule might be checked \"mechanically\"\n* **See also**s -- references to related rules and/or further discussion (in this document or elsewhere)\n* **Note**s (comments) -- something that needs saying that doesn't fit the other classifications\n* **Discussion** -- references to more extensive rationale and/or examples placed outside the main lists of rules\n\nSome rules are hard to check mechanically, but they all meet the minimal criteria that an expert programmer can spot many violations without too much trouble.\nWe hope that \"mechanical\" tools will improve with time to approximate what such an expert programmer notices.\nAlso, we assume that the rules will be refined over time to make them more precise and checkable.\n\nA rule is aimed at being simple, rather than carefully phrased to mention every alternative and special case.\nSuch information is found in the **Alternative** paragraphs and the [Discussion](#s-discussion) sections.\nIf you don't understand a rule or disagree with it, please visit its **Discussion**.\nIf you feel that a discussion is missing or incomplete, enter an [Issue](https://github.com/isocpp/CppCoreGuidelines/issues)\nexplaining your concerns and possibly a corresponding PR.\n\nExamples are written to illustrate rules.\n\n* Examples are not intended to be production quality or to cover all tutorial dimensions.\nFor example, many examples are language-technical and use names like `f`, `base`, and `x`.\n* We try to ensure that \"good\" examples follow the Core Guidelines.\n* Comments are often illustrating rules where they would be unnecessary and/or distracting in \"real code.\"\n* We assume knowledge of the standard library. For example, we use plain `vector` rather than `std::vector`.\n\nThis is not a language manual.\nIt is meant to be helpful, rather than complete, fully accurate on technical details, or a guide to existing code.\nRecommended information sources can be found in [the references](#s-references).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-sec\"></a>In.sec: Major sections",
    "content": "## <a name=\"ss-sec\"></a>In.sec: Major sections\n\n* [In: Introduction](#s-introduction)\n* [P: Philosophy](#s-philosophy)\n* [I: Interfaces](#s-interfaces)\n* [F: Functions](#s-functions)\n* [C: Classes and class hierarchies](#s-class)\n* [Enum: Enumerations](#s-enum)\n* [R: Resource management](#s-resource)\n* [ES: Expressions and statements](#s-expr)\n* [Per: Performance](#s-performance)\n* [CP: Concurrency and parallelism](#s-concurrency)\n* [E: Error handling](#s-errors)\n* [Con: Constants and immutability](#s-const)\n* [T: Templates and generic programming](#s-templates)\n* [CPL: C-style programming](#s-cpl)\n* [SF: Source files](#s-source)\n* [SL: The Standard Library](#sl-the-standard-library)\n\nSupporting sections:\n\n* [A: Architectural ideas](#s-a)\n* [NR: Non-Rules and myths](#s-not)\n* [RF: References](#s-references)\n* [Pro: Profiles](#s-profile)\n* [GSL: Guidelines support library](#gsl-guidelines-support-library)\n* [NL: Naming and layout suggestions](#s-naming)\n* [FAQ: Answers to frequently asked questions](#s-faq)\n* [Appendix A: Libraries](#s-libraries)\n* [Appendix B: Modernizing code](#s-modernizing)\n* [Appendix C: Discussion](#s-discussion)\n* [Appendix D: Supporting tools](#s-tools)\n* [Glossary](#s-glossary)\n* [To-do: Unclassified proto-rules](#s-unclassified)\n\nThese sections are not orthogonal.\n\nEach section (e.g., \"P\" for \"Philosophy\") and each subsection (e.g., \"C.hier\" for \"Class Hierarchies (OOP)\") have an abbreviation for ease of searching and reference.\nThe main section abbreviations are also used in rule numbers (e.g., \"C.11\" for \"Make concrete types regular\").\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-philosophy\"></a>P: Philosophy",
    "content": "# <a name=\"s-philosophy\"></a>P: Philosophy\n\nThe rules in this section are very general.\n\nPhilosophy rules summary:\n\n* [P.1: Express ideas directly in code](#rp-direct)\n* [P.2: Write in ISO Standard C++](#rp-cplusplus)\n* [P.3: Express intent](#rp-what)\n* [P.4: Ideally, a program should be statically type safe](#rp-typesafe)\n* [P.5: Prefer compile-time checking to run-time checking](#rp-compile-time)\n* [P.6: What cannot be checked at compile time should be checkable at run time](#rp-run-time)\n* [P.7: Catch run-time errors early](#rp-early)\n* [P.8: Don't leak any resources](#rp-leak)\n* [P.9: Don't waste time or space](#rp-waste)\n* [P.10: Prefer immutable data to mutable data](#rp-mutable)\n* [P.11: Encapsulate messy constructs, rather than spreading through the code](#rp-library)\n* [P.12: Use supporting tools as appropriate](#rp-tools)\n* [P.13: Use support libraries as appropriate](#rp-lib)\n\nPhilosophical rules are generally not mechanically checkable.\nHowever, individual rules reflecting these philosophical themes are.\nWithout a philosophical basis, the more concrete/specific/checkable rules lack rationale.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rp-direct\"></a>P.1: Express ideas directly in code",
    "content": "### <a name=\"rp-direct\"></a>P.1: Express ideas directly in code\n\n##### Reason\n\nCompilers don't read comments (or design documents) and neither do many programmers (consistently).\nWhat is expressed in code has defined semantics and can (in principle) be checked by compilers and other tools.\n\n##### Example\n\n    class Date {\n    public:\n        Month month() const;  // do\n        int month();          // don't\n        // ...\n    };\n\nThe first declaration of `month` is explicit about returning a `Month` and about not modifying the state of the `Date` object.\nThe second version leaves the reader guessing and opens more possibilities for uncaught bugs.\n\n##### Example, bad\n\nThis loop is a restricted form of `std::find`:\n\n    void f(vector<string>& v)\n    {\n        string val;\n        cin >> val;\n        // ...\n        int index = -1;                    // bad, plus should use gsl::index\n        for (int i = 0; i < v.size(); ++i) {\n            if (v[i] == val) {\n                index = i;\n                break;\n            }\n        }\n        // ...\n    }\n\n##### Example, good\n\nA much clearer expression of intent would be:\n\n    void f(vector<string>& v)\n    {\n        string val;\n        cin >> val;\n        // ...\n        auto p = find(begin(v), end(v), val);  // better\n        // ...\n    }\n\nA well-designed library expresses intent (what is to be done, rather than just how something is being done) far better than direct use of language features.\n\nA C++ programmer should know the basics of the standard library, and use it where appropriate.\nAny programmer should know the basics of the foundation libraries of the project being worked on, and use them appropriately.\nAny programmer using these guidelines should know the [guidelines support library](#gsl-guidelines-support-library), and use it appropriately.\n\n##### Example\n\n    change_speed(double s);   // bad: what does s signify?\n    // ...\n    change_speed(2.3);\n\nA better approach is to be explicit about the meaning of the double (new speed or delta on old speed?) and the unit used:\n\n    change_speed(Speed s);    // better: the meaning of s is specified\n    // ...\n    change_speed(2.3);        // error: no unit\n    change_speed(23_m / 10s);  // meters per second\n\nWe could have accepted a plain (unit-less) `double` as a delta, but that would have been error-prone.\nIf we wanted both absolute speed and deltas, we would have defined a `Delta` type.\n\n##### Enforcement\n\nVery hard in general.\n\n* use `const` consistently (check if member functions modify their object; check if functions modify arguments passed by pointer or reference)\n* flag uses of casts (casts neuter the type system)\n* detect code that mimics the standard library (hard)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rp-cplusplus\"></a>P.2: Write in ISO Standard C++",
    "content": "### <a name=\"rp-cplusplus\"></a>P.2: Write in ISO Standard C++\n\n##### Reason\n\nThis is a set of guidelines for writing ISO Standard C++.\n\n##### Note\n\nThere are environments where extensions are necessary, e.g., to access system resources.\nIn such cases, localize the use of necessary extensions and control their use with non-core Coding Guidelines.  If possible, build interfaces that encapsulate the extensions so they can be turned off or compiled away on systems that do not support those extensions.\n\nExtensions often do not have rigorously defined semantics.  Even extensions that\nare common and implemented by multiple compilers might have slightly different\nbehaviors and edge case behavior as a direct result of *not* having a rigorous\nstandard definition.  With sufficient use of any such extension, expected\nportability will be impacted.\n\n##### Note\n\nUsing valid ISO C++ does not guarantee portability (let alone correctness).\nAvoid dependence on undefined behavior (e.g., [undefined order of evaluation](#res-order))\nand be aware of constructs with implementation defined meaning (e.g., `sizeof(int)`).\n\n##### Note\n\nThere are environments where restrictions on use of standard C++ language or library features are necessary, e.g., to avoid dynamic memory allocation as required by aircraft control software standards.\nIn such cases, control their (dis)use with an extension of these Coding Guidelines customized to the specific environment.\n\n##### Enforcement\n\nUse an up-to-date C++ compiler (currently C++20 or C++17) with a set of options that do not accept extensions.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rp-what\"></a>P.3: Express intent",
    "content": "### <a name=\"rp-what\"></a>P.3: Express intent\n\n##### Reason\n\nUnless the intent of some code is stated (e.g., in names or comments), it is impossible to tell whether the code does what it is supposed to do.\n\n##### Example\n\n    gsl::index i = 0;\n    while (i < v.size()) {\n        // ... do something with v[i] ...\n    }\n\nThe intent of \"just\" looping over the elements of `v` is not expressed here. The implementation detail of an index is exposed (so that it might be misused), and `i` outlives the scope of the loop, which might or might not be intended. The reader cannot know from just this section of code.\n\nBetter:\n\n    for (const auto& x : v) { /* do something with the value of x */ }\n\nNow, there is no explicit mention of the iteration mechanism, and the loop operates on a reference to `const` elements so that accidental modification cannot happen. If modification is desired, say so:\n\n    for (auto& x : v) { /* modify x */ }\n\nFor more details about for-statements, see [ES.71](#res-for-range).\nSometimes better still, use a named algorithm. This example uses the `for_each` from the Ranges TS because it directly expresses the intent:\n\n    for_each(v, [](int x) { /* do something with the value of x */ });\n    for_each(par, v, [](int x) { /* do something with the value of x */ });\n\nThe last variant makes it clear that we are not interested in the order in which the elements of `v` are handled.\n\nA programmer should be familiar with\n\n* [The guidelines support library](#gsl-guidelines-support-library)\n* [The ISO C++ Standard Library](#sl-the-standard-library)\n* Whatever foundation libraries are used for the current project(s)\n\n##### Note\n\nAlternative formulation: Say what should be done, rather than just how it should be done.\n\n##### Note\n\nSome language constructs express intent better than others.\n\n##### Example\n\nIf two `int`s are meant to be the coordinates of a 2D point, say so:\n\n    draw_line(int, int, int, int);  // obscure: (x1,y1,x2,y2)? (x,y,h,w)? ...?\n                                    // need to look up documentation to know\n\n    draw_line(Point, Point);        // clearer\n\n##### Enforcement\n\nLook for common patterns for which there are better alternatives\n\n* simple `for` loops vs. range-`for` loops\n* `f(T*, int)` interfaces vs. `f(span<T>)` interfaces\n* loop variables in too large a scope\n* naked `new` and `delete`\n* functions with many parameters of built-in types\n\nThere is a huge scope for cleverness and semi-automated program transformation.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rp-typesafe\"></a>P.4: Ideally, a program should be statically type safe",
    "content": "### <a name=\"rp-typesafe\"></a>P.4: Ideally, a program should be statically type safe\n\n##### Reason\n\nIdeally, a program would be completely statically (compile-time) type safe.\nUnfortunately, that is not possible. Problem areas:\n\n* unions\n* casts\n* array decay\n* range errors\n* narrowing conversions\n\n##### Note\n\nThese areas are sources of serious problems (e.g., crashes and security violations).\nWe try to provide alternative techniques.\n\n##### Enforcement\n\nWe can ban, restrain, or detect the individual problem categories separately, as required and feasible for individual programs.\nAlways suggest an alternative.\nFor example:\n\n* unions -- use `variant` (in C++17)\n* casts -- minimize their use; templates can help\n* array decay -- use `span` (from the GSL)\n* range errors -- use `span`\n* narrowing conversions -- minimize their use and use `narrow` or `narrow_cast` (from the GSL) where they are necessary\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rp-compile-time\"></a>P.5: Prefer compile-time checking to run-time checking",
    "content": "### <a name=\"rp-compile-time\"></a>P.5: Prefer compile-time checking to run-time checking\n\n##### Reason\n\nCode clarity and performance.\nYou don't need to write error handlers for errors caught at compile time.\n\n##### Example\n\n    // Int is an alias used for integers\n    int bits = 0;         // don't: avoidable code\n    for (Int i = 1; i; i <<= 1)\n        ++bits;\n    if (bits < 32)\n        cerr << \"Int too small\\n\";\n\nThis example fails to achieve what it is trying to achieve (because overflow is undefined) and should be replaced with a simple `static_assert`:\n\n    // Int is an alias used for integers\n    static_assert(sizeof(Int) >= 4);    // do: compile-time check\n\nOr better still just use the type system and replace `Int` with `int32_t`.\n\n##### Example\n\n    void read(int* p, int n);   // read max n integers into *p\n\n    int a[100];\n    read(a, 1000);    // bad, off the end\n\nbetter\n\n    void read(span<int> r); // read into the range of integers r\n\n    int a[100];\n    read(a);        // better: let the compiler figure out the number of elements\n\n**Alternative formulation**: Don't postpone to run time what can be done well at compile time.\n\n##### Enforcement\n\n* Look for pointer arguments.\n* Look for run-time checks for range violations.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rp-run-time\"></a>P.6: What cannot be checked at compile time should be checkable at run time",
    "content": "### <a name=\"rp-run-time\"></a>P.6: What cannot be checked at compile time should be checkable at run time\n\n##### Reason\n\nLeaving hard-to-detect errors in a program is asking for crashes and bad results.\n\n##### Note\n\nIdeally, we catch all errors (that are not errors in the programmer's logic) at either compile time or run time. It is impossible to catch all errors at compile time and often not affordable to catch all remaining errors at run time. However, we should endeavor to write programs that in principle can be checked, given sufficient resources (analysis programs, run-time checks, machine resources, time).\n\n##### Example, bad\n\n    // separately compiled, possibly dynamically loaded\n    extern void f(int* p);\n\n    void g(int n)\n    {\n        // bad: the number of elements is not passed to f()\n        f(new int[n]);\n    }\n\nHere, a crucial bit of information (the number of elements) has been so thoroughly \"obscured\" that static analysis is probably rendered infeasible and dynamic checking can be very difficult when `f()` is part of an ABI so that we cannot \"instrument\" that pointer. We could embed helpful information into the free store, but that requires global changes to a system and maybe to the compiler. What we have here is a design that makes error detection very hard.\n\n##### Example, bad\n\nWe can of course pass the number of elements along with the pointer:\n\n    // separately compiled, possibly dynamically loaded\n    extern void f2(int* p, int n);\n\n    void g2(int n)\n    {\n        // bad: the wrong number of elements can be passed to f2()\n        f2(new int[n], n);\n    }\n\nPassing the number of elements as an argument is better (and far more common) than just passing the pointer and relying on some (unstated) convention for knowing or discovering the number of elements. However (as shown), a simple typo can introduce a serious error. The connection between the two arguments of `f2()` is conventional, rather than explicit.\n\nAlso, it is implicit that `f2()` is supposed to `delete` its argument (or did the caller make a second mistake?).\n\n##### Example, bad\n\nThe standard library resource management pointers fail to pass the size when they point to an object:\n\n    // separately compiled, possibly dynamically loaded\n    // NB: this assumes the calling code is ABI-compatible, using a\n    // compatible C++ compiler and the same stdlib implementation\n    extern void f3(unique_ptr<int[]>, int n);\n\n    void g3(int n)\n    {\n        f3(make_unique<int[]>(n), m);    // bad: pass ownership and size separately\n    }\n\n##### Example\n\nWe need to pass the pointer and the number of elements as an integral object:\n\n    extern void f4(vector<int>&);   // separately compiled, possibly dynamically loaded\n    extern void f4(span<int>);      // separately compiled, possibly dynamically loaded\n                                    // NB: this assumes the calling code is ABI-compatible, using a\n                                    // compatible C++ compiler and the same stdlib implementation\n\n    void g3(int n)\n    {\n        vector<int> v(n);\n        f4(v);                     // pass a reference, retain ownership\n        f4(span<int>{v});          // pass a view, retain ownership\n    }\n\nThis design carries the number of elements along as an integral part of an object, so that errors are unlikely and dynamic (run-time) checking is always feasible, if not always affordable.\n\n##### Example\n\nHow do we transfer both ownership and all information needed for validating use?\n\n    vector<int> f5(int n)    // OK: move\n    {\n        vector<int> v(n);\n        // ... initialize v ...\n        return v;\n    }\n\n    unique_ptr<int[]> f6(int n)    // bad: loses n\n    {\n        auto p = make_unique<int[]>(n);\n        // ... initialize *p ...\n        return p;\n    }\n\n    owner<int*> f7(int n)    // bad: loses n and we might forget to delete\n    {\n        owner<int*> p = new int[n];\n        // ... initialize *p ...\n        return p;\n    }\n\n##### Example\n\n* ???\n* show how possible checks are avoided by interfaces that pass polymorphic base classes around, when they actually know what they need?\n  Or strings as \"free-style\" options\n\n##### Enforcement\n\n* Flag (pointer, count)-style interfaces (this will flag a lot of examples that can't be fixed for compatibility reasons)\n* ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rp-early\"></a>P.7: Catch run-time errors early",
    "content": "### <a name=\"rp-early\"></a>P.7: Catch run-time errors early\n\n##### Reason\n\nAvoid \"mysterious\" crashes.\nAvoid errors leading to (possibly unrecognized) wrong results.\n\n##### Example\n\n    void increment1(int* p, int n)    // bad: error-prone\n    {\n        for (int i = 0; i < n; ++i) ++p[i];\n    }\n\n    void use1(int m)\n    {\n        const int n = 10;\n        int a[n] = {};\n        // ...\n        increment1(a, m);   // maybe typo, maybe m <= n is supposed\n                            // but assume that m == 20\n        // ...\n    }\n\nHere we made a small error in `use1` that will lead to corrupted data or a crash.\nThe (pointer, count)-style interface leaves `increment1()` with no realistic way of defending itself against out-of-range errors.\nIf we could check subscripts for out of range access, then the error would not be discovered until `p[10]` was accessed.\nWe could check earlier and improve the code:\n\n    void increment2(span<int> p)\n    {\n        for (int& x : p) ++x;\n    }\n\n    void use2(int m)\n    {\n        const int n = 10;\n        int a[n] = {};\n        // ...\n        increment2({a, m});    // maybe typo, maybe m <= n is supposed\n        // ...\n    }\n\nNow, `m <= n` can be checked at the point of call (early) rather than later.\nIf all we had was a typo so that we meant to use `n` as the bound, the code could be further simplified (eliminating the possibility of an error):\n\n    void use3(int m)\n    {\n        const int n = 10;\n        int a[n] = {};\n        // ...\n        increment2(a);   // the number of elements of a need not be repeated\n        // ...\n    }\n\n##### Example, bad\n\nDon't repeatedly check the same value. Don't pass structured data as strings:\n\n    Date read_date(istream& is);    // read date from istream\n\n    Date extract_date(const string& s);    // extract date from string\n\n    void user1(const string& date)    // manipulate date\n    {\n        auto d = extract_date(date);\n        // ...\n    }\n\n    void user2()\n    {\n        Date d = read_date(cin);\n        // ...\n        user1(d.to_string());\n        // ...\n    }\n\nThe date is validated twice (by the `Date` constructor) and passed as a character string (unstructured data).\n\n##### Example\n\nExcess checking can be costly.\nThere are cases where checking early is inefficient because you might never need the value, or might only need part of the value that is more easily checked than the whole.  Similarly, don't add validity checks that change the asymptotic behavior of your interface (e.g., don't add a `O(n)` check to an interface with an average complexity of `O(1)`).\n\n    class Jet {    // Physics says: e * e < x * x + y * y + z * z\n        float x;\n        float y;\n        float z;\n        float e;\n    public:\n        Jet(float x, float y, float z, float e)\n            :x(x), y(y), z(z), e(e)\n        {\n            // Should I check here that the values are physically meaningful?\n        }\n\n        float m() const\n        {\n            // Should I handle the degenerate case here?\n            return sqrt(x * x + y * y + z * z - e * e);\n        }\n\n        ???\n    };\n\nThe physical law for a jet (`e * e < x * x + y * y + z * z`) is not an invariant because of the possibility for measurement errors.\n\n???\n\n##### Enforcement\n\n* Look at pointers and arrays: Do range-checking early and not repeatedly\n* Look at conversions: Eliminate or mark narrowing conversions\n* Look for unchecked values coming from input\n* Look for structured data (objects of classes with invariants) being converted into strings\n* ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rp-leak\"></a>P.8: Don't leak any resources",
    "content": "### <a name=\"rp-leak\"></a>P.8: Don't leak any resources\n\n##### Reason\n\nEven a slow growth in resources will, over time, exhaust the availability of those resources.\nThis is particularly important for long-running programs, but is an essential piece of responsible programming behavior.\n\n##### Example, bad\n\n    void f(const char* name)\n    {\n        FILE* input = fopen(name, \"r\");\n        // ...\n        if (something) return;   // bad: if something == true, a file handle is leaked\n        // ...\n        fclose(input);\n    }\n\nPrefer [RAII](#rr-raii):\n\n    void f(const char* name)\n    {\n        ifstream input {name};\n        // ...\n        if (something) return;   // OK: no leak\n        // ...\n    }\n\n**See also**: [The resource management section](#s-resource)\n\n##### Note\n\nA leak is colloquially \"anything that isn't cleaned up.\"\nThe more important classification is \"anything that can no longer be cleaned up.\"\nFor example, allocating an object on the heap and then losing the last pointer that points to that allocation.\nThis rule should not be taken as requiring that allocations within long-lived objects must be returned during program shutdown.\nFor example, relying on system guaranteed cleanup such as file closing and memory deallocation upon process shutdown can simplify code.\nHowever, relying on abstractions that implicitly clean up can be as simple, and often safer.\n\n##### Note\n\nEnforcing [the lifetime safety profile](#ss-lifetime) eliminates leaks.\nWhen combined with resource safety provided by [RAII](#rr-raii), it eliminates the need for \"garbage collection\" (by generating no garbage).\nCombine this with enforcement of [the type and bounds profiles](#ss-force) and you get complete type- and resource-safety, guaranteed by tools.\n\n##### Enforcement\n\n* Look at pointers: Classify them into non-owners (the default) and owners.\n  Where feasible, replace owners with standard-library resource handles (as in the example above).\n  Alternatively, mark an owner as such using `owner` from [the GSL](#gsl-guidelines-support-library).\n* Look for naked `new` and `delete`\n* Look for known resource allocating functions returning raw pointers (such as `fopen`, `malloc`, and `strdup`)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rp-waste\"></a>P.9: Don't waste time or space",
    "content": "### <a name=\"rp-waste\"></a>P.9: Don't waste time or space\n\n##### Reason\n\nThis is C++.\n\n##### Note\n\nTime and space that you spend well to achieve a goal (e.g., speed of development, resource safety, or simplification of testing) is not wasted.\n\"Another benefit of striving for efficiency is that the process forces you to understand the problem in more depth.\" - Alex Stepanov\n\n##### Example, bad\n\n    struct X {\n        char ch;\n        int i;\n        string s;\n        char ch2;\n\n        X& operator=(const X& a);\n        X(const X&);\n    };\n\n    X waste(const char* p)\n    {\n        if (!p) throw Nullptr_error{};\n        int n = strlen(p);\n        auto buf = new char[n];\n        if (!buf) throw Allocation_error{};\n        for (int i = 0; i < n; ++i) buf[i] = p[i];\n        // ... manipulate buffer ...\n        X x;\n        x.ch = 'a';\n        x.s = string(n);    // give x.s space for *p\n        for (gsl::index i = 0; i < x.s.size(); ++i) x.s[i] = buf[i];  // copy buf into x.s\n        delete[] buf;\n        return x;\n    }\n\n    void driver()\n    {\n        X x = waste(\"Typical argument\");\n        // ...\n    }\n\nYes, this is a caricature, but we have seen every individual mistake in production code, and worse.\nNote that the layout of `X` guarantees that at least 6 bytes (and most likely more) are wasted.\nThe spurious definition of copy operations disables move semantics so that the return operation is slow\n(please note that the Return Value Optimization, RVO, is not guaranteed here).\nThe use of `new` and `delete` for `buf` is redundant; if we really needed a local string, we should use a local `string`.\nThere are several more performance bugs and gratuitous complication.\n\n##### Example, bad\n\n    void lower(zstring s)\n    {\n        for (int i = 0; i < strlen(s); ++i) s[i] = tolower(s[i]);\n    }\n\nThis is actually an example from production code.\nWe can see that in our condition we have `i < strlen(s)`. This expression will be evaluated on every iteration of the loop, which means that `strlen` must walk through string every loop to discover its length. While the string contents are changing, it's assumed that `tolower` will not affect the length of the string, so it's better to cache the length outside the loop and not incur that cost each iteration.\n\n##### Note\n\nAn individual example of waste is rarely significant, and where it is significant, it is typically easily eliminated by an expert.\nHowever, waste spread liberally across a code base can easily be significant and experts are not always as available as we would like.\nThe aim of this rule (and the more specific rules that support it) is to eliminate most waste related to the use of C++ before it happens.\nAfter that, we can look at waste related to algorithms and requirements, but that is beyond the scope of these guidelines.\n\n##### Enforcement\n\nMany more specific rules aim at the overall goals of simplicity and elimination of gratuitous waste.\n\n* Flag an unused return value from a user-defined non-defaulted postfix `operator++` or `operator--` function. Prefer using the prefix form instead. (Note: \"User-defined non-defaulted\" is intended to reduce noise. Review this enforcement if it's still too noisy in practice.)\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rp-mutable\"></a>P.10: Prefer immutable data to mutable data",
    "content": "### <a name=\"rp-mutable\"></a>P.10: Prefer immutable data to mutable data\n\n##### Reason\n\nIt is easier to reason about constants than about variables.\nSomething immutable cannot change unexpectedly.\nSometimes immutability enables better optimization.\nYou can't have a data race on a constant.\n\nSee [Con: Constants and immutability](#s-const)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rp-library\"></a>P.11: Encapsulate messy constructs, rather than spreading through the code",
    "content": "### <a name=\"rp-library\"></a>P.11: Encapsulate messy constructs, rather than spreading through the code\n\n##### Reason\n\nMessy code is more likely to hide bugs and harder to write.\nA good interface is easier and safer to use.\nMessy, low-level code breeds more such code.\n\n##### Example\n\n    int sz = 100;\n    int* p = (int*) malloc(sizeof(int) * sz);\n    int count = 0;\n    // ...\n    for (;;) {\n        // ... read an int into x, exit loop if end of file is reached ...\n        // ... check that x is valid ...\n        if (count == sz)\n            p = (int*) realloc(p, sizeof(int) * sz * 2);\n        p[count++] = x;\n        // ...\n    }\n\nThis is low-level, verbose, and error-prone.\nFor example, we \"forgot\" to test for memory exhaustion and assign new value to `sz`.\nInstead, we could use `vector`:\n\n    vector<int> v;\n    v.reserve(100);\n    // ...\n    for (int x; cin >> x; ) {\n        // ... check that x is valid ...\n        v.push_back(x);\n    }\n\n##### Note\n\nThe standards library and the GSL are examples of this philosophy.\nFor example, instead of messing with the arrays, unions, cast, tricky lifetime issues, `gsl::owner`, etc.,\nthat are needed to implement key abstractions, such as `vector`, `span`, `lock_guard`, and `future`, we use the libraries\ndesigned and implemented by people with more time and expertise than we usually have.\nSimilarly, we can and should design and implement more specialized libraries, rather than leaving the users (often ourselves)\nwith the challenge of repeatedly getting low-level code well.\nThis is a variant of the [subset of superset principle](#r0) that underlies these guidelines.\n\n##### Enforcement\n\n* Look for \"messy code\" such as complex pointer manipulation and casting outside the implementation of abstractions.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rp-tools\"></a>P.12: Use supporting tools as appropriate",
    "content": "### <a name=\"rp-tools\"></a>P.12: Use supporting tools as appropriate\n\n##### Reason\n\nThere are many things that are done better \"by machine\".\nComputers don't tire or get bored by repetitive tasks.\nWe typically have better things to do than repeatedly do routine tasks.\n\n##### Example\n\nRun a static analyzer to verify that your code follows the guidelines you want it to follow.\n\n##### Note\n\nSee\n\n* [Static analysis tools](https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis)\n* [Concurrency tools](#rconc-tools)\n* [Testing tools](https://github.com/isocpp/CppCoreGuidelines/tree/master)\n\nThere are many other kinds of tools, such as source code repositories, build tools, etc.,\nbut those are beyond the scope of these guidelines.\n\n##### Note\n\nBe careful not to become dependent on over-elaborate or over-specialized tool chains.\nThose can make your otherwise portable code non-portable.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rp-lib\"></a>P.13: Use support libraries as appropriate",
    "content": "### <a name=\"rp-lib\"></a>P.13: Use support libraries as appropriate\n\n##### Reason\n\nUsing a well-designed, well-documented, and well-supported library saves time and effort;\nits quality and documentation are likely to be greater than what you could do\nif the majority of your time must be spent on an implementation.\nThe cost (time, effort, money, etc.) of a library can be shared over many users.\nA widely used library is more likely to be kept up-to-date and ported to new systems than an individual application.\nKnowledge of a widely-used library can save time on other/future projects.\nSo, if a suitable library exists for your application domain, use it.\n\n##### Example\n\n    std::sort(begin(v), end(v), std::greater<>());\n\nUnless you are an expert in sorting algorithms and have plenty of time,\nthis is more likely to be correct and to run faster than anything you write for a specific application.\nYou need a reason not to use the standard library (or whatever foundational libraries your application uses) rather than a reason to use it.\n\n##### Note\n\nBy default use\n\n* The [ISO C++ Standard Library](#sl-the-standard-library)\n* The [Guidelines Support Library](#gsl-guidelines-support-library)\n\n##### Note\n\nIf no well-designed, well-documented, and well-supported library exists for an important domain,\nmaybe you should design and implement it, and then use it.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-interfaces\"></a>I: Interfaces",
    "content": "# <a name=\"s-interfaces\"></a>I: Interfaces\n\nAn interface is a contract between two parts of a program. Precisely stating what is expected of a supplier of a service and a user of that service is essential.\nHaving good (easy-to-understand, encouraging efficient use, not error-prone, supporting testing, etc.) interfaces is probably the most important single aspect of code organization.\n\nInterface rule summary:\n\n* [I.1: Make interfaces explicit](#ri-explicit)\n* [I.2: Avoid non-`const` global variables](#ri-global)\n* [I.3: Avoid singletons](#ri-singleton)\n* [I.4: Make interfaces precisely and strongly typed](#ri-typed)\n* [I.5: State preconditions (if any)](#ri-pre)\n* [I.6: Prefer `Expects()` for expressing preconditions](#ri-expects)\n* [I.7: State postconditions](#ri-post)\n* [I.8: Prefer `Ensures()` for expressing postconditions](#ri-ensures)\n* [I.9: If an interface is a template, document its parameters using concepts](#ri-concepts)\n* [I.10: Use exceptions to signal a failure to perform a required task](#ri-except)\n* [I.11: Never transfer ownership by a raw pointer (`T*`) or reference (`T&`)](#ri-raw)\n* [I.12: Declare a pointer that must not be null as `not_null`](#ri-nullptr)\n* [I.13: Do not pass an array as a single pointer](#ri-array)\n* [I.22: Avoid complex initialization of global objects](#ri-global-init)\n* [I.23: Keep the number of function arguments low](#ri-nargs)\n* [I.24: Avoid adjacent parameters that can be invoked by the same arguments in either order with different meaning](#ri-unrelated)\n* [I.25: Prefer empty abstract classes as interfaces to class hierarchies](#ri-abstract)\n* [I.26: If you want a cross-compiler ABI, use a C-style subset](#ri-abi)\n* [I.27: For stable library ABI, consider the Pimpl idiom](#ri-pimpl)\n* [I.30: Encapsulate rule violations](#ri-encapsulate)\n\n**See also**:\n\n* [F: Functions](#s-functions)\n* [C.concrete: Concrete types](#ss-concrete)\n* [C.hier: Class hierarchies](#ss-hier)\n* [C.over: Overloading and overloaded operators](#ss-overload)\n* [C.con: Containers and other resource handles](#ss-containers)\n* [E: Error handling](#s-errors)\n* [T: Templates and generic programming](#s-templates)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ri-explicit\"></a>I.1: Make interfaces explicit",
    "content": "### <a name=\"ri-explicit\"></a>I.1: Make interfaces explicit\n\n##### Reason\n\nCorrectness. Assumptions not stated in an interface are easily overlooked and hard to test.\n\n##### Example, bad\n\nControlling the behavior of a function through a global (namespace scope) variable (a call mode) is implicit and potentially confusing. For example:\n\n    int round(double d)\n    {\n        return (round_up) ? ceil(d) : d;    // don't: \"invisible\" dependency\n    }\n\nIt will not be obvious to a caller that the meaning of two calls of `round(7.2)` might give different results.\n\n##### Exception\n\nSometimes we control the details of a set of operations by an environment variable, e.g., normal vs. verbose output or debug vs. optimized.\nThe use of a non-local control is potentially confusing, but controls only implementation details of otherwise fixed semantics.\n\n##### Example, bad\n\nReporting through non-local variables (e.g., `errno`) is easily ignored. For example:\n\n    // don't: no test of fprintf's return value\n    fprintf(connection, \"logging: %d %d %d\\n\", x, y, s);\n\nWhat if the connection goes down so that no logging output is produced? See I.???.\n\n**Alternative**: Throw an exception. An exception cannot be ignored.\n\n**Alternative formulation**: Avoid passing information across an interface through non-local or implicit state.\nNote that non-`const` member functions pass information to other member functions through their object's state.\n\n**Alternative formulation**: An interface should be a function or a set of functions.\nFunctions can be function templates and sets of functions can be classes or class templates.\n\n##### Enforcement\n\n* (Simple) A function should not make control-flow decisions based on the values of variables declared at namespace scope.\n* (Simple) A function should not write to variables declared at namespace scope.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ri-global\"></a>I.2: Avoid non-`const` global variables",
    "content": "### <a name=\"ri-global\"></a>I.2: Avoid non-`const` global variables\n\n##### Reason\n\nNon-`const` global variables hide dependencies and make the dependencies subject to unpredictable changes.\n\n##### Example\n\n    struct Data {\n        // ... lots of stuff ...\n    } data;            // non-const data\n\n    void compute()     // don't\n    {\n        // ... use data ...\n    }\n\n    void output()     // don't\n    {\n        // ... use data ...\n    }\n\nWho else might modify `data`?\n\n**Warning**: The initialization of global objects is not totally ordered.\nIf you use a global object initialize it with a constant.\nNote that it is possible to get undefined initialization order even for `const` objects.\n\n##### Exception\n\nA global object is often better than a singleton.\n\n##### Note\n\nGlobal constants are useful.\n\n##### Note\n\nThe rule against global variables applies to namespace scope variables as well.\n\n**Alternative**: If you use global (more generally namespace scope) data to avoid copying, consider passing the data as an object by reference to `const`.\nAnother solution is to define the data as the state of some object and the operations as member functions.\n\n**Warning**: Beware of data races: If one thread can access non-local data (or data passed by reference) while another thread executes the callee, we can have a data race.\nEvery pointer or reference to mutable data is a potential data race.\n\nUsing global pointers or references to access and change non-const, and otherwise non-global,\ndata isn't a better alternative to non-const global variables since that doesn't solve the issues of hidden dependencies or potential race conditions.\n\n##### Note\n\nYou cannot have a race condition on immutable data.\n\n**References**: See the [rules for calling functions](#ss-call).\n\n##### Note\n\nThe rule is \"avoid\", not \"don't use.\" Of course there will be (rare) exceptions, such as `cin`, `cout`, and `cerr`.\n\n##### Enforcement\n\n(Simple) Report all non-`const` variables declared at namespace scope and global pointers/references to non-const data.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ri-singleton\"></a>I.3: Avoid singletons",
    "content": "### <a name=\"ri-singleton\"></a>I.3: Avoid singletons\n\n##### Reason\n\nSingletons are basically complicated global objects in disguise.\n\n##### Example\n\n    class Singleton {\n        // ... lots of stuff to ensure that only one Singleton object is created,\n        // that it is initialized properly, etc.\n    };\n\nThere are many variants of the singleton idea.\nThat's part of the problem.\n\n##### Note\n\nIf you don't want a global object to change, declare it `const` or `constexpr`.\n\n##### Exception\n\nYou can use the simplest \"singleton\" (so simple that it is often not considered a singleton) to get initialization on first use, if any:\n\n    X& myX()\n    {\n        static X my_x {3};\n        return my_x;\n    }\n\nThis is one of the most effective solutions to problems related to initialization order.\nIn a multi-threaded environment, the initialization of the static object does not introduce a race condition\n(unless you carelessly access a shared object from within its constructor).\n\nNote that the initialization of a local `static` does not imply a race condition.\nHowever, if the destruction of `X` involves an operation that needs to be synchronized we must use a less simple solution.\nFor example:\n\n    X& myX()\n    {\n        static auto p = new X {3};\n        return *p;  // potential leak\n    }\n\nNow someone must `delete` that object in some suitably thread-safe way.\nThat's error-prone, so we don't use that technique unless\n\n* `myX` is in multi-threaded code,\n* that `X` object needs to be destroyed (e.g., because it releases a resource), and\n* `X`'s destructor's code needs to be synchronized.\n\nIf you, as many do, define a singleton as a class for which only one object is created, functions like `myX` are not singletons, and this useful technique is not an exception to the no-singleton rule.\n\n##### Enforcement\n\nVery hard in general.\n\n* Look for classes with names that include `singleton`.\n* Look for classes for which only a single object is created (by counting objects or by examining constructors).\n* If a class X has a public static function that contains a function-local static of the class' type X and returns a pointer or reference to it, ban that.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ri-typed\"></a>I.4: Make interfaces precisely and strongly typed",
    "content": "### <a name=\"ri-typed\"></a>I.4: Make interfaces precisely and strongly typed\n\n##### Reason\n\nTypes are the simplest and best documentation, improve legibility due to their well-defined meaning, and are checked at compile time.\nAlso, precisely typed code is often optimized better.\n\n##### Example, don't\n\nConsider:\n\n    void pass(void* data);    // weak and under-qualified type void* is suspicious\n\nCallers are unsure what types are allowed and if the data may\nbe mutated as `const` is not specified. Note all pointer types\nimplicitly convert to `void*`, so it is easy for callers to provide this value.\n\nThe callee must `static_cast` data to an unverified type to use it.\nThat is error-prone and verbose.\n\nOnly use `const void*` for passing in data in designs that are indescribable in C++. Consider using a `variant` or a pointer to base instead.\n\n**Alternative**: Often, a template parameter can eliminate the `void*` turning it into a `T*` or `T&`.\nFor generic code these `T`s can be general or concept constrained template parameters.\n\n##### Example, bad\n\nConsider:\n\n    draw_rect(100, 200, 100, 500); // what do the numbers specify?\n\n    draw_rect(p.x, p.y, 10, 20); // what units are 10 and 20 in?\n\nIt is clear that the caller is describing a rectangle, but it is unclear what parts they relate to. Also, an `int` can carry arbitrary forms of information, including values of many units, so we must guess about the meaning of the four `int`s. Most likely, the first two are an `x`,`y` coordinate pair, but what are the last two?\n\nComments and parameter names can help, but we could be explicit:\n\n    void draw_rectangle(Point top_left, Point bottom_right);\n    void draw_rectangle(Point top_left, Size height_width);\n\n    draw_rectangle(p, Point{10, 20});  // two corners\n    draw_rectangle(p, Size{10, 20});   // one corner and a (height, width) pair\n\nObviously, we cannot catch all errors through the static type system\n(e.g., the fact that a first argument is supposed to be a top-left point is left to convention (naming and comments)).\n\n##### Example, bad\n\nConsider:\n\n    set_settings(true, false, 42); // what do the numbers specify?\n\nThe parameter types and their values do not communicate what settings are being specified or what those values mean.\n\nThis design is more explicit, safe and legible:\n\n    alarm_settings s{};\n    s.enabled = true;\n    s.displayMode = alarm_settings::mode::spinning_light;\n    s.frequency = alarm_settings::every_10_seconds;\n    set_settings(s);\n\nFor the case of a set of boolean values consider using a flags `enum`; a pattern that expresses a set of boolean values.\n\n    enable_lamp_options(lamp_option::on | lamp_option::animate_state_transitions);\n\n##### Example, bad\n\nIn the following example, it is not clear from the interface what `time_to_blink` means: Seconds? Milliseconds?\n\n    void blink_led(int time_to_blink) // bad -- the unit is ambiguous\n    {\n        // ...\n        // do something with time_to_blink\n        // ...\n    }\n\n    void use()\n    {\n        blink_led(2);\n    }\n\n##### Example, good\n\n`std::chrono::duration` types help making the unit of time duration explicit.\n\n    void blink_led(milliseconds time_to_blink) // good -- the unit is explicit\n    {\n        // ...\n        // do something with time_to_blink\n        // ...\n    }\n\n    void use()\n    {\n        blink_led(1500ms);\n    }\n\nThe function can also be written in such a way that it will accept any time duration unit.\n\n    template<class rep, class period>\n    void blink_led(duration<rep, period> time_to_blink) // good -- accepts any unit\n    {\n        // assuming that millisecond is the smallest relevant unit\n        auto milliseconds_to_blink = duration_cast<milliseconds>(time_to_blink);\n        // ...\n        // do something with milliseconds_to_blink\n        // ...\n    }\n\n    void use()\n    {\n        blink_led(2s);\n        blink_led(1500ms);\n    }\n\n##### Enforcement\n\n* (Simple) Report the use of `void*` as a parameter or return type.\n* (Simple) Report the use of more than one `bool` parameter.\n* (Hard to do well) Look for functions that use too many primitive type arguments.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ri-pre\"></a>I.5: State preconditions (if any)",
    "content": "### <a name=\"ri-pre\"></a>I.5: State preconditions (if any)\n\n##### Reason\n\nArguments have meaning that might constrain their proper use in the callee.\n\n##### Example\n\nConsider:\n\n    double sqrt(double x);\n\nHere `x` must be non-negative. The type system cannot (easily and naturally) express that, so we must use other means. For example:\n\n    double sqrt(double x); // x must be non-negative\n\nSome preconditions can be expressed as assertions. For example:\n\n    double sqrt(double x) { Expects(x >= 0); /* ... */ }\n\nIdeally, that `Expects(x >= 0)` should be part of the interface of `sqrt()` but that's not easily done. For now, we place it in the definition (function body).\n\n**References**: `Expects()` is described in [GSL](#gsl-guidelines-support-library).\n\n##### Note\n\nPrefer a formal specification of requirements, such as `Expects(p);`.\nIf that is infeasible, use English text in comments, such as `// the sequence [p:q) is ordered using <`.\n\n##### Note\n\nMost member functions have as a precondition that some class invariant holds.\nThat invariant is established by a constructor and must be reestablished upon exit by every member function called from outside the class.\nWe don't need to mention it for each member function.\n\n##### Enforcement\n\n(Not enforceable)\n\n**See also**: The rules for passing pointers. ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ri-expects\"></a>I.6: Prefer `Expects()` for expressing preconditions",
    "content": "### <a name=\"ri-expects\"></a>I.6: Prefer `Expects()` for expressing preconditions\n\n##### Reason\n\nTo make it clear that the condition is a precondition and to enable tool use.\n\n##### Example\n\n    int area(int height, int width)\n    {\n        Expects(height > 0 && width > 0);            // good\n        if (height <= 0 || width <= 0) my_error();   // obscure\n        // ...\n    }\n\n##### Note\n\nPreconditions can be stated in many ways, including comments, `if`-statements, and `assert()`.\nThis can make them hard to distinguish from ordinary code, hard to update, hard to manipulate by tools, and might have the wrong semantics (do you always want to abort in debug mode and check nothing in productions runs?).\n\n##### Note\n\nPreconditions should be part of the interface rather than part of the implementation,\nbut we don't yet have the language facilities to do that.\nOnce language support becomes available (e.g., see the [contract proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf)) we will adopt the standard version of preconditions, postconditions, and assertions.\n\n##### Note\n\n`Expects()` can also be used to check a condition in the middle of an algorithm.\n\n##### Note\n\nNo, using `unsigned` is not a good way to sidestep the problem of [ensuring that a value is non-negative](#res-nonnegative).\n\n##### Enforcement\n\n(Not enforceable) Finding the variety of ways preconditions can be asserted is not feasible. Warning about those that can be easily identified (`assert()`) has questionable value in the absence of a language facility.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ri-post\"></a>I.7: State postconditions",
    "content": "### <a name=\"ri-post\"></a>I.7: State postconditions\n\n##### Reason\n\nTo detect misunderstandings about the result and possibly catch erroneous implementations.\n\n##### Example, bad\n\nConsider:\n\n    int area(int height, int width) { return height * width; }  // bad\n\nHere, we (incautiously) left out the precondition specification, so it is not explicit that height and width must be positive.\nWe also left out the postcondition specification, so it is not obvious that the algorithm (`height * width`) is wrong for areas larger than the largest integer.\nOverflow can happen.\nConsider using:\n\n    int area(int height, int width)\n    {\n        auto res = height * width;\n        Ensures(res > 0);\n        return res;\n    }\n\n##### Example, bad\n\nConsider a famous security bug:\n\n    void f()    // problematic\n    {\n        char buffer[MAX];\n        // ...\n        memset(buffer, 0, sizeof(buffer));\n    }\n\nThere was no postcondition stating that the buffer should be cleared and the optimizer eliminated the apparently redundant `memset()` call:\n\n    void f()    // better\n    {\n        char buffer[MAX];\n        // ...\n        memset(buffer, 0, sizeof(buffer));\n        Ensures(buffer[0] == 0);\n    }\n\n##### Note\n\nPostconditions are often informally stated in a comment that states the purpose of a function; `Ensures()` can be used to make this more systematic, visible, and checkable.\n\n##### Note\n\nPostconditions are especially important when they relate to something that is not directly reflected in a returned result, such as a state of a data structure used.\n\n##### Example\n\nConsider a function that manipulates a `Record`, using a `mutex` to avoid race conditions:\n\n    mutex m;\n\n    void manipulate(Record& r)    // don't\n    {\n        m.lock();\n        // ... no m.unlock() ...\n    }\n\nHere, we \"forgot\" to state that the `mutex` should be released, so we don't know if the failure to ensure release of the `mutex` was a bug or a feature.\nStating the postcondition would have made it clear:\n\n    void manipulate(Record& r)    // postcondition: m is unlocked upon exit\n    {\n        m.lock();\n        // ... no m.unlock() ...\n    }\n\nThe bug is now obvious (but only to a human reading comments).\n\nBetter still, use [RAII](#rr-raii) to ensure that the postcondition (\"the lock must be released\") is enforced in code:\n\n    void manipulate(Record& r)    // best\n    {\n        lock_guard<mutex> _ {m};\n        // ...\n    }\n\n##### Note\n\nIdeally, postconditions are stated in the interface/declaration so that users can easily see them.\nOnly postconditions related to the users can be stated in the interface.\nPostconditions related only to internal state belong in the definition/implementation.\n\n##### Enforcement\n\n(Not enforceable) This is a philosophical guideline that is infeasible to check\ndirectly in the general case. Domain specific checkers (like lock-holding\ncheckers) exist for many toolchains.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ri-ensures\"></a>I.8: Prefer `Ensures()` for expressing postconditions",
    "content": "### <a name=\"ri-ensures\"></a>I.8: Prefer `Ensures()` for expressing postconditions\n\n##### Reason\n\nTo make it clear that the condition is a postcondition and to enable tool use.\n\n##### Example\n\n    void f()\n    {\n        char buffer[MAX];\n        // ...\n        memset(buffer, 0, MAX);\n        Ensures(buffer[0] == 0);\n    }\n\n##### Note\n\nPostconditions can be stated in many ways, including comments, `if`-statements, and `assert()`.\nThis can make them hard to distinguish from ordinary code, hard to update, hard to manipulate by tools, and might have the wrong semantics.\n\n**Alternative**: Postconditions of the form \"this resource must be released\" are best expressed by [RAII](#rr-raii).\n\n##### Note\n\nIdeally, that `Ensures` should be part of the interface, but that's not easily done.\nFor now, we place it in the definition (function body).\nOnce language support becomes available (e.g., see the [contract proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf)) we will adopt the standard version of preconditions, postconditions, and assertions.\n\n##### Enforcement\n\n(Not enforceable) Finding the variety of ways postconditions can be asserted is not feasible. Warning about those that can be easily identified (`assert()`) has questionable value in the absence of a language facility.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ri-concepts\"></a>I.9: If an interface is a template, document its parameters using concepts",
    "content": "### <a name=\"ri-concepts\"></a>I.9: If an interface is a template, document its parameters using concepts\n\n##### Reason\n\nMake the interface precisely specified and compile-time checkable in the (not so distant) future.\n\n##### Example\n\nUse the C++20 style of requirements specification. For example:\n\n    template<typename Iter, typename Val>\n      requires input_iterator<Iter> && equality_comparable_with<iter_value_t<Iter>, Val>\n    Iter find(Iter first, Iter last, Val v)\n    {\n        // ...\n    }\n\n**See also**: [Generic programming](#ss-gp) and [concepts](#ss-concepts).\n\n##### Enforcement\n\nWarn if any non-variadic template parameter is not constrained by a concept (in its declaration or mentioned in a `requires` clause).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ri-except\"></a>I.10: Use exceptions to signal a failure to perform a required task",
    "content": "### <a name=\"ri-except\"></a>I.10: Use exceptions to signal a failure to perform a required task\n\n##### Reason\n\nIt should not be possible to ignore an error because that could leave the system or a computation in an undefined (or unexpected) state.\nThis is a major source of errors.\n\n##### Example\n\n    int printf(const char* ...);    // bad: return negative number if output fails\n\n    template<class F, class ...Args>\n    // good: throw system_error if unable to start the new thread\n    explicit thread(F&& f, Args&&... args);\n\n##### Note\n\nWhat is an error?\n\nAn error means that the function cannot achieve its advertised purpose (including establishing postconditions).\nCalling code that ignores an error could lead to wrong results or undefined systems state.\nFor example, not being able to connect to a remote server is not by itself an error:\nthe server can refuse a connection for all kinds of reasons, so the natural thing is to return a result that the caller should always check.\nHowever, if failing to make a connection is considered an error, then a failure should throw an exception.\n\n##### Exception\n\nMany traditional interface functions (e.g., UNIX signal handlers) use error codes (e.g., `errno`) to report what are really status codes, rather than errors. You don't have a good alternative to using such, so calling these does not violate the rule.\n\n##### Alternative\n\nIf you can't use exceptions (e.g., because your code is full of old-style raw-pointer use or because there are hard-real-time constraints), consider using a style that returns a pair of values:\n\n    int val;\n    int error_code;\n    tie(val, error_code) = do_something();\n    if (error_code) {\n        // ... handle the error or exit ...\n    }\n    // ... use val ...\n\nThis style unfortunately leads to uninitialized variables.\nSince C++17 the \"structured bindings\" feature can be used to initialize variables directly from the return value:\n\n    auto [val, error_code] = do_something();\n    if (error_code) {\n        // ... handle the error or exit ...\n    }\n    // ... use val ...\n\n##### Note\n\nWe don't consider \"performance\" a valid reason not to use exceptions.\n\n* Often, explicit error checking and handling consume as much time and space as exception handling.\n* Often, cleaner code yields better performance with exceptions (simplifying the tracing of paths through the program and their optimization).\n* A good rule for performance critical code is to move checking outside the [critical](#rper-critical) part of the code.\n* In the longer term, more regular code gets better optimized.\n* Always carefully [measure](#rper-measure) before making performance claims.\n\n**See also**: [I.5](#ri-pre) and [I.7](#ri-post) for reporting precondition and postcondition violations.\n\n##### Enforcement\n\n* (Not enforceable) This is a philosophical guideline that is infeasible to check directly.\n* Look for `errno`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ri-raw\"></a>I.11: Never transfer ownership by a raw pointer (`T*`) or reference (`T&`)",
    "content": "### <a name=\"ri-raw\"></a>I.11: Never transfer ownership by a raw pointer (`T*`) or reference (`T&`)\n\n##### Reason\n\nIf there is any doubt whether the caller or the callee owns an object, leaks or premature destruction will occur.\n\n##### Example\n\nConsider:\n\n    X* compute(args)    // don't\n    {\n        X* res = new X{};\n        // ...\n        return res;\n    }\n\nWho deletes the returned `X`? The problem would be harder to spot if `compute` returned a reference.\nConsider returning the result by value (use move semantics if the result is large):\n\n    vector<double> compute(args)  // good\n    {\n        vector<double> res(10000);\n        // ...\n        return res;\n    }\n\n**Alternative**: [Pass ownership](#rr-smartptrparam) using a \"smart pointer\", such as `unique_ptr` (for exclusive ownership) and `shared_ptr` (for shared ownership).\nHowever, that is less elegant and often less efficient than returning the object itself,\nso use smart pointers only if reference semantics are needed.\n\n**Alternative**: Sometimes older code can't be modified because of ABI compatibility requirements or lack of resources.\nIn that case, mark owning pointers using `owner` from the [guidelines support library](#gsl-guidelines-support-library):\n\n    owner<X*> compute(args)    // It is now clear that ownership is transferred\n    {\n        owner<X*> res = new X{};\n        // ...\n        return res;\n    }\n\nThis tells analysis tools that `res` is an owner.\nThat is, its value must be `delete`d or transferred to another owner, as is done here by the `return`.\n\n`owner` is used similarly in the implementation of resource handles.\n\n##### Note\n\nEvery object passed as a raw pointer (or iterator) is assumed to be owned by the\ncaller, so that its lifetime is handled by the caller. Viewed another way:\nownership transferring APIs are relatively rare compared to pointer-passing APIs,\nso the default is \"no ownership transfer.\"\n\n**See also**: [Argument passing](#rf-conventional), [use of smart pointer arguments](#rr-smartptrparam), and [value return](#rf-value-return).\n\n##### Enforcement\n\n* (Simple) Warn on `delete` of a raw pointer that is not an `owner<T>`. Suggest use of standard-library resource handle or use of `owner<T>`.\n* (Simple) Warn on failure to either `reset` or explicitly `delete` an `owner` pointer on every code path.\n* (Simple) Warn if the return value of `new` or a function call with an `owner` return value is assigned to a raw pointer or non-`owner` reference.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ri-nullptr\"></a>I.12: Declare a pointer that must not be null as `not_null`",
    "content": "### <a name=\"ri-nullptr\"></a>I.12: Declare a pointer that must not be null as `not_null`\n\n##### Reason\n\nTo help avoid dereferencing `nullptr` errors.\nTo improve performance by avoiding redundant checks for `nullptr`.\n\n##### Example\n\n    int length(const char* p);            // it is not clear whether length(nullptr) is valid\n\n    length(nullptr);                      // OK?\n\n    int length(not_null<const char*> p);  // better: we can assume that p cannot be nullptr\n\n    int length(const char* p);            // we must assume that p can be nullptr\n\nBy stating the intent in source, implementers and tools can provide better diagnostics, such as finding some classes of errors through static analysis, and perform optimizations, such as removing branches and null tests.\n\n##### Note\n\n`not_null` is defined in the [guidelines support library](#gsl-guidelines-support-library).\n\n##### Note\n\nThe assumption that the pointer to `char` pointed to a C-style string (a zero-terminated string of characters) was still implicit, and a potential source of confusion and errors. Use `czstring` in preference to `const char*`.\n\n    // we can assume that p cannot be nullptr\n    // we can assume that p points to a zero-terminated array of characters\n    int length(not_null<czstring> p);\n\nNote: `length()` is, of course, `std::strlen()` in disguise.\n\n##### Enforcement\n\n* (Simple) ((Foundation)) If a function checks a pointer parameter against `nullptr` before access, on all control-flow paths, then warn it should be declared `not_null`.\n* (Complex) If a function with pointer return value ensures it is not `nullptr` on all return paths, then warn the return type should be declared `not_null`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ri-array\"></a>I.13: Do not pass an array as a single pointer",
    "content": "### <a name=\"ri-array\"></a>I.13: Do not pass an array as a single pointer\n\n##### Reason\n\n (pointer, size)-style interfaces are error-prone. Also, a plain pointer (to array) must rely on some convention to allow the callee to determine the size.\n\n##### Example\n\nConsider:\n\n    void copy_n(const T* p, T* q, int n); // copy from [p:p+n) to [q:q+n)\n\nWhat if there are fewer than `n` elements in the array pointed to by `q`? Then, we overwrite some probably unrelated memory.\nWhat if there are fewer than `n` elements in the array pointed to by `p`? Then, we read some probably unrelated memory.\nEither is undefined behavior and a potentially very nasty bug.\n\n##### Alternative\n\nConsider using explicit spans:\n\n    void copy(span<const T> r, span<T> r2); // copy r to r2\n\n##### Example, bad\n\nConsider:\n\n    void draw(Shape* p, int n);  // poor interface; poor code\n    Circle arr[10];\n    // ...\n    draw(arr, 10);\n\nPassing `10` as the `n` argument might be a mistake: the most common convention is to assume `[0:n)` but that is nowhere stated. Worse is that the call of `draw()` compiled at all: there was an implicit conversion from array to pointer (array decay) and then another implicit conversion from `Circle` to `Shape`. There is no way that `draw()` can safely iterate through that array: it has no way of knowing the size of the elements.\n\n**Alternative**: Use a support class that ensures that the number of elements is correct and prevents dangerous implicit conversions. For example:\n\n    void draw2(span<Circle>);\n    Circle arr[10];\n    // ...\n    draw2(span<Circle>(arr));  // deduce the number of elements\n    draw2(arr);    // deduce the element type and array size\n\n    void draw3(span<Shape>);\n    draw3(arr);    // error: cannot convert Circle[10] to span<Shape>\n\nThis `draw2()` passes the same amount of information to `draw()`, but makes the fact that it is supposed to be a range of `Circle`s explicit. See ???.\n\n##### Exception\n\nUse `zstring` and `czstring` to represent C-style, zero-terminated strings.\nBut when doing so, use `std::string_view` or `span<char>` from the [GSL](#gsl-guidelines-support-library) to prevent range errors.\n\n##### Enforcement\n\n* (Simple) ((Bounds)) Warn for any expression that would rely on implicit conversion of an array type to a pointer type. Allow exception for zstring/czstring pointer types.\n* (Simple) ((Bounds)) Warn for any arithmetic operation on an expression of pointer type that results in a value of pointer type. Allow exception for zstring/czstring pointer types.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ri-global-init\"></a>I.22: Avoid complex initialization of global objects",
    "content": "### <a name=\"ri-global-init\"></a>I.22: Avoid complex initialization of global objects\n\n##### Reason\n\nComplex initialization can lead to undefined order of execution.\n\n##### Example\n\n    // file1.c\n\n    extern const X x;\n\n    const Y y = f(x);   // read x; write y\n\n    // file2.c\n\n    extern const Y y;\n\n    const X x = g(y);   // read y; write x\n\nSince `x` and `y` are in different translation units the order of calls to `f()` and `g()` is undefined;\none will access an uninitialized `const`.\nThis shows that the order-of-initialization problem for global (namespace scope) objects is not limited to global *variables*.\n\n##### Note\n\nOrder of initialization problems become particularly difficult to handle in concurrent code.\nIt is usually best to avoid global (namespace scope) objects altogether.\n\n##### Enforcement\n\n* Flag initializers of globals that call non-`constexpr` functions\n* Flag initializers of globals that access `extern` objects\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ri-nargs\"></a>I.23: Keep the number of function arguments low",
    "content": "### <a name=\"ri-nargs\"></a>I.23: Keep the number of function arguments low\n\n##### Reason\n\nHaving many arguments opens opportunities for confusion. Passing lots of arguments is often costly compared to alternatives.\n\n##### Discussion\n\nThe two most common reasons why functions have too many parameters are:\n\n1. *Missing an abstraction.*\n   There is an abstraction missing, so that a compound value is being\n   passed as individual elements instead of as a single object that enforces an invariant.\n   This not only expands the parameter list, but it leads to errors because the component values\n   are no longer protected by an enforced invariant.\n\n2. *Violating \"one function, one responsibility.\"*\n   The function is trying to do more than one job and should probably be refactored.\n\n##### Example\n\nThe standard-library `merge()` is at the limit of what we can comfortably handle:\n\n    template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator merge(InputIterator1 first1, InputIterator1 last1,\n                         InputIterator2 first2, InputIterator2 last2,\n                         OutputIterator result, Compare comp);\n\nNote that this is because of problem 1 above -- missing abstraction. Instead of passing a range (abstraction), STL passed iterator pairs (unencapsulated component values).\n\nHere, we have four template arguments and six function arguments.\nTo simplify the most frequent and simplest uses, the comparison argument can be defaulted to `<`:\n\n    template<class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator merge(InputIterator1 first1, InputIterator1 last1,\n                         InputIterator2 first2, InputIterator2 last2,\n                         OutputIterator result);\n\nThis doesn't reduce the total complexity, but it reduces the surface complexity presented to many users.\nTo really reduce the number of arguments, we need to bundle the arguments into higher-level abstractions:\n\n    template<class InputRange1, class InputRange2, class OutputIterator>\n    OutputIterator merge(InputRange1 r1, InputRange2 r2, OutputIterator result);\n\nGrouping arguments into \"bundles\" is a general technique to reduce the number of arguments and to increase the opportunities for checking.\n\nAlternatively, we could use a standard library concept to define the notion of three types that must be usable for merging:\n\n    template<class In1, class In2, class Out>\n      requires mergeable<In1, In2, Out>\n    Out merge(In1 r1, In2 r2, Out result);\n\n##### Example\n\nThe safety Profiles recommend replacing\n\n    void f(int* some_ints, int some_ints_length);  // BAD: C style, unsafe\n\nwith\n\n    void f(gsl::span<int> some_ints);              // GOOD: safe, bounds-checked\n\nHere, using an abstraction has safety and robustness benefits, and naturally also reduces the number of parameters.\n\n##### Note\n\nHow many parameters are too many? Try to use fewer than four (4) parameters.\nThere are functions that are best expressed with four individual parameters, but not many.\n\n**Alternative**: Use better abstraction: Group arguments into meaningful objects and pass the objects (by value or by reference).\n\n**Alternative**: Use default arguments or overloads to allow the most common forms of calls to be done with fewer arguments.\n\n##### Enforcement\n\n* Warn when a function declares two iterators (including pointers) of the same type instead of a range or a view.\n* (Not enforceable) This is a philosophical guideline that is infeasible to check directly.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ri-unrelated\"></a>I.24: Avoid adjacent parameters that can be invoked by the same arguments in either order with different meaning",
    "content": "### <a name=\"ri-unrelated\"></a>I.24: Avoid adjacent parameters that can be invoked by the same arguments in either order with different meaning\n\n##### Reason\n\nAdjacent arguments of the same type are easily swapped by mistake.\n\n##### Example, bad\n\nConsider:\n\n    void copy_n(T* p, T* q, int n);  // copy from [p:p + n) to [q:q + n)\n\nThis is a nasty variant of a K&R C-style interface. It is easy to reverse the \"to\" and \"from\" arguments.\n\nUse `const` for the \"from\" argument:\n\n    void copy_n(const T* p, T* q, int n);  // copy from [p:p + n) to [q:q + n)\n\n##### Exception\n\nIf the order of the parameters is not important, there is no problem:\n\n    int max(int a, int b);\n\n##### Alternative\n\nDon't pass arrays as pointers, pass an object representing a range (e.g., a `span`):\n\n    void copy_n(span<const T> p, span<T> q);  // copy from p to q\n\n##### Alternative\n\nDefine a `struct` as the parameter type and name the fields for those parameters accordingly:\n\n    struct SystemParams {\n        string config_file;\n        string output_path;\n        seconds timeout;\n    };\n    void initialize(SystemParams p);\n\nThis tends to make invocations of this clear to future readers, as the parameters\nare often filled in by name at the call site.\n\n##### Note\n\nOnly the interface's designer can adequately address the source of violations of this guideline.\n\n##### Enforcement strategy\n\n(Simple) Warn if two consecutive parameters share the same type.\n\nWe are still looking for a less-simple enforcement.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ri-abstract\"></a>I.25: Prefer empty abstract classes as interfaces to class hierarchies",
    "content": "### <a name=\"ri-abstract\"></a>I.25: Prefer empty abstract classes as interfaces to class hierarchies\n\n##### Reason\n\nAbstract classes that are empty (have no non-static member data) are more likely to be stable than base classes with state.\n\n##### Example, bad\n\nYou just knew that `Shape` would turn up somewhere :-)\n\n    class Shape {  // bad: interface class loaded with data\n    public:\n        Point center() const { return c; }\n        virtual void draw() const;\n        virtual void rotate(int);\n        // ...\n    private:\n        Point c;\n        vector<Point> outline;\n        Color col;\n    };\n\nThis will force every derived class to compute a center -- even if that's non-trivial and the center is never used. Similarly, not every `Shape` has a `Color`, and many `Shape`s are best represented without an outline defined as a sequence of `Point`s. Using an abstract class is better:\n\n    class Shape {    // better: Shape is a pure interface\n    public:\n        virtual Point center() const = 0;   // pure virtual functions\n        virtual void draw() const = 0;\n        virtual void rotate(int) = 0;\n        // ...\n        // ... no data members ...\n        // ...\n        virtual ~Shape() = default;\n    };\n\n##### Enforcement\n\n(Simple) Warn if a pointer/reference to a class `C` is assigned to a pointer/reference to a base of `C` and the base class contains data members.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ri-abi\"></a>I.26: If you want a cross-compiler ABI, use a C-style subset",
    "content": "### <a name=\"ri-abi\"></a>I.26: If you want a cross-compiler ABI, use a C-style subset\n\n##### Reason\n\nDifferent compilers implement different binary layouts for classes, exception handling, function names, and other implementation details.\n\n##### Exception\n\nCommon ABIs are emerging on some platforms freeing you from the more draconian restrictions.\n\n##### Note\n\nIf you use a single compiler, you can use full C++ in interfaces. That might require recompilation after an upgrade to a new compiler version.\n\n##### Enforcement\n\n(Not enforceable) It is difficult to reliably identify where an interface forms part of an ABI.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ri-pimpl\"></a>I.27: For stable library ABI, consider the Pimpl idiom",
    "content": "### <a name=\"ri-pimpl\"></a>I.27: For stable library ABI, consider the Pimpl idiom\n\n##### Reason\n\nBecause private data members participate in class layout and private member functions participate in overload resolution, changes to those\nimplementation details require recompilation of all users of a class that uses them. A non-polymorphic interface class holding a pointer to\nimplementation (Pimpl) can isolate the users of a class from changes in its implementation at the cost of an indirection.\n\n##### Example\n\ninterface (widget.h)\n\n    class widget {\n        class impl;\n        std::unique_ptr<impl> pimpl;\n    public:\n        void draw(); // public API that will be forwarded to the implementation\n        widget(int); // defined in the implementation file\n        ~widget();   // defined in the implementation file, where impl is a complete type\n        widget(widget&&) noexcept; // defined in the implementation file\n        widget(const widget&) = delete;\n        widget& operator=(widget&&) noexcept; // defined in the implementation file\n        widget& operator=(const widget&) = delete;\n    };\n\n\nimplementation (widget.cpp)\n\n    class widget::impl {\n        int n; // private data\n    public:\n        void draw(const widget& w) { /* ... */ }\n        impl(int n) : n(n) {}\n    };\n    void widget::draw() { pimpl->draw(*this); }\n    widget::widget(int n) : pimpl{std::make_unique<impl>(n)} {}\n    widget::widget(widget&&) noexcept = default;\n    widget::~widget() = default;\n    widget& widget::operator=(widget&&) noexcept = default;\n\n##### Notes\n\nSee [GOTW #100](https://herbsutter.com/gotw/_100/) and [cppreference](https://en.cppreference.com/w/cpp/language/pimpl) for the trade-offs and additional implementation details associated with this idiom.\n\n##### Enforcement\n\n(Not enforceable) It is difficult to reliably identify where an interface forms part of an ABI.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ri-encapsulate\"></a>I.30: Encapsulate rule violations",
    "content": "### <a name=\"ri-encapsulate\"></a>I.30: Encapsulate rule violations\n\n##### Reason\n\nTo keep code simple and safe.\nSometimes, ugly, unsafe, or error-prone techniques are necessary for logical or performance reasons.\nIf so, keep them local, rather than \"infecting\" interfaces so that larger groups of programmers have to be aware of the\nsubtleties.\nImplementation complexity should, if at all possible, not leak through interfaces into user code.\n\n##### Example\n\nConsider a program that, depending on some form of input (e.g., arguments to `main`), should consume input\nfrom a file, from the command line, or from standard input.\nWe might write\n\n    bool owned;\n    owner<istream*> inp;\n    switch (source) {\n    case std_in:        owned = false; inp = &cin;                       break;\n    case command_line:  owned = true;  inp = new istringstream{argv[2]}; break;\n    case file:          owned = true;  inp = new ifstream{argv[2]};      break;\n    }\n    istream& in = *inp;\n\nThis violated the rule [against uninitialized variables](#res-always),\nthe rule against [ignoring ownership](#ri-raw),\nand the rule [against magic constants](#res-magic).\nIn particular, someone has to remember to somewhere write\n\n    if (owned) delete inp;\n\nWe could handle this particular example by using `unique_ptr` with a special deleter that does nothing for `cin`,\nbut that's complicated for novices (who can easily encounter this problem) and the example is an example of a more general\nproblem where a property that we would like to consider static (here, ownership) needs infrequently be addressed\nat run time.\nThe common, most frequent, and safest examples can be handled statically, so we don't want to add cost and complexity to those.\nBut we must also cope with the uncommon, less-safe, and necessarily more expensive cases.\nSuch examples are discussed in [[Str15]](https://www.stroustrup.com/resource-model.pdf).\n\nSo, we write a class\n\n    class Istream { [[gsl::suppress(\"lifetime\")]]\n    public:\n        enum Opt { from_line = 1 };\n        Istream() { }\n        Istream(czstring p) : owned{true}, inp{new ifstream{p}} {}            // read from file\n        Istream(czstring p, Opt) : owned{true}, inp{new istringstream{p}} {}  // read from command line\n        ~Istream() { if (owned) delete inp; }\n        operator istream&() { return *inp; }\n    private:\n        bool owned = false;\n        istream* inp = &cin;\n    };\n\nNow, the dynamic nature of `istream` ownership has been encapsulated.\nPresumably, a bit of checking for potential errors would be added in real code.\n\n##### Enforcement\n\n* Hard, it is hard to decide what rule-breaking code is essential\n* Flag rule suppression that enable rule-violations to cross interfaces\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-functions\"></a>F: Functions",
    "content": "# <a name=\"s-functions\"></a>F: Functions\n\nA function specifies an action or a computation that takes the system from one consistent state to the next. It is the fundamental building block of programs.\n\nIt should be possible to name a function meaningfully, to specify the requirements of its argument, and clearly state the relationship between the arguments and the result. An implementation is not a specification. Try to think about what a function does as well as about how it does it.\nFunctions are the most critical part in most interfaces, so see the interface rules.\n\nFunction rule summary:\n\nFunction definition rules:\n\n* [F.1: \"Package\" meaningful operations as carefully named functions](#rf-package)\n* [F.2: A function should perform a single logical operation](#rf-logical)\n* [F.3: Keep functions short and simple](#rf-single)\n* [F.4: If a function might have to be evaluated at compile time, declare it `constexpr`](#rf-constexpr)\n* [F.5: If a function is very small and time-critical, declare it inline](#rf-inline)\n* [F.6: If your function must not throw, declare it `noexcept`](#rf-noexcept)\n* [F.7: For general use, take `T*` or `T&` arguments rather than smart pointers](#rf-smart)\n* [F.8: Prefer pure functions](#rf-pure)\n* [F.9: Unused parameters should be unnamed](#rf-unused)\n* [F.10: If an operation can be reused, give it a name](#rf-name)\n* [F.11: Use an unnamed lambda if you need a simple function object in one place only](#rf-lambda)\n\nParameter passing expression rules:\n\n* [F.15: Prefer simple and conventional ways of passing information](#rf-conventional)\n* [F.16: For \"in\" parameters, pass cheaply-copied types by value and others by reference to `const`](#rf-in)\n* [F.17: For \"in-out\" parameters, pass by reference to non-`const`](#rf-inout)\n* [F.18: For \"will-move-from\" parameters, pass by `X&&` and `std::move` the parameter](#rf-consume)\n* [F.19: For \"forward\" parameters, pass by `TP&&` and only `std::forward` the parameter](#rf-forward)\n* [F.20: For \"out\" output values, prefer return values to output parameters](#rf-out)\n* [F.21: To return multiple \"out\" values, prefer returning a struct](#rf-out-multi)\n* [F.60: Prefer `T*` over `T&` when \"no argument\" is a valid option](#rf-ptr-ref)\n\nParameter passing semantic rules:\n\n* [F.22: Use `T*` or `owner<T*>` to designate a single object](#rf-ptr)\n* [F.23: Use a `not_null<T>` to indicate that \"null\" is not a valid value](#rf-nullptr)\n* [F.24: Use a `span<T>` or a `span_p<T>` to designate a half-open sequence](#rf-range)\n* [F.25: Use a `zstring` or a `not_null<zstring>` to designate a C-style string](#rf-zstring)\n* [F.26: Use a `unique_ptr<T>` to transfer ownership where a pointer is needed](#rf-unique_ptr)\n* [F.27: Use a `shared_ptr<T>` to share ownership](#rf-shared_ptr)\n\n<a name=\"rf-value-return\"></a>Value return semantic rules:\n\n* [F.42: Return a `T*` to indicate a position (only)](#rf-return-ptr)\n* [F.43: Never (directly or indirectly) return a pointer or a reference to a local object](#rf-dangle)\n* [F.44: Return a `T&` when copy is undesirable and \"returning no object\" isn't needed](#rf-return-ref)\n* [F.45: Don't return a `T&&`](#rf-return-ref-ref)\n* [F.46: `int` is the return type for `main()`](#rf-main)\n* [F.47: Return `T&` from assignment operators](#rf-assignment-op)\n* [F.48: Don't return `std::move(local)`](#rf-return-move-local)\n* [F.49: Don't return `const T`](#rf-return-const)\n\nOther function rules:\n\n* [F.50: Use a lambda when a function won't do (to capture local variables, or to write a local function)](#rf-capture-vs-overload)\n* [F.51: Where there is a choice, prefer default arguments over overloading](#rf-default-args)\n* [F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms](#rf-reference-capture)\n* [F.53: Avoid capturing by reference in lambdas that will be used non-locally, including returned, stored on the heap, or passed to another thread](#rf-value-capture)\n* [F.54: When writing a lambda that captures `this` or any class data member, don't use `[=]` default capture](#rf-this-capture)\n* [F.55: Don't use `va_arg` arguments](#f-varargs)\n* [F.56: Avoid unnecessary condition nesting](#f-nesting)\n\nFunctions have strong similarities to lambdas and function objects.\n\n**See also**: [C.lambdas: Function objects and lambdas](#ss-lambdas)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-fct-def\"></a>F.def: Function definitions",
    "content": "## <a name=\"ss-fct-def\"></a>F.def: Function definitions\n\nA function definition is a function declaration that also specifies the function's implementation, the function body.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-package\"></a>F.1: \"Package\" meaningful operations as carefully named functions",
    "content": "### <a name=\"rf-package\"></a>F.1: \"Package\" meaningful operations as carefully named functions\n\n##### Reason\n\nFactoring out common code makes code more readable, more likely to be reused, and limit errors from complex code.\nIf something is a well-specified action, separate it out from its surrounding code and give it a name.\n\n##### Example, don't\n\n    void read_and_print(istream& is)    // read and print an int\n    {\n        int x;\n        if (is >> x)\n            cout << \"the int is \" << x << '\\n';\n        else\n            cerr << \"no int on input\\n\";\n    }\n\nAlmost everything is wrong with `read_and_print`.\nIt reads, it writes (to a fixed `ostream`), it writes error messages (to a fixed `ostream`), it handles only `int`s.\nThere is nothing to reuse, logically separate operations are intermingled and local variables are in scope after the end of their logical use.\nFor a tiny example, this looks OK, but if the input operation, the output operation, and the error handling had been more complicated the tangled\nmess could become hard to understand.\n\n##### Note\n\nIf you write a non-trivial lambda that potentially can be used in more than one place, give it a name by assigning it to a (usually non-local) variable.\n\n##### Example\n\n    sort(a, b, [](T x, T y) { return x.rank() < y.rank() && x.value() < y.value(); });\n\nNaming that lambda breaks up the expression into its logical parts and provides a strong hint to the meaning of the lambda.\n\n    auto lessT = [](T x, T y) { return x.rank() < y.rank() && x.value() < y.value(); };\n\n    sort(a, b, lessT);\n\nThe shortest code is not always the best for performance or maintainability.\n\n##### Exception\n\nLoop bodies, including lambdas used as loop bodies, rarely need to be named.\nHowever, large loop bodies (e.g., dozens of lines or dozens of pages) can be a problem.\nThe rule [Keep functions short and simple](#rf-single) implies \"Keep loop bodies short.\"\nSimilarly, lambdas used as callback arguments are sometimes non-trivial, yet unlikely to be reusable.\n\n##### Enforcement\n\n* See [Keep functions short and simple](#rf-single)\n* Flag identical and very similar lambdas used in different places.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-logical\"></a>F.2: A function should perform a single logical operation",
    "content": "### <a name=\"rf-logical\"></a>F.2: A function should perform a single logical operation\n\n##### Reason\n\nA function that performs a single operation is simpler to understand, test, and reuse.\n\n##### Example\n\nConsider:\n\n    void read_and_print()    // bad\n    {\n        int x;\n        cin >> x;\n        // check for errors\n        cout << x << \"\\n\";\n    }\n\nThis is a monolith that is tied to a specific input and will never find another (different) use. Instead, break functions up into suitable logical parts and parameterize:\n\n    int read(istream& is)    // better\n    {\n        int x;\n        is >> x;\n        // check for errors\n        return x;\n    }\n\n    void print(ostream& os, int x)\n    {\n        os << x << \"\\n\";\n    }\n\nThese can now be combined where needed:\n\n    void read_and_print()\n    {\n        auto x = read(cin);\n        print(cout, x);\n    }\n\nIf there was a need, we could further templatize `read()` and `print()` on the data type, the I/O mechanism, the response to errors, etc. Example:\n\n    auto read = [](auto& input, auto& value)    // better\n    {\n        input >> value;\n        // check for errors\n    };\n\n    void print(auto& output, const auto& value)\n    {\n        output << value << \"\\n\";\n    }\n\n##### Enforcement\n\n* Consider functions with more than one \"out\" parameter suspicious. Use return values instead, including `tuple` for multiple return values.\n* Consider \"large\" functions that don't fit on one editor screen suspicious. Consider factoring such a function into smaller well-named suboperations.\n* Consider functions with 7 or more parameters suspicious.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-single\"></a>F.3: Keep functions short and simple",
    "content": "### <a name=\"rf-single\"></a>F.3: Keep functions short and simple\n\n##### Reason\n\nLarge functions are hard to read, more likely to contain complex code, and more likely to have variables in larger than minimal scopes.\nFunctions with complex control structures are more likely to be long and more likely to hide logical errors\n\n##### Example\n\nConsider:\n\n    double simple_func(double val, int flag1, int flag2)\n        // simple_func: takes a value and calculates the expected ASIC output,\n        // given the two mode flags.\n    {\n        double intermediate;\n        if (flag1 > 0) {\n            intermediate = func1(val);\n            if (flag2 % 2)\n                 intermediate = sqrt(intermediate);\n        }\n        else if (flag1 == -1) {\n            intermediate = func1(-val);\n            if (flag2 % 2)\n                 intermediate = sqrt(-intermediate);\n            flag1 = -flag1;\n        }\n        if (abs(flag2) > 10) {\n            intermediate = func2(intermediate);\n        }\n        switch (flag2 / 10) {\n        case 1: if (flag1 == -1) return finalize(intermediate, 1.171);\n                break;\n        case 2: return finalize(intermediate, 13.1);\n        default: break;\n        }\n        return finalize(intermediate, 0.);\n    }\n\nThis is too complex.\nHow would you know if all possible alternatives have been correctly handled?\nYes, it breaks other rules also.\n\nWe can refactor:\n\n    double func1_muon(double val, int flag)\n    {\n        // ???\n    }\n\n    double func1_tau(double val, int flag1, int flag2)\n    {\n        // ???\n    }\n\n    double simple_func(double val, int flag1, int flag2)\n        // simple_func: takes a value and calculates the expected ASIC output,\n        // given the two mode flags.\n    {\n        if (flag1 > 0)\n            return func1_muon(val, flag2);\n        if (flag1 == -1)\n            // handled by func1_tau: flag1 = -flag1;\n            return func1_tau(-val, flag1, flag2);\n        return 0.;\n    }\n\n##### Note\n\n\"It doesn't fit on a screen\" is often a good practical definition of \"far too large.\"\nOne-to-five-line functions should be considered normal.\n\n##### Note\n\nBreak large functions up into smaller cohesive and named functions.\nSmall simple functions are easily inlined where the cost of a function call is significant.\n\n##### Enforcement\n\n* Flag functions that do not \"fit on a screen.\"\n  How big is a screen? Try 60 lines by 140 characters; that's roughly the maximum that's comfortable for a book page.\n* Flag functions that are too complex. How complex is too complex?\n  You could use cyclomatic complexity. Try \"more than 10 logical paths through.\" Count a simple switch as one path.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-constexpr\"></a>F.4: If a function might have to be evaluated at compile time, declare it `constexpr`",
    "content": "### <a name=\"rf-constexpr\"></a>F.4: If a function might have to be evaluated at compile time, declare it `constexpr`\n\n##### Reason\n\n `constexpr` is needed to tell the compiler to allow compile-time evaluation.\n\n##### Example\n\nThe (in)famous factorial:\n\n    constexpr int fac(int n)\n    {\n        constexpr int max_exp = 17;      // constexpr enables max_exp to be used in Expects\n        Expects(0 <= n && n < max_exp);  // prevent silliness and overflow\n        int x = 1;\n        for (int i = 2; i <= n; ++i) x *= i;\n        return x;\n    }\n\nThis is C++14.\nFor C++11, use a recursive formulation of `fac()`.\n\n##### Note\n\n`constexpr` does not guarantee compile-time evaluation;\nit just guarantees that the function can be evaluated at compile time for constant expression arguments if the programmer requires it or the compiler decides to do so to optimize.\n\n    constexpr int min(int x, int y) { return x < y ? x : y; }\n\n    void test(int v)\n    {\n        int m1 = min(-1, 2);            // probably compile-time evaluation\n        constexpr int m2 = min(-1, 2);  // compile-time evaluation\n        int m3 = min(-1, v);            // run-time evaluation\n        constexpr int m4 = min(-1, v);  // error: cannot evaluate at compile time\n    }\n\n##### Note\n\nDon't try to make all functions `constexpr`.\nMost computation is best done at run time.\n\n##### Note\n\nAny API that might eventually depend on high-level run-time configuration or\nbusiness logic should not be made `constexpr`. Such customization can not be\nevaluated by the compiler, and any `constexpr` functions that depended upon\nthat API would have to be refactored or drop `constexpr`.\n\n##### Enforcement\n\nImpossible and unnecessary.\nThe compiler gives an error if a non-`constexpr` function is called where a constant is required.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-inline\"></a>F.5: If a function is very small and time-critical, declare it `inline`",
    "content": "### <a name=\"rf-inline\"></a>F.5: If a function is very small and time-critical, declare it `inline`\n\n##### Reason\n\nSome optimizers are good at inlining without hints from the programmer, but don't rely on it.\nMeasure! Over the last 40 years or so, we have been promised compilers that can inline better than humans without hints from humans.\nWe are still waiting.\nSpecifying inline (explicitly, or implicitly when writing member functions inside a class definition) encourages the compiler to do a better job.\n\n##### Example\n\n    inline string cat(const string& s, const string& s2) { return s + s2; }\n\n##### Exception\n\nDo not put an `inline` function in what is meant to be a stable interface unless you are certain that it will not change.\nAn inline function is part of the ABI.\n\n##### Note\n\n`constexpr` implies `inline`.\n\n##### Note\n\nMember functions defined in-class are `inline` by default.\n\n##### Exception\n\nFunction templates (including member functions of class templates `A<T>::function()` and member function templates `A::function<T>()`) are normally defined in headers and therefore inline.\n\n##### Note\n\nConsider making functions out of line if they are more than three statements and can be declared out of line (such as class member functions).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-noexcept\"></a>F.6: If your function must not throw, declare it `noexcept`",
    "content": "### <a name=\"rf-noexcept\"></a>F.6: If your function must not throw, declare it `noexcept`\n\n##### Reason\n\nIf an exception is not supposed to be thrown, the program cannot be assumed to cope with the error and should be terminated as soon as possible. Declaring a function `noexcept` helps optimizers by reducing the number of alternative execution paths. It also speeds up the exit after failure.\n\n##### Example\n\nPut `noexcept` on every function written completely in C or in any other language without exceptions.\nThe C++ Standard Library does that implicitly for all functions in the C Standard Library.\n\n##### Note\n\n`constexpr` functions can throw when evaluated at run time, so you might need conditional `noexcept` for some of those.\n\n##### Example\n\nYou can use `noexcept` even on functions that can throw:\n\n    vector<string> collect(istream& is) noexcept\n    {\n        vector<string> res;\n        for (string s; is >> s;)\n            res.push_back(s);\n        return res;\n    }\n\nIf `collect()` runs out of memory, the program crashes.\nUnless the program is crafted to survive memory exhaustion, that might be just the right thing to do;\n`terminate()` might generate suitable error log information (but after memory runs out it is hard to do anything clever).\n\n##### Note\n\nYou must be aware of the execution environment that your code is running when\ndeciding whether to tag a function `noexcept`, especially because of the issue\nof throwing and allocation.  Code that is intended to be perfectly general (like\nthe standard library and other utility code of that sort) needs to support\nenvironments where a `bad_alloc` exception could be handled meaningfully.\nHowever, most programs and execution environments cannot meaningfully\nhandle a failure to allocate, and aborting the program is the cleanest and\nsimplest response to an allocation failure in those cases.  If you know that\nyour application code cannot respond to an allocation failure, it could be\nappropriate to add `noexcept` even on functions that allocate.\n\nPut another way: In most programs, most functions can throw (e.g., because they\nuse `new`, call functions that do, or use library functions that report failure\nby throwing), so don't just sprinkle `noexcept` all over the place without\nconsidering whether the possible exceptions can be handled.\n\n`noexcept` is most useful (and most clearly correct) for frequently used,\nlow-level functions.\n\n##### Note\n\nDestructors, `swap` functions, move operations, and default constructors should never throw.\nSee also [C.44](#rc-default00).\n\n##### Note\n\nCare must be taken on base virtual functions and functions part of a public interface because declaring a function `noexcept` is establishing a guarantee that all current and future implementations must abide by.  For virtual function, all overriders must also be `noexcept` and removing `noexcept` from a function could break calling functions. \n\n##### Enforcement\n\n* (hard) Flag low-level functions that are not `noexcept`, yet cannot throw.\n* Flag throwing `swap`, `move`, destructors, and default constructors.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-smart\"></a>F.7: For general use, take `T*` or `T&` arguments rather than smart pointers",
    "content": "### <a name=\"rf-smart\"></a>F.7: For general use, take `T*` or `T&` arguments rather than smart pointers\n\n##### Reason\n\nPassing a smart pointer transfers or shares ownership and should only be used when ownership semantics are intended.\nA function that does not manipulate lifetime should take raw pointers or references instead.\n\nPassing by smart pointer restricts the use of a function to callers that use smart pointers.\nA function that needs a `widget` should be able to accept any `widget` object, not just ones whose lifetimes are managed by a particular kind of smart pointer.\n\nPassing a shared smart pointer (e.g., `std::shared_ptr`) implies a run-time cost.\n\n##### Example\n\n    // accepts any int*\n    void f(int*);\n\n    // can only accept ints for which you want to transfer ownership\n    void g(unique_ptr<int>);\n\n    // can only accept ints for which you are willing to share ownership\n    void g(shared_ptr<int>);\n\n    // doesn't change ownership, but requires a particular ownership of the caller\n    void h(const unique_ptr<int>&);\n\n    // accepts any int\n    void h(int&);\n\n##### Example, bad\n\n    // callee\n    void f(shared_ptr<widget>& w)\n    {\n        // ...\n        use(*w); // only use of w -- the lifetime is not used at all\n        // ...\n    };\n\n    // caller\n    shared_ptr<widget> my_widget = /* ... */;\n    f(my_widget);\n\n    widget stack_widget;\n    f(stack_widget); // error\n\n##### Example, good\n\n    // callee\n    void f(widget& w)\n    {\n        // ...\n        use(w);\n        // ...\n    };\n\n    // caller\n    shared_ptr<widget> my_widget = /* ... */;\n    f(*my_widget);\n\n    widget stack_widget;\n    f(stack_widget); // ok -- now this works\n\n##### Note\n\nWe can catch many common cases of dangling pointers statically (see [lifetime safety profile](#ss-lifetime)). Function arguments naturally live for the lifetime of the function call, and so have fewer lifetime problems.\n\n##### Enforcement\n\n* (Simple) Warn if a function takes a parameter of a smart pointer type (that overloads `operator->` or `operator*`) that is copyable but the function only calls any of: `operator*`, `operator->` or `get()`.\n  Suggest using a `T*` or `T&` instead.\n* Flag a parameter of a smart pointer type (a type that overloads `operator->` or `operator*`) that is copyable/movable but never copied/moved from in the function body, and that is never modified, and that is not passed along to another function that could do so. That means the ownership semantics are not used.\n  Suggest using a `T*` or `T&` instead.\n\n**See also**:\n\n* [Prefer `T*` over `T&` when \"no argument\" is a valid option](#rf-ptr-ref)\n* [Smart pointer rule summary](#rr-summary-smartptrs)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-pure\"></a>F.8: Prefer pure functions",
    "content": "### <a name=\"rf-pure\"></a>F.8: Prefer pure functions\n\n##### Reason\n\nPure functions are easier to reason about, sometimes easier to optimize (and even parallelize), and sometimes can be memoized.\n\n##### Example\n\n    template<class T>\n    auto square(T t) { return t * t; }\n\n##### Enforcement\n\nNot possible.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-unused\"></a>F.9: Unused parameters should be unnamed",
    "content": "### <a name=\"rf-unused\"></a>F.9: Unused parameters should be unnamed\n\n##### Reason\n\nReadability.\nSuppression of unused parameter warnings.\n\n##### Example\n\n    widget* find(const set<widget>& s, const widget& w, Hint);   // once upon a time, a hint was used\n\n##### Note\n\nAllowing parameters to be unnamed was introduced in the early 1980s to address this problem.\n\nIf parameters are conditionally unused, declare them with the `[[maybe_unused]]` attribute.\nFor example:\n\n    template <typename Value>\n    Value* find(const set<Value>& s, const Value& v, [[maybe_unused]] Hint h)\n    {\n        if constexpr (sizeof(Value) > CacheSize)\n        {\n            // a hint is used only if Value is of a certain size\n        }\n    }\n\n##### Enforcement\n\nFlag named unused parameters.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-name\"></a>F.10: If an operation can be reused, give it a name",
    "content": "### <a name=\"rf-name\"></a>F.10: If an operation can be reused, give it a name\n\n##### Reason\n\nDocumentation, readability, opportunity for reuse.\n\n##### Example\n\n    struct Rec {\n        string name;\n        string addr;\n        int id;         // unique identifier\n    };\n\n    bool same(const Rec& a, const Rec& b)\n    {\n        return a.id == b.id;\n    }\n\n    vector<Rec*> find_id(const string& name);    // find all records for \"name\"\n\n    auto x = find_if(vr.begin(), vr.end(),\n        [&](Rec& r) {\n            if (r.name.size() != n.size()) return false; // name to compare to is in n\n            for (int i = 0; i < r.name.size(); ++i)\n                if (tolower(r.name[i]) != tolower(n[i])) return false;\n            return true;\n        }\n    );\n\nThere is a useful function lurking here (case insensitive string comparison), as there often is when lambda arguments get large.\n\n    bool compare_insensitive(const string& a, const string& b)\n    {\n        if (a.size() != b.size()) return false;\n        for (int i = 0; i < a.size(); ++i) if (tolower(a[i]) != tolower(b[i])) return false;\n        return true;\n    }\n\n    auto x = find_if(vr.begin(), vr.end(),\n        [&](Rec& r) { return compare_insensitive(r.name, n); }\n    );\n\nOr maybe (if you prefer to avoid the implicit name binding to n):\n\n    auto cmp_to_n = [&n](const string& a) { return compare_insensitive(a, n); };\n\n    auto x = find_if(vr.begin(), vr.end(),\n        [](const Rec& r) { return cmp_to_n(r.name); }\n    );\n\n##### Note\n\nwhether functions, lambdas, or operators.\n\n##### Exception\n\n* Lambdas logically used only locally, such as an argument to `for_each` and similar control flow algorithms.\n* Lambdas as [initializers](#???)\n\n##### Enforcement\n\n* (hard) flag similar lambdas\n* ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-lambda\"></a>F.11: Use an unnamed lambda if you need a simple function object in one place only",
    "content": "### <a name=\"rf-lambda\"></a>F.11: Use an unnamed lambda if you need a simple function object in one place only\n\n##### Reason\n\nThat makes the code concise and gives better locality than alternatives.\n\n##### Example\n\n    auto earlyUsersEnd = std::remove_if(users.begin(), users.end(),\n                                        [](const User &a) { return a.id > 100; });\n\n\n##### Exception\n\nNaming a lambda can be useful for clarity even if it is used only once.\n\n##### Enforcement\n\n* Look for identical and near identical lambdas (to be replaced with named functions or named lambdas).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-call\"></a>F.call: Parameter passing",
    "content": "## <a name=\"ss-call\"></a>F.call: Parameter passing\n\nThere are a variety of ways to pass parameters to a function and to return values.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-conventional\"></a>F.15: Prefer simple and conventional ways of passing information",
    "content": "### <a name=\"rf-conventional\"></a>F.15: Prefer simple and conventional ways of passing information\n\n##### Reason\n\nUsing \"unusual and clever\" techniques causes surprises, slows understanding by other programmers, and encourages bugs.\nIf you really feel the need for an optimization beyond the common techniques, measure to ensure that it really is an improvement, and document/comment because the improvement might not be portable.\n\nThe following tables summarize the advice in the following Guidelines, F.16-21.\n\nNormal parameter passing:\n\n![Normal parameter passing table](./param-passing-normal.png \"Normal parameter passing\")\n\nAdvanced parameter passing:\n\n![Advanced parameter passing table](./param-passing-advanced.png \"Advanced parameter passing\")\n\nUse the advanced techniques only after demonstrating need, and document that need in a comment.\n\nFor passing sequences of characters see [String](#ss-string).\n\n##### Exception\n\nTo express shared ownership using `shared_ptr` types, rather than following guidelines F.16-21,\nfollow [R.34](#rr-sharedptrparam-owner), [R.35](#rr-sharedptrparam), and [R.36](#rr-sharedptrparam-const).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-in\"></a>F.16: For \"in\" parameters, pass cheaply-copied types by value and others by reference to `const`",
    "content": "### <a name=\"rf-in\"></a>F.16: For \"in\" parameters, pass cheaply-copied types by value and others by reference to `const`\n\n##### Reason\n\nBoth let the caller know that a function will not modify the argument, and both allow initialization by rvalues.\n\nWhat is \"cheap to copy\" depends on the machine architecture, but two or three words (doubles, pointers, references) are usually best passed by value.\nWhen copying is cheap, nothing beats the simplicity and safety of copying, and for small objects (up to two or three words) it is also faster than passing by reference because it does not require an extra indirection to access from the function.\n\n##### Example\n\n    void f1(const string& s);  // OK: pass by reference to const; always cheap\n\n    void f2(string s);         // bad: potentially expensive\n\n    void f3(int x);            // OK: Unbeatable\n\n    void f4(const int& x);     // bad: overhead on access in f4()\n\nFor advanced uses (only), where you really need to optimize for rvalues passed to \"input-only\" parameters:\n\n* If the function is going to unconditionally move from the argument, take it by `&&`. See [F.18](#rf-consume).\n* If the function is going to keep a locally modifiable copy of the argument only for its own local use, taking it by value is fine.\n* If the function is going to keep a copy of the argument to pass to another destination (to another function, or store in a non-local location), in addition to passing by `const&` (for lvalues),\n  add an overload that passes the parameter by `&&` (for rvalues) and in the body `std::move`s it to its destination. Essentially this overloads a \"will-move-from\"; see [F.18](#rf-consume).\n* In special cases, such as multiple \"input + copy\" parameters, consider using perfect forwarding. See [F.19](#rf-forward).\n\n##### Example\n\n    int multiply(int, int); // just input ints, pass by value\n\n    // suffix is input-only but not as cheap as an int, pass by const&\n    string& concatenate(string&, const string& suffix);\n\n    void sink(unique_ptr<widget>);  // input only, and moves ownership of the widget\n\nAvoid \"esoteric techniques\" such as passing arguments as `T&&` \"for efficiency\".\nMost rumors about performance advantages from passing by `&&` are false or brittle (but see [F.18](#rf-consume) and [F.19](#rf-forward)).\n\n##### Notes\n\nA reference can be assumed to refer to a valid object (language rule).\nThere is no (legitimate) \"null reference.\"\nIf you need the notion of an optional value, use a pointer, `std::optional`, or a special value used to denote \"no value.\"\n\n##### Enforcement\n\n* (Simple) ((Foundation)) Warn when a parameter being passed by value has a size greater than `2 * sizeof(void*)`.\n  Suggest using a reference to `const` instead.\n* (Simple) ((Foundation)) Warn when a parameter passed by reference to `const` has a size less or equal than `2 * sizeof(void*)`. Suggest passing by value instead.\n* (Simple) ((Foundation)) Warn when a parameter passed by reference to `const` is `move`d.\n\n##### Exception\n\nTo express shared ownership using `shared_ptr` types, follow [R.34](#rr-sharedptrparam-owner) or [R.36](#rr-sharedptrparam-const),\ndepending on whether or not the function unconditionally takes a reference to the argument.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-inout\"></a>F.17: For \"in-out\" parameters, pass by reference to non-`const`",
    "content": "### <a name=\"rf-inout\"></a>F.17: For \"in-out\" parameters, pass by reference to non-`const`\n\n##### Reason\n\nThis makes it clear to callers that the object is assumed to be modified.\n\n##### Example\n\n    void update(Record& r);  // assume that update writes to r\n\n##### Note\n\nSome user-defined and standard library types, such as `span<T>` or the iterators\nare [cheap to copy](#rf-in) and may be passed by value, while doing so has\nmutable (in-out) reference semantics:\n\n    void increment_all(span<int> a)\n    {\n      for (auto&& e : a)\n        ++e;\n    }\n\n##### Note\n\nA `T&` argument can pass information into a function as well as out of it.\nThus `T&` could be an in-out-parameter. That can in itself be a problem and a source of errors:\n\n    void f(string& s)\n    {\n        s = \"New York\";  // non-obvious error\n    }\n\n    void g()\n    {\n        string buffer = \".................................\";\n        f(buffer);\n        // ...\n    }\n\nHere, the writer of `g()` is supplying a buffer for `f()` to fill, but `f()` simply replaces it (at a somewhat higher cost than a simple copy of the characters).\nA bad logic error can happen if the writer of `g()` incorrectly assumes the size of the `buffer`.\n\n##### Enforcement\n\n* (Moderate) ((Foundation)) Warn about functions regarding reference to non-`const` parameters that do *not* write to them.\n* (Simple) ((Foundation)) Warn when a non-`const` parameter being passed by reference is `move`d.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-consume\"></a>F.18: For \"will-move-from\" parameters, pass by `X&&` and `std::move` the parameter",
    "content": "### <a name=\"rf-consume\"></a>F.18: For \"will-move-from\" parameters, pass by `X&&` and `std::move` the parameter\n\n##### Reason\n\nIt's efficient and eliminates bugs at the call site: `X&&` binds to rvalues, which requires an explicit `std::move` at the call site if passing an lvalue.\n\n##### Example\n\n    void sink(vector<int>&& v)  // sink takes ownership of whatever the argument owned\n    {\n        // usually there might be const accesses of v here\n        store_somewhere(std::move(v));\n        // usually no more use of v here; it is moved-from\n    }\n\nNote that the `std::move(v)` makes it possible for `store_somewhere()` to leave `v` in a moved-from state.\n[That could be dangerous](#rc-move-semantic).\n\n\n##### Exception\n\nUnique owner types that are move-only and cheap-to-move, such as `unique_ptr`, can also be passed by value which is simpler to write and achieves the same effect. Passing by value does generate one extra (cheap) move operation, but prefer simplicity and clarity first.\n\nFor example:\n\n    template<class T>\n    void sink(std::unique_ptr<T> p)\n    {\n        // use p ... possibly std::move(p) onward somewhere else\n    }   // p gets destroyed\n\n##### Exception\n\nIf the \"will-move-from\" parameter is a `shared_ptr` follow [R.34](#rr-sharedptrparam-owner) and pass the `shared_ptr` by value.\n\n##### Enforcement\n\n* Flag all `X&&` parameters (where `X` is not a template type parameter name) where the function body uses them without `std::move`.\n* Flag access to moved-from objects.\n* Don't conditionally move from objects\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-forward\"></a>F.19: For \"forward\" parameters, pass by `TP&&` and only `std::forward` the parameter",
    "content": "### <a name=\"rf-forward\"></a>F.19: For \"forward\" parameters, pass by `TP&&` and only `std::forward` the parameter\n\n##### Reason\n\nIf the object is to be passed onward to other code and not directly used by this function, we want to make this function agnostic to the argument `const`-ness and rvalue-ness.\n\nIn that case, and only that case, make the parameter `TP&&` where `TP` is a template type parameter -- it both *ignores* and *preserves* `const`-ness and rvalue-ness. Therefore any code that uses a `TP&&` is implicitly declaring that it itself doesn't care about the variable's `const`-ness and rvalue-ness (because it is ignored), but that intends to pass the value onward to other code that does care about `const`-ness and rvalue-ness (because it is preserved). When used as a parameter `TP&&` is safe because any temporary objects passed from the caller will live for the duration of the function call. A parameter of type `TP&&` should essentially always be passed onward via `std::forward` in the body of the function.\n\n##### Example\n\nUsually you forward the entire parameter (or parameter pack, using `...`) exactly once on every static control flow path:\n\n    template<class F, class... Args>\n    inline decltype(auto) invoke(F&& f, Args&&... args)\n    {\n        return forward<F>(f)(forward<Args>(args)...);\n    }\n\n##### Example\n\nSometimes you may forward a composite parameter piecewise, each subobject once on every static control flow path:\n\n    template<class PairLike>\n    inline auto test(PairLike&& pairlike)\n    {\n        // ...\n        f1(some, args, and, forward<PairLike>(pairlike).first);           // forward .first\n        f2(and, forward<PairLike>(pairlike).second, in, another, call);   // forward .second\n    }\n\n##### Enforcement\n\n* Flag a function that takes a `TP&&` parameter (where `TP` is a template type parameter name) and does anything with it other than `std::forward`ing it exactly once on every static path, or `std::forward`ing it more than once but qualified with a different data member exactly once on every static path.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-out\"></a>F.20: For \"out\" output values, prefer return values to output parameters",
    "content": "### <a name=\"rf-out\"></a>F.20: For \"out\" output values, prefer return values to output parameters\n\n##### Reason\n\nA return value is self-documenting, whereas an `&` could be either in-out or out-only and is liable to be misused.\n\nThis includes large objects like standard containers that use implicit move operations for performance and to avoid explicit memory management.\n\nIf you have multiple values to return, [use a tuple](#rf-out-multi) or similar multi-member type.\n\n##### Example\n\n    // OK: return pointers to elements with the value x\n    vector<const int*> find_all(const vector<int>&, int x);\n\n    // Bad: place pointers to elements with value x in-out\n    void find_all(const vector<int>&, vector<const int*>& out, int x);\n\n##### Note\n\nA `struct` of many (individually cheap-to-move) elements might be in aggregate expensive to move.\n\n##### Exceptions\n\n* For non-concrete types, such as types in an inheritance hierarchy, return the object by `unique_ptr` or `shared_ptr`.\n* If a type is expensive to move (e.g., `array<BigTrivial>`), consider allocating it on the free store and return a handle (e.g., `unique_ptr`), or passing it in a reference to non-`const` target object to fill (to be used as an out-parameter).\n* To reuse an object that carries capacity (e.g., `std::string`, `std::vector`) across multiple calls to the function in an inner loop: [treat it as an in/out parameter and pass by reference](#rf-out-multi).\n\n##### Example\n\nAssuming that `Matrix` has move operations (possibly by keeping its elements in a `std::vector`):\n\n    Matrix operator+(const Matrix& a, const Matrix& b)\n    {\n        Matrix res;\n        // ... fill res with the sum ...\n        return res;\n    }\n\n    Matrix x = m1 + m2;  // move constructor\n\n    y = m3 + m3;         // move assignment\n\n\n##### Note\n\nThe return value optimization doesn't handle the assignment case, but the move assignment does.\n\n##### Example\n\n    struct Package {      // exceptional case: expensive-to-move object\n        char header[16];\n        char load[2024 - 16];\n    };\n\n    Package fill();       // Bad: large return value\n    void fill(Package&);  // OK\n\n    int val();            // OK\n    void val(int&);       // Bad: Is val reading its argument\n\n##### Enforcement\n\n* Flag reference to non-`const` parameters that are not read before being written to and are a type that could be cheaply returned; they should be \"out\" return values.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-out-multi\"></a>F.21: To return multiple \"out\" values, prefer returning a struct",
    "content": "### <a name=\"rf-out-multi\"></a>F.21: To return multiple \"out\" values, prefer returning a struct\n\n##### Reason\n\nA return value is self-documenting as an \"output-only\" value.\nNote that C++ does have multiple return values, by convention of using tuple-like types (`struct`, `array`, `tuple`, etc.),\npossibly with the extra convenience of structured bindings (C++17) at the call site.\nPrefer using a named `struct` if possible.\nOtherwise, a `tuple` is useful in variadic templates.\n\n##### Example\n\n    // BAD: output-only parameter documented in a comment\n    int f(const string& input, /*output only*/ string& output_data)\n    {\n        // ...\n        output_data = something();\n        return status;\n    }\n\n    // GOOD: self-documenting\n    struct f_result { int status; string data; };\n\n    f_result f(const string& input)\n    {\n        // ...\n        return {status, something()};\n    }\n\nC++98's standard library used this style in places, by returning `pair` in some functions.\nFor example, given a `set<string> my_set`, consider:\n\n    // C++98\n    pair<set::iterator, bool> result = my_set.insert(\"Hello\");\n    if (result.second)\n        do_something_with(result.first);    // workaround\n\nWith C++17 we are able to use \"structured bindings\" to give each member a name:\n\n    if (auto [ iter, success ] = my_set.insert(\"Hello\"); success)\n        do_something_with(iter);\n\nA `struct` with meaningful names is more common in modern C++.\nSee for example `ranges::min_max_result`, `from_chars_result`, and others.\n\n##### Exception\n\nSometimes, we need to pass an object to a function to manipulate its state.\nIn such cases, passing the object by reference [`T&`](#rf-inout) is usually the right technique.\nExplicitly passing an in-out parameter back out again as a return value is often not necessary.\nFor example:\n\n    istream& operator>>(istream& in, string& s);    // much like std::operator>>()\n\n    for (string s; in >> s; ) {\n        // do something with line\n    }\n\nHere, both `s` and `in` are used as in-out parameters.\nWe pass `in` by (non-`const`) reference to be able to manipulate its state.\nWe pass `s` to avoid repeated allocations.\nBy reusing `s` (passed by reference), we allocate new memory only when we need to expand `s`'s capacity.\nThis technique is sometimes called the \"caller-allocated out\" pattern and is particularly useful for types,\nsuch as `string` and `vector`, that need to do free store allocations.\n\nTo compare, if we passed out all values as return values, we would write something like this:\n\n    struct get_string_result { istream& in; string s; };\n\n    get_string_result get_string(istream& in)  // not recommended\n    {\n        string s;\n        in >> s;\n        return { in, move(s) };\n    }\n\n    for (auto [in, s] = get_string(cin); in; s = get_string(in).s) {\n        // do something with string\n    }\n\nWe consider that significantly less elegant with significantly less performance.\n\nFor a truly strict reading of this rule (F.21), the exception isn't really an exception because it relies on in-out parameters,\nrather than the plain out parameters mentioned in the rule.\nHowever, we prefer to be explicit, rather than subtle.\n\n##### Note\n\nIn most cases, it is useful to return a specific, user-defined type.\nFor example:\n\n    struct Distance {\n        int value;\n        int unit = 1;   // 1 means meters\n    };\n\n    Distance d1 = measure(obj1);        // access d1.value and d1.unit\n    auto d2 = measure(obj2);            // access d2.value and d2.unit\n    auto [value, unit] = measure(obj3); // access value and unit; somewhat redundant\n                                        // to people who know measure()\n    auto [x, y] = measure(obj4);        // don't; it's likely to be confusing\n\nThe overly generic `pair` and `tuple` should be used only when the value returned represents independent entities rather than an abstraction.\n\nAnother option is to use `optional<T>` or `expected<T, error_code>`, rather than `pair` or `tuple`.\nWhen used appropriately these types convey more information about what the members mean than `pair<T, bool>` or `pair<T, error_code>` do.\n\n##### Note\n\nWhen the object to be returned is initialized from local variables that are expensive to copy,\nexplicit `move` may be helpful to avoid copying:\n\n    pair<LargeObject, LargeObject> f(const string& input)\n    {\n        LargeObject large1 = g(input);\n        LargeObject large2 = h(input);\n        // ...\n        return { move(large1), move(large2) }; // no copies\n    }\n\nAlternatively,\n\n    pair<LargeObject, LargeObject> f(const string& input)\n    {\n        // ...\n        return { g(input), h(input) }; // no copies, no moves\n    }\n\nNote this is different from the `return move(...)` anti-pattern from [ES.56](#res-move).\n\n##### Enforcement\n\n* Output parameters should be replaced by return values.\n  An output parameter is one that the function writes to, invokes a non-`const` member function, or passes on as a non-`const`.\n* `pair` or `tuple` return types should be replaced by `struct`, if possible.\n  In variadic templates, `tuple` is often unavoidable.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-ptr-ref\"></a>F.60: Prefer `T*` over `T&` when \"no argument\" is a valid option",
    "content": "### <a name=\"rf-ptr-ref\"></a>F.60: Prefer `T*` over `T&` when \"no argument\" is a valid option\n\n##### Reason\n\nA pointer (`T*`) can be a `nullptr` and a reference (`T&`) cannot, there is no valid \"null reference\".\nSometimes having `nullptr` as an alternative to indicated \"no object\" is useful, but if it is not, a reference is notationally simpler and might yield better code.\n\n##### Example\n\n    string zstring_to_string(zstring p) // zstring is a char*; that is a C-style string\n    {\n        if (!p) return string{};    // p might be nullptr; remember to check\n        return string{p};\n    }\n\n    void print(const vector<int>& r)\n    {\n        // r refers to a vector<int>; no check needed\n    }\n\n##### Note\n\nIt is possible, but not valid C++ to construct a reference that is essentially a `nullptr` (e.g., `T* p = nullptr; T& r = *p;`).\nThat error is very uncommon.\n\n##### Note\n\nIf you prefer the pointer notation (`->` and/or `*` vs. `.`), `not_null<T*>` provides the same guarantee as `T&`.\n\n##### Enforcement\n\n* Flag ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-ptr\"></a>F.22: Use `T*` or `owner<T*>` to designate a single object",
    "content": "### <a name=\"rf-ptr\"></a>F.22: Use `T*` or `owner<T*>` to designate a single object\n\n##### Reason\n\nReadability: it makes the meaning of a plain pointer clear.\nEnables significant tool support.\n\n##### Note\n\nIn traditional C and C++ code, plain `T*` is used for many weakly-related purposes, such as:\n\n* Identify a (single) object (not to be deleted by this function)\n* Point to an object allocated on the free store (and delete it later)\n* Hold the `nullptr`\n* Identify a C-style string (zero-terminated array of characters)\n* Identify an array with a length specified separately\n* Identify a location in an array\n\nThis makes it hard to understand what the code does and is supposed to do.\nIt complicates checking and tool support.\n\n##### Example\n\n    void use(int* p, int n, char* s, int* q)\n    {\n        p[n - 1] = 666; // Bad: we don't know if p points to n elements;\n                        // assume it does not or use span<int>\n        cout << s;      // Bad: we don't know if that s points to a zero-terminated array of char;\n                        // assume it does not or use zstring\n        delete q;       // Bad: we don't know if *q is allocated on the free store;\n                        // assume it does not or use owner\n    }\n\nbetter\n\n    void use2(span<int> p, zstring s, owner<int*> q)\n    {\n        p[p.size() - 1] = 666; // OK, a range error can be caught\n        cout << s; // OK\n        delete q;  // OK\n    }\n\n##### Note\n\n`owner<T*>` represents ownership, `zstring` represents a C-style string.\n\n**Also**: Assume that a `T*` obtained from a smart pointer to `T` (e.g., `unique_ptr<T>`) points to a single element.\n\n**See also**: [Support library](#gsl-guidelines-support-library)\n\n**See also**: [Do not pass an array as a single pointer](#ri-array)\n\n##### Enforcement\n\n* (Simple) ((Bounds)) Warn for any arithmetic operation on an expression of pointer type that results in a value of pointer type.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-nullptr\"></a>F.23: Use a `not_null<T>` to indicate that \"null\" is not a valid value",
    "content": "### <a name=\"rf-nullptr\"></a>F.23: Use a `not_null<T>` to indicate that \"null\" is not a valid value\n\n##### Reason\n\nClarity. A function with a `not_null<T>` parameter makes it clear that the caller of the function is responsible for any `nullptr` checks that might be necessary.\nSimilarly, a function with a return value of `not_null<T>` makes it clear that the caller of the function does not need to check for `nullptr`.\n\n##### Example\n\n`not_null<T*>` makes it obvious to a reader (human or machine) that a test for `nullptr` is not necessary before dereference.\nAdditionally, when debugging, `owner<T*>` and `not_null<T>` can be instrumented to check for correctness.\n\nConsider:\n\n    int length(Record* p);\n\nWhen I call `length(p)` should I check if `p` is `nullptr` first? Should the implementation of `length()` check if `p` is `nullptr`?\n\n    // it is the caller's job to make sure p != nullptr\n    int length(not_null<Record*> p);\n\n    // the implementor of length() must assume that p == nullptr is possible\n    int length(Record* p);\n\n##### Note\n\nA `not_null<T*>` is assumed not to be the `nullptr`; a `T*` might be the `nullptr`; both can be represented in memory as a `T*` (so no run-time overhead is implied).\n\n##### Note\n\n`not_null` is not just for built-in pointers. It works for `unique_ptr`, `shared_ptr`, and other pointer-like types.\n\n##### Enforcement\n\n* (Simple) Warn if a raw pointer is dereferenced without being tested against `nullptr` (or equivalent) within a function, suggest it is declared `not_null` instead.\n* (Simple) Error if a raw pointer is sometimes dereferenced after first being tested against `nullptr` (or equivalent) within the function and sometimes is not.\n* (Simple) Warn if a `not_null` pointer is tested against `nullptr` within a function.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-range\"></a>F.24: Use a `span<T>` or a `span_p<T>` to designate a half-open sequence",
    "content": "### <a name=\"rf-range\"></a>F.24: Use a `span<T>` or a `span_p<T>` to designate a half-open sequence\n\n##### Reason\n\nInformal/non-explicit ranges are a source of errors.\n\n##### Example\n\n    X* find(span<X> r, const X& v);    // find v in r\n\n    vector<X> vec;\n    // ...\n    auto p = find({vec.begin(), vec.end()}, X{});  // find X{} in vec\n\n##### Note\n\nRanges are extremely common in C++ code. Typically, they are implicit and their correct use is very hard to ensure.\nIn particular, given a pair of arguments `(p, n)` designating an array `[p:p+n)`,\nit is in general impossible to know if there really are `n` elements to access following `*p`.\n`span<T>` and `span_p<T>` are simple helper classes designating a `[p:q)` range and a range starting with `p` and ending with the first element for which a predicate is true, respectively.\n\n##### Example\n\nA `span` represents a range of elements, but how do we manipulate elements of that range?\n\n    void f(span<int> s)\n    {\n        // range traversal (guaranteed correct)\n        for (int x : s) cout << x << '\\n';\n\n        // C-style traversal (potentially checked)\n        for (gsl::index i = 0; i < s.size(); ++i) cout << s[i] << '\\n';\n\n        // random access (potentially checked)\n        s[7] = 9;\n\n        // extract pointers (potentially checked)\n        std::sort(&s[0], &s[s.size() / 2]);\n    }\n\n##### Note\n\nA `span<T>` object does not own its elements and is so small that it can be passed by value.\n\nPassing a `span` object as an argument is exactly as efficient as passing a pair of pointer arguments or passing a pointer and an integer count.\n\n**See also**: [Support library](#gsl-guidelines-support-library)\n\n##### Enforcement\n\n(Complex) Warn where accesses to pointer parameters are bounded by other parameters that are integral types and suggest they could use `span` instead.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-zstring\"></a>F.25: Use a `zstring` or a `not_null<zstring>` to designate a C-style string",
    "content": "### <a name=\"rf-zstring\"></a>F.25: Use a `zstring` or a `not_null<zstring>` to designate a C-style string\n\n##### Reason\n\nC-style strings are ubiquitous. They are defined by convention: zero-terminated arrays of characters.\nWe must distinguish C-style strings from a pointer to a single character or an old-fashioned pointer to an array of characters.\n\nIf you don't need null termination, use `string_view`.\n\n##### Example\n\nConsider:\n\n    int length(const char* p);\n\nWhen I call `length(s)` should I check if `s` is `nullptr` first? Should the implementation of `length()` check if `p` is `nullptr`?\n\n    // the implementor of length() must assume that p == nullptr is possible\n    int length(zstring p);\n\n    // it is the caller's job to make sure p != nullptr\n    int length(not_null<zstring> p);\n\n##### Note\n\n`zstring` does not represent ownership.\n\n**See also**: [Support library](#gsl-guidelines-support-library)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-unique_ptr\"></a>F.26: Use a `unique_ptr<T>` to transfer ownership where a pointer is needed",
    "content": "### <a name=\"rf-unique_ptr\"></a>F.26: Use a `unique_ptr<T>` to transfer ownership where a pointer is needed\n\n##### Reason\n\nUsing `unique_ptr` is the cheapest way to pass a pointer safely.\n\n**See also**: [C.50](#rc-factory) regarding when to return a `shared_ptr` from a factory.\n\n##### Example\n\n    unique_ptr<Shape> get_shape(istream& is)  // assemble shape from input stream\n    {\n        auto kind = read_header(is); // read header and identify the next shape on input\n        switch (kind) {\n        case kCircle:\n            return make_unique<Circle>(is);\n        case kTriangle:\n            return make_unique<Triangle>(is);\n        // ...\n        }\n    }\n\n##### Note\n\nYou need to pass a pointer rather than an object if what you are transferring is an object from a class hierarchy that is to be used through an interface (base class).\n\n##### Enforcement\n\n(Simple) Warn if a function returns a locally allocated raw pointer. Suggest using either `unique_ptr` or `shared_ptr` instead.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-shared_ptr\"></a>F.27: Use a `shared_ptr<T>` to share ownership",
    "content": "### <a name=\"rf-shared_ptr\"></a>F.27: Use a `shared_ptr<T>` to share ownership\n\n##### Reason\n\nUsing `std::shared_ptr` is the standard way to represent shared ownership. That is, the last owner deletes the object.\n\n##### Example\n\n    {\n        shared_ptr<const Image> im { read_image(somewhere) };\n\n        std::thread t0 {shade, args0, top_left, im};\n        std::thread t1 {shade, args1, top_right, im};\n        std::thread t2 {shade, args2, bottom_left, im};\n        std::thread t3 {shade, args3, bottom_right, im};\n\n        // detaching threads requires extra care (e.g., to join before\n        // main ends), but even if we do detach the four threads here ...\n    }\n    // ... shared_ptr ensures that eventually the last thread to\n    //     finish safely deletes the image\n\n##### Note\n\nPrefer a `unique_ptr` over a `shared_ptr` if there is never more than one owner at a time.\n`shared_ptr` is for shared ownership.\n\nNote that pervasive use of `shared_ptr` has a cost (atomic operations on the `shared_ptr`'s reference count have a measurable aggregate cost).\n\n##### Alternative\n\nHave a single object own the shared object (e.g. a scoped object) and destroy that (preferably implicitly) when all users have completed.\n\n##### Enforcement\n\n(Not enforceable) This is a too complex pattern to reliably detect.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-return-ptr\"></a>F.42: Return a `T*` to indicate a position (only)",
    "content": "### <a name=\"rf-return-ptr\"></a>F.42: Return a `T*` to indicate a position (only)\n\n##### Reason\n\nThat's what pointers are good for.\nReturning a `T*` to transfer ownership is a misuse.\n\n##### Example\n\n    Node* find(Node* t, const string& s)  // find s in a binary tree of Nodes\n    {\n        if (!t || t->name == s) return t;\n        if ((auto p = find(t->left, s))) return p;\n        if ((auto p = find(t->right, s))) return p;\n        return nullptr;\n    }\n\nIf it isn't the `nullptr`, the pointer returned by `find` indicates a `Node` holding `s`.\nImportantly, that does not imply a transfer of ownership of the pointed-to object to the caller.\n\n##### Note\n\nPositions can also be transferred by iterators, indices, and references.\nA reference is often a superior alternative to a pointer [if there is no need to use `nullptr`](#rf-ptr-ref) or [if the object referred to should not change](#s-const).\n\n##### Note\n\nDo not return a pointer to something that is not in the caller's scope; see [F.43](#rf-dangle).\n\n**See also**: [discussion of dangling pointer prevention](#???)\n\n##### Enforcement\n\n* Flag `delete`, `std::free()`, etc. applied to a plain `T*`.\nOnly owners should be deleted.\n* Flag `new`, `malloc()`, etc. assigned to a plain `T*`.\nOnly owners should be responsible for deletion.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-dangle\"></a>F.43: Never (directly or indirectly) return a pointer or a reference to a local object",
    "content": "### <a name=\"rf-dangle\"></a>F.43: Never (directly or indirectly) return a pointer or a reference to a local object\n\n##### Reason\n\nTo avoid the crashes and data corruption that can result from the use of such a dangling pointer.\n\n##### Example, bad\n\nAfter the return from a function its local objects no longer exist:\n\n    int* f()\n    {\n        int fx = 9;\n        return &fx;  // BAD\n    }\n\n    void g(int* p)   // looks innocent enough\n    {\n        int gx;\n        cout << \"*p == \" << *p << '\\n';\n        *p = 999;\n        cout << \"gx == \" << gx << '\\n';\n    }\n\n    void h()\n    {\n        int* p = f();\n        int z = *p;  // read from abandoned stack frame (bad)\n        g(p);        // pass pointer to abandoned stack frame to function (bad)\n    }\n\nHere on one popular implementation I got the output:\n\n    *p == 999\n    gx == 999\n\nI expected that because the call of `g()` reuses the stack space abandoned by the call of `f()` so `*p` refers to the space now occupied by `gx`.\n\n* Imagine what would happen if `fx` and `gx` were of different types.\n* Imagine what would happen if `fx` or `gx` was a type with an invariant.\n* Imagine what would happen if that dangling pointer was passed around among a larger set of functions.\n* Imagine what a cracker could do with that dangling pointer.\n\nFortunately, most (all?) modern compilers catch and warn against this simple case.\n\n##### Note\n\nThis applies to references as well:\n\n    int& f()\n    {\n        int x = 7;\n        // ...\n        return x;  // Bad: returns reference to object that is about to be destroyed\n    }\n\n##### Note\n\nThis applies only to non-`static` local variables.\nAll `static` variables are (as their name indicates) statically allocated, so that pointers to them cannot dangle.\n\n##### Example, bad\n\nNot all examples of leaking a pointer to a local variable are that obvious:\n\n    int* glob;       // global variables are bad in so many ways\n\n    template<class T>\n    void steal(T x)\n    {\n        glob = x();  // BAD\n    }\n\n    void f()\n    {\n        int i = 99;\n        steal([&] { return &i; });\n    }\n\n    int main()\n    {\n        f();\n        cout << *glob << '\\n';\n    }\n\nHere I managed to read the location abandoned by the call of `f`.\nThe pointer stored in `glob` could be used much later and cause trouble in unpredictable ways.\n\n##### Note\n\nThe address of a local variable can be \"returned\"/leaked by a return statement, by a `T&` out-parameter, as a member of a returned object, as an element of a returned array, and more.\n\n##### Note\n\nSimilar examples can be constructed \"leaking\" a pointer from an inner scope to an outer one;\nsuch examples are handled equivalently to leaks of pointers out of a function.\n\nA slightly different variant of the problem is placing pointers in a container that outlives the objects pointed to.\n\n**See also**: Another way of getting dangling pointers is [pointer invalidation](#???).\nIt can be detected/prevented with similar techniques.\n\n##### Enforcement\n\n* Compilers tend to catch return of reference to locals and could in many cases catch return of pointers to locals.\n* Static analysis can catch many common patterns of the use of pointers indicating positions (thus eliminating dangling pointers)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-return-ref\"></a>F.44: Return a `T&` when copy is undesirable and \"returning no object\" isn't needed",
    "content": "### <a name=\"rf-return-ref\"></a>F.44: Return a `T&` when copy is undesirable and \"returning no object\" isn't needed\n\n##### Reason\n\nThe language guarantees that a `T&` refers to an object, so that testing for `nullptr` isn't necessary.\n\n**See also**: The return of a reference must not imply transfer of ownership:\n[discussion of dangling pointer prevention](#???) and [discussion of ownership](#???).\n\n##### Example\n\n    class Car\n    {\n        array<wheel, 4> w;\n        // ...\n    public:\n        wheel& get_wheel(int i) { Expects(i < w.size()); return w[i]; }\n        // ...\n    };\n\n    void use()\n    {\n        Car c;\n        wheel& w0 = c.get_wheel(0); // w0 has the same lifetime as c\n    }\n\n##### Enforcement\n\nFlag functions where no `return` expression could yield `nullptr`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-return-ref-ref\"></a>F.45: Don't return a `T&&`",
    "content": "### <a name=\"rf-return-ref-ref\"></a>F.45: Don't return a `T&&`\n\n##### Reason\n\nIt's asking to return a reference to a destroyed temporary object.\nAn `&&` is a magnet for temporary objects.\n\n##### Example\n\nA returned rvalue reference goes out of scope at the end of the full expression to which it is returned:\n\n    auto&& x = max(0, 1);   // OK, so far\n    foo(x);                 // Undefined behavior\n\nThis kind of use is a frequent source of bugs, often incorrectly reported as a compiler bug.\nAn implementer of a function should avoid setting such traps for users.\n\nThe [lifetime safety profile](#ss-lifetime) will (when completely implemented) catch such problems.\n\n\n##### Example\n\nReturning an rvalue reference is fine when the reference to the temporary is being passed \"downward\" to a callee;\nthen, the temporary is guaranteed to outlive the function call (see [F.18](#rf-consume) and [F.19](#rf-forward)).\nHowever, it's not fine when passing such a reference \"upward\" to a larger caller scope.\nFor passthrough functions that pass in parameters (by ordinary reference or by perfect forwarding) and want to return values, use simple `auto` return type deduction (not `auto&&`).\n\nAssume that `F` returns by value:\n\n    template<class F>\n    auto&& wrapper(F f)\n    {\n        log_call(typeid(f)); // or whatever instrumentation\n        return f();          // BAD: returns a reference to a temporary\n    }\n\nBetter:\n\n    template<class F>\n    auto wrapper(F f)\n    {\n        log_call(typeid(f)); // or whatever instrumentation\n        return f();          // OK\n    }\n\n\n##### Exception\n\n`std::move` and `std::forward` do return `&&`, but they are just casts -- used by convention only in expression contexts where a reference to a temporary object is passed along within the same expression before the temporary is destroyed. We don't know of any other good examples of returning `&&`.\n\n##### Enforcement\n\nFlag any use of `&&` as a return type, except in `std::move` and `std::forward`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-main\"></a>F.46: `int` is the return type for `main()`",
    "content": "### <a name=\"rf-main\"></a>F.46: `int` is the return type for `main()`\n\n##### Reason\n\nIt's a language rule, but violated through \"language extensions\" so often that it is worth mentioning.\nDeclaring `main` (the one global `main` of a program) `void` limits portability.\n\n##### Example\n\n        void main() { /* ... */ };  // bad, not C++\n\n        int main()\n        {\n            std::cout << \"This is the way to do it\\n\";\n        }\n\n##### Note\n\nWe mention this only because of the persistence of this error in the community.\nNote that despite its non-void return type, the main function does not require an explicit return statement.\n\n##### Enforcement\n\n* The compiler should do it\n* If the compiler doesn't do it, let tools flag it\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-assignment-op\"></a>F.47: Return `T&` from assignment operators",
    "content": "### <a name=\"rf-assignment-op\"></a>F.47: Return `T&` from assignment operators\n\n##### Reason\n\nThe convention for operator overloads (especially on concrete types) is for\n`operator=(const T&)` to perform the assignment and then return (non-`const`)\n`*this`.  This ensures consistency with standard-library types and follows the\nprinciple of \"do as the ints do.\"\n\n##### Note\n\nHistorically there was some guidance to make the assignment operator return `const T&`.\nThis was primarily to avoid code of the form `(a = b) = c` -- such code is not common enough to warrant violating consistency with standard types.\n\n##### Example\n\n    class Foo\n    {\n     public:\n        ...\n        Foo& operator=(const Foo& rhs)\n        {\n          // Copy members.\n          ...\n          return *this;\n        }\n    };\n\n##### Enforcement\n\nThis should be enforced by tooling by checking the return type (and return\nvalue) of any assignment operator.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-return-move-local\"></a>F.48: Don't `return std::move(local)`",
    "content": "### <a name=\"rf-return-move-local\"></a>F.48: Don't `return std::move(local)`\n\n##### Reason\n\nReturning a local variable implicitly moves it anyway.\nAn explicit `std::move` is always a pessimization, because it prevents Return Value Optimization (RVO),\nwhich can eliminate the move completely.\n\n##### Example, bad\n\n    S bad()\n    {\n      S result;\n      return std::move(result);\n    }\n\n##### Example, good\n\n    S good()\n    {\n      S result;\n      // Named RVO: move elision at best, move construction at worst\n      return result;\n    }\n\n##### Enforcement\n\nThis should be enforced by tooling by checking the return expression.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-return-const\"></a>F.49: Don't return `const T`",
    "content": "### <a name=\"rf-return-const\"></a>F.49: Don't return `const T`\n\n##### Reason\n\nIt is not recommended to return a `const` value.\nSuch older advice is now obsolete; it does not add value, and it interferes with move semantics.\n\n##### Example\n\n    const vector<int> fct();    // bad: that \"const\" is more trouble than it is worth\n\n    void g(vector<int>& vx)\n    {\n        // ...\n        fct() = vx;   // prevented by the \"const\"\n        // ...\n        vx = fct(); // expensive copy: move semantics suppressed by the \"const\"\n        // ...\n    }\n\nThe argument for adding `const` to a return value is that it prevents (very rare) accidental access to a temporary.\nThe argument against is that it prevents (very frequent) use of move semantics.\n\n**See also**: [F.20, the general item about \"out\" output values](#rf-out)\n\n##### Enforcement\n\n* Flag returning a `const` value. To fix: Remove `const` to return a non-`const` value instead.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-capture-vs-overload\"></a>F.50: Use a lambda when a function won't do (to capture local variables, or to write a local function)",
    "content": "### <a name=\"rf-capture-vs-overload\"></a>F.50: Use a lambda when a function won't do (to capture local variables, or to write a local function)\n\n##### Reason\n\nFunctions can't capture local variables or be defined at local scope; if you need those things, prefer a lambda where possible, and a handwritten function object where not. On the other hand, lambdas and function objects don't overload; if you need to overload, prefer a function (the workarounds to make lambdas overload are ornate). If either will work, prefer writing a function; use the simplest tool necessary.\n\n##### Example\n\n    // writing a function that should only take an int or a string\n    // -- overloading is natural\n    void f(int);\n    void f(const string&);\n\n    // writing a function object that needs to capture local state and appear\n    // at statement or expression scope -- a lambda is natural\n    vector<work> v = lots_of_work();\n    for (int tasknum = 0; tasknum < max; ++tasknum) {\n        pool.run([=, &v] {\n            /*\n            ...\n            ... process (1/max)-th of v, the tasknum-th chunk\n            ...\n            */\n        });\n    }\n    pool.join();\n\n##### Exception\n\nGeneric lambdas offer a concise way to write function templates and so can be useful even when a normal function template would do equally well with a little more syntax. This advantage will probably disappear in the future once all functions gain the ability to have Concept parameters.\n\n##### Enforcement\n\n* Warn on use of a named non-generic lambda (e.g., `auto x = [](int i) { /*...*/; };`) that captures nothing and appears at global scope. Write an ordinary function instead.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-default-args\"></a>F.51: Where there is a choice, prefer default arguments over overloading",
    "content": "### <a name=\"rf-default-args\"></a>F.51: Where there is a choice, prefer default arguments over overloading\n\n##### Reason\n\nDefault arguments simply provide alternative interfaces to a single implementation.\nThere is no guarantee that a set of overloaded functions all implement the same semantics.\nThe use of default arguments can avoid code replication.\n\n##### Note\n\nThere is a choice between using default argument and overloading when the alternatives are from a set of arguments of the same types.\nFor example:\n\n    void print(const string& s, format f = {});\n\nas opposed to\n\n    void print(const string& s);  // use default format\n    void print(const string& s, format f);\n\nThere is not a choice when a set of functions are used to do a semantically equivalent operation to a set of types. For example:\n\n    void print(const char&);\n    void print(int);\n    void print(zstring);\n\n##### See also\n\n\n[Default arguments for virtual functions](#rh-virtual-default-arg)\n\n##### Enforcement\n\n* Warn on an overload set where the overloads have a common prefix of parameters (e.g., `f(int)`, `f(int, const string&)`, `f(int, const string&, double)`). (Note: Review this enforcement if it's too noisy in practice.)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-reference-capture\"></a>F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms",
    "content": "### <a name=\"rf-reference-capture\"></a>F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms\n\n##### Reason\n\nFor efficiency and correctness, you nearly always want to capture by reference when using the lambda locally. This includes when writing or calling parallel algorithms that are local because they join before returning.\n\n##### Discussion\n\nThe efficiency consideration is that most types are cheaper to pass by reference than by value.\n\nThe correctness consideration is that many calls want to perform side effects on the original object at the call site (see example below). Passing by value prevents this.\n\n##### Note\n\nUnfortunately, there is no simple way to capture by reference to `const` to get the efficiency for a local call but also prevent side effects.\n\n##### Example\n\nHere, a large object (a network message) is passed to an iterative algorithm, and it is not efficient or correct to copy the message (which might not be copyable):\n\n    std::for_each(begin(sockets), end(sockets), [&message](auto& socket)\n    {\n        socket.send(message);\n    });\n\n##### Example\n\nThis is a simple three-stage parallel pipeline. Each `stage` object encapsulates a worker thread and a queue, has a `process` function to enqueue work, and in its destructor automatically blocks waiting for the queue to empty before ending the thread.\n\n    void send_packets(buffers& bufs)\n    {\n        stage encryptor([](buffer& b) { encrypt(b); });\n        stage compressor([&](buffer& b) { compress(b); encryptor.process(b); });\n        stage decorator([&](buffer& b) { decorate(b); compressor.process(b); });\n        for (auto& b : bufs) { decorator.process(b); }\n    }  // automatically blocks waiting for pipeline to finish\n\n##### Enforcement\n\nFlag a lambda that captures by reference, but is used other than locally within the function scope or passed to a function by reference. (Note: This rule is an approximation, but does flag passing by pointer as those are more likely to be stored by the callee, writing to a heap location accessed via a parameter, returning the lambda, etc. The Lifetime rules will also provide general rules that flag escaping pointers and references including via lambdas.)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-value-capture\"></a>F.53: Avoid capturing by reference in lambdas that will be used non-locally, including returned, stored on the heap, or passed to another thread",
    "content": "### <a name=\"rf-value-capture\"></a>F.53: Avoid capturing by reference in lambdas that will be used non-locally, including returned, stored on the heap, or passed to another thread\n\n##### Reason\n\nPointers and references to locals shouldn't outlive their scope. Lambdas that capture by reference are just another place to store a reference to a local object, and shouldn't do so if they (or a copy) outlive the scope.\n\n##### Example, bad\n\n    int local = 42;\n\n    // Want a reference to local.\n    // Note that after program exits this scope,\n    // local no longer exists, therefore\n    // process() call will have undefined behavior!\n    thread_pool.queue_work([&] { process(local); });\n\n##### Example, good\n\n    int local = 42;\n    // Want a copy of local.\n    // Since a copy of local is made, it will\n    // always be available for the call.\n    thread_pool.queue_work([=] { process(local); });\n\n##### Note\n\nIf a non-local pointer must be captured, consider using `unique_ptr`; this handles both lifetime and synchronization.\n\nIf the `this` pointer must be captured, consider using `[*this]` capture, which creates a copy of the entire object.\n\n##### Enforcement\n\n* (Simple) Warn when capture-list contains a reference to a locally declared variable\n* (Complex) Flag when capture-list contains a reference to a locally declared variable and the lambda is passed to a non-`const` and non-local context\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rf-this-capture\"></a>F.54: When writing a lambda that captures `this` or any class data member, don't use `[=]` default capture",
    "content": "### <a name=\"rf-this-capture\"></a>F.54: When writing a lambda that captures `this` or any class data member, don't use `[=]` default capture\n\n##### Reason\n\nIt's confusing. Writing `[=]` in a member function appears to capture by value, but actually captures data members by reference because it actually captures the invisible `this` pointer by value. If you meant to do that, write `this` explicitly.\n\n##### Example\n\n    class My_class {\n        int x = 0;\n        // ...\n\n        void f()\n        {\n            int i = 0;\n            // ...\n\n            auto lambda = [=] { use(i, x); };   // BAD: \"looks like\" copy/value capture\n\n            x = 42;\n            lambda(); // calls use(0, 42);\n            x = 43;\n            lambda(); // calls use(0, 43);\n\n            // ...\n\n            auto lambda2 = [i, this] { use(i, x); }; // ok, most explicit and least confusing\n\n            // ...\n        }\n    };\n\n##### Note\n\nIf you intend to capture a copy of all class data members, consider C++17 `[*this]`.\n\n##### Enforcement\n\n* Flag any lambda capture-list that specifies a capture-default of `[=]` and also captures `this` (whether explicitly or via the default capture and a use of `this` in the body)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"f-varargs\"></a>F.55: Don't use `va_arg` arguments",
    "content": "### <a name=\"f-varargs\"></a>F.55: Don't use `va_arg` arguments\n\n##### Reason\n\nReading from a `va_arg` assumes that the correct type was actually passed.\nPassing to varargs assumes the correct type will be read.\nThis is fragile because it cannot generally be enforced to be safe in the language and so relies on programmer discipline to get it right.\n\n##### Example\n\n    int sum(...)\n    {\n        // ...\n        while (/*...*/)\n            result += va_arg(list, int); // BAD, assumes it will be passed ints\n        // ...\n    }\n\n    sum(3, 2); // ok\n    sum(3.14159, 2.71828); // BAD, undefined\n\n    template<class ...Args>\n    auto sum(Args... args) // GOOD, and much more flexible\n    {\n        return (... + args); // note: C++17 \"fold expression\"\n    }\n\n    sum(3, 2); // ok: 5\n    sum(3.14159, 2.71828); // ok: ~5.85987\n\n##### Alternatives\n\n* overloading\n* variadic templates\n* `variant` arguments\n* `initializer_list` (homogeneous)\n\n##### Note\n\nDeclaring a `...` parameter is sometimes useful for techniques that don't involve actual argument passing, notably to declare \"take-anything\" functions so as to disable \"everything else\" in an overload set or express a catchall case in a template metaprogram.\n\n##### Enforcement\n\n* Issue a diagnostic for using `va_list`, `va_start`, or `va_arg`.\n* Issue a diagnostic for passing an argument to a vararg parameter of a function that does not offer an overload for a more specific type in the position of the vararg. To fix: Use a different function, or `[[suppress(\"type\")]]`.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"f-nesting\"></a>F.56: Avoid unnecessary condition nesting",
    "content": "### <a name=\"f-nesting\"></a>F.56: Avoid unnecessary condition nesting\n\n##### Reason\n\nShallow nesting of conditions makes the code easier to follow. It also makes the intent clearer.\nStrive to place the essential code at outermost scope, unless this obscures intent.\n\n##### Example\n\nUse a guard-clause to take care of exceptional cases and return early.\n\n    // Bad: Deep nesting\n    void foo() {\n        ...\n        if (x) {\n            computeImportantThings(x);\n        }\n    }\n\n    // Bad: Still a redundant else.\n    void foo() {\n        ...\n        if (!x) {\n            return;\n        }\n        else {\n            computeImportantThings(x);\n        }\n    }\n\n    // Good: Early return, no redundant else\n    void foo() {\n        ...\n        if (!x)\n            return;\n\n        computeImportantThings(x);\n    }\n\n##### Example\n\n    // Bad: Unnecessary nesting of conditions\n    void foo() {\n        ...\n        if (x) {\n            if (y) {\n                computeImportantThings(x);\n            }\n        }\n    }\n\n    // Good: Merge conditions + return early\n    void foo() {\n        ...\n        if (!(x && y))\n            return;\n\n        computeImportantThings(x);\n    }\n\n##### Enforcement\n\nFlag a redundant `else`.\nFlag a function whose body is simply a conditional statement enclosing a block.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-class\"></a>C: Classes and class hierarchies",
    "content": "# <a name=\"s-class\"></a>C: Classes and class hierarchies\n\nA class is a user-defined type, for which a programmer can define the representation, operations, and interfaces.\nClass hierarchies are used to organize related classes into hierarchical structures.\n\nClass rule summary:\n\n* [C.1: Organize related data into structures (`struct`s or `class`es)](#rc-org)\n* [C.2: Use `class` if the class has an invariant; use `struct` if the data members can vary independently](#rc-struct)\n* [C.3: Represent the distinction between an interface and an implementation using a class](#rc-interface)\n* [C.4: Make a function a member only if it needs direct access to the representation of a class](#rc-member)\n* [C.5: Place helper functions in the same namespace as the class they support](#rc-helper)\n* [C.7: Don't define a class or enum and declare a variable of its type in the same statement](#rc-standalone)\n* [C.8: Use `class` rather than `struct` if any member is non-public](#rc-class)\n* [C.9: Minimize exposure of members](#rc-private)\n\nSubsections:\n\n* [C.concrete: Concrete types](#ss-concrete)\n* [C.ctor: Constructors, assignments, and destructors](#s-ctor)\n* [C.con: Containers and other resource handles](#ss-containers)\n* [C.lambdas: Function objects and lambdas](#ss-lambdas)\n* [C.hier: Class hierarchies (OOP)](#ss-hier)\n* [C.over: Overloading and overloaded operators](#ss-overload)\n* [C.union: Unions](#ss-union)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-org\"></a>C.1: Organize related data into structures (`struct`s or `class`es)",
    "content": "### <a name=\"rc-org\"></a>C.1: Organize related data into structures (`struct`s or `class`es)\n\n##### Reason\n\nEase of comprehension.\nIf data is related (for fundamental reasons), that fact should be reflected in code.\n\n##### Example\n\n    void draw(int x, int y, int x2, int y2);  // BAD: unnecessary implicit relationships\n    void draw(Point from, Point to);          // better\n\n##### Note\n\nA simple class without virtual functions implies no space or time overhead.\n\n##### Note\n\nFrom a language perspective `class` and `struct` differ only in the default visibility of their members.\n\n##### Enforcement\n\nProbably impossible. Maybe a heuristic looking for data items used together is possible.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-struct\"></a>C.2: Use `class` if the class has an invariant; use `struct` if the data members can vary independently",
    "content": "### <a name=\"rc-struct\"></a>C.2: Use `class` if the class has an invariant; use `struct` if the data members can vary independently\n\n##### Reason\n\nReadability.\nEase of comprehension.\nThe use of `class` alerts the programmer to the need for an invariant.\nThis is a useful convention.\n\n##### Note\n\nAn invariant is a logical condition for the members of an object that a constructor must establish for the public member functions to assume.\nAfter the invariant is established (typically by a constructor) every member function can be called for the object.\nAn invariant can be stated informally (e.g., in a comment) or more formally using `Expects`.\n\nIf all data members can vary independently of each other, no invariant is possible.\n\n##### Example\n\n    struct Pair {  // the members can vary independently\n        string name;\n        int volume;\n    };\n\nbut:\n\n    class Date {\n    public:\n        // validate that {yy, mm, dd} is a valid date and initialize\n        Date(int yy, Month mm, char dd);\n        // ...\n    private:\n        int y;\n        Month m;\n        char d;    // day\n    };\n\n##### Note\n\nIf a class has any `private` data, a user cannot completely initialize an object without the use of a constructor.\nHence, the class definer will provide a constructor and must specify its meaning.\nThis effectively means the definer needs to define an invariant.\n\n**See also**:\n\n* [define a class with private data as `class`](#rc-class)\n* [Prefer to place the interface first in a class](#rl-order)\n* [minimize exposure of members](#rc-private)\n* [Avoid `protected` data](#rh-protected)\n\n##### Enforcement\n\nLook for `struct`s with all data private and `class`es with public members.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-interface\"></a>C.3: Represent the distinction between an interface and an implementation using a class",
    "content": "### <a name=\"rc-interface\"></a>C.3: Represent the distinction between an interface and an implementation using a class\n\n##### Reason\n\nAn explicit distinction between interface and implementation improves readability and simplifies maintenance.\n\n##### Example\n\n    class Date {\n    public:\n        Date();\n        // validate that {yy, mm, dd} is a valid date and initialize\n        Date(int yy, Month mm, char dd);\n\n        int day() const;\n        Month month() const;\n        // ...\n    private:\n        // ... some representation ...\n    };\n\nFor example, we can now change the representation of a `Date` without affecting its users (recompilation is likely, though).\n\n##### Note\n\nUsing a class in this way to represent the distinction between interface and implementation is of course not the only way.\nFor example, we can use a set of declarations of freestanding functions in a namespace, an abstract base class, or a function template with concepts to represent an interface.\nThe most important issue is to explicitly distinguish between an interface and its implementation \"details.\"\nIdeally, and typically, an interface is far more stable than its implementation(s).\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-member\"></a>C.4: Make a function a member only if it needs direct access to the representation of a class",
    "content": "### <a name=\"rc-member\"></a>C.4: Make a function a member only if it needs direct access to the representation of a class\n\n##### Reason\n\nLess coupling than with member functions, fewer functions that can cause trouble by modifying object state, reduces the number of functions that need to be modified after a change in representation.\n\n##### Example\n\n    class Date {\n        // ... relatively small interface ...\n    };\n\n    // helper functions:\n    Date next_weekday(Date);\n    bool operator==(Date, Date);\n\nThe \"helper functions\" have no need for direct access to the representation of a `Date`.\n\n##### Note\n\nThis rule becomes even better if C++ gets [\"uniform function call\"](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0251r0.pdf).\n\n##### Exception\n\nThe language requires `virtual` functions to be members, and not all `virtual` functions directly access data.\nIn particular, members of an abstract class rarely do.\n\nNote [multi-methods](https://web.archive.org/web/20200605021759/https://parasol.tamu.edu/~yuriys/papers/OMM10.pdf).\n\n##### Exception\n\nThe language requires operators `=`, `()`, `[]`, and `->` to be members.\n\n##### Exception\n\nAn overload set could have some members that do not directly access `private` data:\n\n    class Foobar {\n    public:\n        void foo(long x) { /* manipulate private data */ }\n        void foo(double x) { foo(std::lround(x)); }\n        // ...\n    private:\n        // ...\n    };\n\n##### Exception\n\nSimilarly, a set of functions could be designed to be used in a chain:\n\n    x.scale(0.5).rotate(45).set_color(Color::red);\n\nTypically, some but not all of such functions directly access `private` data.\n\n##### Enforcement\n\n* Look for non-`virtual` member functions that do not touch data members directly.\nThe snag is that many member functions that do not need to touch data members directly do.\n* Ignore `virtual` functions.\n* Ignore functions that are part of an overload set out of which at least one function accesses `private` members.\n* Ignore functions returning `this`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-helper\"></a>C.5: Place helper functions in the same namespace as the class they support",
    "content": "### <a name=\"rc-helper\"></a>C.5: Place helper functions in the same namespace as the class they support\n\n##### Reason\n\nA helper function is a function (usually supplied by the writer of a class) that does not need direct access to the representation of the class, yet is seen as part of the useful interface to the class.\nPlacing them in the same namespace as the class makes their relationship to the class obvious and allows them to be found by argument dependent lookup.\n\n##### Example\n\n    namespace Chrono { // here we keep time-related services\n\n        class Time { /* ... */ };\n        class Date { /* ... */ };\n\n        // helper functions:\n        bool operator==(Date, Date);\n        Date next_weekday(Date);\n        // ...\n    }\n\n##### Note\n\nThis is especially important for [overloaded operators](#ro-namespace).\n\n##### Enforcement\n\n* Flag global functions taking argument types from a single namespace.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-standalone\"></a>C.7: Don't define a class or enum and declare a variable of its type in the same statement",
    "content": "### <a name=\"rc-standalone\"></a>C.7: Don't define a class or enum and declare a variable of its type in the same statement\n\n##### Reason\n\nMixing a type definition and the definition of another entity in the same declaration is confusing and unnecessary.\n\n##### Example, bad\n\n    struct Data { /*...*/ } data{ /*...*/ };\n\n##### Example, good\n\n    struct Data { /*...*/ };\n    Data data{ /*...*/ };\n\n##### Enforcement\n\n* Flag if the `}` of a class or enumeration definition is not followed by a `;`. The `;` is missing.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-class\"></a>C.8: Use `class` rather than `struct` if any member is non-public",
    "content": "### <a name=\"rc-class\"></a>C.8: Use `class` rather than `struct` if any member is non-public\n\n##### Reason\n\nReadability.\nTo make it clear that something is being hidden/abstracted.\nThis is a useful convention.\n\n##### Example, bad\n\n    struct Date {\n        int d, m;\n\n        Date(int i, Month m);\n        // ... lots of functions ...\n    private:\n        int y;  // year\n    };\n\nThere is nothing wrong with this code as far as the C++ language rules are concerned,\nbut nearly everything is wrong from a design perspective.\nThe private data is hidden far from the public data.\nThe data is split in different parts of the class declaration.\nDifferent parts of the data have different access.\nAll of this decreases readability and complicates maintenance.\n\n##### Note\n\nPrefer to place the interface first in a class, [see NL.16](#rl-order).\n\n##### Enforcement\n\nFlag classes declared with `struct` if there is a `private` or `protected` member.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-private\"></a>C.9: Minimize exposure of members",
    "content": "### <a name=\"rc-private\"></a>C.9: Minimize exposure of members\n\n##### Reason\n\nEncapsulation.\nInformation hiding.\nMinimize the chance of unintended access.\nThis simplifies maintenance.\n\n##### Example\n\n    template<typename T, typename U>\n    struct pair {\n        T a;\n        U b;\n        // ...\n    };\n\nWhatever we do in the `//`-part, an arbitrary user of a `pair` can arbitrarily and independently change its `a` and `b`.\nIn a large code base, we cannot easily find which code does what to the members of `pair`.\nThis might be exactly what we want, but if we want to enforce a relation among members, we need to make them `private`\nand enforce that relation (invariant) through constructors and member functions.\nFor example:\n\n    class Distance {\n    public:\n        // ...\n        double meters() const { return magnitude*unit; }\n        void set_unit(double u)\n        {\n                // ... check that u is a factor of 10 ...\n                // ... change magnitude appropriately ...\n                unit = u;\n        }\n        // ...\n    private:\n        double magnitude;\n        double unit;    // 1 is meters, 1000 is kilometers, 0.001 is millimeters, etc.\n    };\n\n##### Note\n\nIf the set of direct users of a set of variables cannot be easily determined, the type or usage of that set cannot be (easily) changed/improved.\nFor `public` and `protected` data, that's usually the case.\n\n##### Example\n\nA class can provide two interfaces to its users.\nOne for derived classes (`protected`) and one for general users (`public`).\nFor example, a derived class might be allowed to skip a run-time check because it has already guaranteed correctness:\n\n    class Foo {\n    public:\n        int bar(int x) { check(x); return do_bar(x); }\n        // ...\n    protected:\n        int do_bar(int x); // do some operation on the data\n        // ...\n    private:\n        // ... data ...\n    };\n\n    class Dir : public Foo {\n        //...\n        int mem(int x, int y)\n        {\n            /* ... do something ... */\n            return do_bar(x + y); // OK: derived class can bypass check\n        }\n    };\n\n    void user(Foo& x)\n    {\n        int r1 = x.bar(1);      // OK, will check\n        int r2 = x.do_bar(2);   // error: would bypass check\n        // ...\n    }\n\n##### Note\n\n[`protected` data is a bad idea](#rh-protected).\n\n##### Note\n\nPrefer the order `public` members before `protected` members before `private` members; see [NL.16](#rl-order).\n\n##### Enforcement\n\n* [Flag protected data](#rh-protected).\n* Flag mixtures of `public` and `private` data\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-concrete\"></a>C.concrete: Concrete types",
    "content": "## <a name=\"ss-concrete\"></a>C.concrete: Concrete types\n\nConcrete type rule summary:\n\n* [C.10: Prefer concrete types over class hierarchies](#rc-concrete)\n* [C.11: Make concrete types regular](#rc-regular)\n* [C.12: Don't make data members `const` or references in a copyable or movable type](#rc-constref)\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-concrete\"></a>C.10: Prefer concrete types over class hierarchies",
    "content": "### <a name=\"rc-concrete\"></a>C.10: Prefer concrete types over class hierarchies\n\n##### Reason\n\nA concrete type is fundamentally simpler than a type in a class hierarchy:\neasier to design, easier to implement, easier to use, easier to reason about, smaller, and faster.\nYou need a reason (use cases) for using a hierarchy.\n\n##### Example\n\n    class Point1 {\n        int x, y;\n        // ... operations ...\n        // ... no virtual functions ...\n    };\n\n    class Point2 {\n        int x, y;\n        // ... operations, some virtual ...\n        virtual ~Point2();\n    };\n\n    void use()\n    {\n        Point1 p11 {1, 2};   // make an object on the stack\n        Point1 p12 {p11};    // a copy\n\n        auto p21 = make_unique<Point2>(1, 2);   // make an object on the free store\n        auto p22 = p21->clone();                // make a copy\n        // ...\n    }\n\nIf a class is part of a hierarchy, we (in real code if not necessarily in small examples) must manipulate its objects through pointers or references.\nThat implies more memory overhead, more allocations and deallocations, and more run-time overhead to perform the resulting indirections.\n\n##### Note\n\nConcrete types can be stack-allocated and be members of other classes.\n\n##### Note\n\nThe use of indirection is fundamental for run-time polymorphic interfaces.\nThe allocation/deallocation overhead is not (that's just the most common case).\nWe can use a base class as the interface of a scoped object of a derived class.\nThis is done where dynamic allocation is prohibited (e.g. hard-real-time) and to provide a stable interface to some kinds of plug-ins.\n\n\n##### Enforcement\n\n???\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-regular\"></a>C.11: Make concrete types regular",
    "content": "### <a name=\"rc-regular\"></a>C.11: Make concrete types regular\n\n##### Reason\n\nRegular types are easier to understand and reason about than types that are not regular (irregularities require extra effort to understand and use).\n\nThe C++ built-in types are regular, and so are standard-library classes such as `string`, `vector`, and `map`. Concrete classes without assignment and equality can be defined, but they are (and should be) rare.\n\n##### Example\n\n    struct Bundle {\n        string name;\n        vector<Record> vr;\n    };\n\n    bool operator==(const Bundle& a, const Bundle& b)\n    {\n        return a.name == b.name && a.vr == b.vr;\n    }\n\n    Bundle b1 { \"my bundle\", {r1, r2, r3}};\n    Bundle b2 = b1;\n    if (!(b1 == b2)) error(\"impossible!\");\n    b2.name = \"the other bundle\";\n    if (b1 == b2) error(\"No!\");\n\nIn particular, if a concrete type is copyable, prefer to also give it an equality comparison operator, and ensure that `a = b` implies `a == b`.\n\n##### Note\n\nFor structs intended to be shared with C code, defining `operator==` may not be feasible.\n\n##### Note\n\nHandles for resources that cannot be cloned, e.g., a `scoped_lock` for a `mutex`, are concrete types but typically cannot be copied (instead, they can usually be moved),\nso they can't be regular; instead, they tend to be move-only.\n\n##### Enforcement\n\n???\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-constref\"></a>C.12: Don't make data members `const` or references in a copyable or movable type",
    "content": "### <a name=\"rc-constref\"></a>C.12: Don't make data members `const` or references in a copyable or movable type\n\n##### Reason\n\n`const` and reference data members are not useful in a copyable or movable type, and make such types difficult to use by making them at least partly uncopyable/unmovable for subtle reasons.\n\n##### Example; bad\n\n    class bad {\n        const int i;    // bad\n        string& s;      // bad\n        // ...\n    };\n\nThe `const` and `&` data members make this class \"only-sort-of-copyable\" -- copy-constructible but not copy-assignable.\n\n##### Note\n\nIf you need a member to point to something, use a pointer (raw or smart, and `gsl::not_null` if it should not be null) instead of a reference.\n\n##### Enforcement\n\nFlag a data member that is `const`, `&`, or `&&` in a type that has any copy or move operation.\n\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-ctor\"></a>C.ctor: Constructors, assignments, and destructors",
    "content": "## <a name=\"s-ctor\"></a>C.ctor: Constructors, assignments, and destructors\n\nThese functions control the lifecycle of objects: creation, copy, move, and destruction.\nDefine constructors to guarantee and simplify initialization of classes.\n\nThese are *default operations*:\n\n* a default constructor: `X()`\n* a copy constructor: `X(const X&)`\n* a copy assignment: `operator=(const X&)`\n* a move constructor: `X(X&&)`\n* a move assignment: `operator=(X&&)`\n* a destructor: `~X()`\n\nBy default, the compiler defines each of these operations if it is used, but the default can be suppressed.\n\nThe default operations are a set of related operations that together implement the lifecycle semantics of an object.\nBy default, C++ treats classes as value-like types, but not all types are value-like.\n\nSet of default operations rules:\n\n* [C.20: If you can avoid defining any default operations, do](#rc-zero)\n* [C.21: If you define or `=delete` any copy, move, or destructor function, define or `=delete` them all](#rc-five)\n* [C.22: Make default operations consistent](#rc-matched)\n\nDestructor rules:\n\n* [C.30: Define a destructor if a class needs an explicit action at object destruction](#rc-dtor)\n* [C.31: All resources acquired by a class must be released by the class's destructor](#rc-dtor-release)\n* [C.32: If a class has a raw pointer (`T*`) or reference (`T&`), consider whether it might be owning](#rc-dtor-ptr)\n* [C.33: If a class has an owning pointer member, define a destructor](#rc-dtor-ptr2)\n* [C.35: A base class destructor should be either public and virtual, or protected and non-virtual](#rc-dtor-virtual)\n* [C.36: A destructor must not fail](#rc-dtor-fail)\n* [C.37: Make destructors `noexcept`](#rc-dtor-noexcept)\n\nConstructor rules:\n\n* [C.40: Define a constructor if a class has an invariant](#rc-ctor)\n* [C.41: A constructor should create a fully initialized object](#rc-complete)\n* [C.42: If a constructor cannot construct a valid object, throw an exception](#rc-throw)\n* [C.43: Ensure that a copyable class has a default constructor](#rc-default0)\n* [C.44: Prefer default constructors to be simple and non-throwing](#rc-default00)\n* [C.45: Don't define a default constructor that only initializes data members; use member initializers instead](#rc-default)\n* [C.46: By default, declare single-argument constructors `explicit`](#rc-explicit)\n* [C.47: Define and initialize data members in the order of member declaration](#rc-order)\n* [C.48: Prefer default member initializers to member initializers in constructors for constant initializers](#rc-in-class-initializer)\n* [C.49: Prefer initialization to assignment in constructors](#rc-initialize)\n* [C.50: Use a factory function if you need \"virtual behavior\" during initialization](#rc-factory)\n* [C.51: Use delegating constructors to represent common actions for all constructors of a class](#rc-delegating)\n* [C.52: Use inheriting constructors to import constructors into a derived class that does not need further explicit initialization](#rc-inheriting)\n\nCopy and move rules:\n\n* [C.60: Make copy assignment non-`virtual`, take the parameter by `const&`, and return by non-`const&`](#rc-copy-assignment)\n* [C.61: A copy operation should copy](#rc-copy-semantic)\n* [C.62: Make copy assignment safe for self-assignment](#rc-copy-self)\n* [C.63: Make move assignment non-`virtual`, take the parameter by `&&`, and return by non-`const&`](#rc-move-assignment)\n* [C.64: A move operation should move and leave its source in a valid state](#rc-move-semantic)\n* [C.65: Make move assignment safe for self-assignment](#rc-move-self)\n* [C.66: Make move operations `noexcept`](#rc-move-noexcept)\n* [C.67: A polymorphic class should suppress public copy/move](#rc-copy-virtual)\n\nOther default operations rules:\n\n* [C.80: Use `=default` if you have to be explicit about using the default semantics](#rc-eqdefault)\n* [C.81: Use `=delete` when you want to disable default behavior (without wanting an alternative)](#rc-delete)\n* [C.82: Don't call virtual functions in constructors and destructors](#rc-ctor-virtual)\n* [C.83: For value-like types, consider providing a `noexcept` swap function](#rc-swap)\n* [C.84: A `swap` must not fail](#rc-swap-fail)\n* [C.85: Make `swap` `noexcept`](#rc-swap-noexcept)\n* [C.86: Make `==` symmetric with respect of operand types and `noexcept`](#rc-eq)\n* [C.87: Beware of `==` on base classes](#rc-eq-base)\n* [C.89: Make a `hash` `noexcept`](#rc-hash)\n* [C.90: Rely on constructors and assignment operators, not memset and memcpy](#rc-memset)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-defop\"></a>C.defop: Default Operations",
    "content": "## <a name=\"ss-defop\"></a>C.defop: Default Operations\n\nBy default, the language supplies the default operations with their default semantics.\nHowever, a programmer can disable or replace these defaults.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-zero\"></a>C.20: If you can avoid defining default operations, do",
    "content": "### <a name=\"rc-zero\"></a>C.20: If you can avoid defining default operations, do\n\n##### Reason\n\nIt's the simplest and gives the cleanest semantics.\n\n##### Example\n\n    struct Named_map {\n    public:\n        explicit Named_map(const string& n) : name(n) {}\n        // no copy/move constructors\n        // no copy/move assignment operators\n        // no destructor\n    private:\n        string name;\n        map<int, int> rep;\n    };\n\n    Named_map nm(\"map\"); // construct\n    Named_map nm2 {nm};  // copy construct\n\nSince `std::map` and `string` have all the special functions, no further work is needed.\n\n##### Note\n\nThis is known as \"the rule of zero\".\n\n##### Enforcement\n\n(Not enforceable) While not enforceable, a good static analyzer can detect patterns that indicate a possible improvement to meet this rule.\nFor example, a class with a (pointer, size) pair of members and a destructor that `delete`s the pointer could probably be converted to a `vector`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-five\"></a>C.21: If you define or `=delete` any copy, move, or destructor function, define or `=delete` them all",
    "content": "### <a name=\"rc-five\"></a>C.21: If you define or `=delete` any copy, move, or destructor function, define or `=delete` them all\n\n##### Reason\n\nThe semantics of copy, move, and destruction are closely related, so if one needs to be declared, the odds are that others need consideration too.\n\nDeclaring any copy/move/destructor function,\neven as `=default` or `=delete`, will suppress the implicit declaration\nof a move constructor and move assignment operator.\nDeclaring a move constructor or move assignment operator, even as\n`=default` or `=delete`, will cause an implicitly generated copy constructor\nor implicitly generated copy assignment operator to be defined as deleted.\nSo as soon as any of these are declared, the others should\nall be declared to avoid unwanted effects like turning all potential moves\ninto more expensive copies, or making a class move-only.\n\n##### Example, bad\n\n    struct M2 {   // bad: incomplete set of copy/move/destructor operations\n    public:\n        // ...\n        // ... no copy or move operations ...\n        ~M2() { delete[] rep; }\n    private:\n        pair<int, int>* rep;  // zero-terminated set of pairs\n    };\n\n    void use()\n    {\n        M2 x;\n        M2 y;\n        // ...\n        x = y;   // the default assignment\n        // ...\n    }\n\nGiven that \"special attention\" was needed for the destructor (here, to deallocate), the likelihood that the implicitly-defined copy and move assignment operators will be correct is low (here, we would get double deletion).\n\n##### Note\n\nThis is known as \"the rule of five.\"\n\n##### Note\n\nIf you want a default implementation (while defining another), write `=default` to show you're doing so intentionally for that function.\nIf you don't want a generated default function, suppress it with `=delete`.\n\n##### Example, good\n\nWhen a destructor needs to be declared just to make it `virtual`, it can be\ndefined as defaulted.\n\n    class AbstractBase {\n    public:\n        virtual void foo() = 0;  // at least one abstract method to make the class abstract\n        virtual ~AbstractBase() = default;\n        // ...\n    };\n\nTo prevent slicing as per [C.67](#rc-copy-virtual),\nmake the copy and move operations protected or `=delete`d, and add a `clone`:\n\n    class CloneableBase {\n    public:\n        virtual unique_ptr<CloneableBase> clone() const;\n        virtual ~CloneableBase() = default;\n        CloneableBase() = default;\n        CloneableBase(const CloneableBase&) = delete;\n        CloneableBase& operator=(const CloneableBase&) = delete;\n        CloneableBase(CloneableBase&&) = delete;\n        CloneableBase& operator=(CloneableBase&&) = delete;\n        // ... other constructors and functions ...\n    };\n\nDefining only the move operations or only the copy operations would have the\nsame effect here, but stating the intent explicitly for each special member\nmakes it more obvious to the reader.\n\n##### Note\n\nCompilers enforce much of this rule and ideally warn about any violation.\n\n##### Note\n\nRelying on an implicitly generated copy operation in a class with a destructor is deprecated.\n\n##### Note\n\nWriting these functions can be error-prone.\nNote their argument types:\n\n    class X {\n    public:\n        // ...\n        virtual ~X() = default;               // destructor (virtual if X is meant to be a base class)\n        X(const X&) = default;                // copy constructor\n        X& operator=(const X&) = default;     // copy assignment\n        X(X&&) noexcept = default;            // move constructor\n        X& operator=(X&&) noexcept = default; // move assignment\n    };\n\nA minor mistake (such as a misspelling, leaving out a `const`, using `&` instead of `&&`, or leaving out a special function) can lead to errors or warnings.\nTo avoid the tedium and the possibility of errors, try to follow the [rule of zero](#rc-zero).\n\n##### Enforcement\n\n(Simple) A class should have a declaration (even a `=delete` one) for either all or none of the copy/move/destructor functions.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-matched\"></a>C.22: Make default operations consistent",
    "content": "### <a name=\"rc-matched\"></a>C.22: Make default operations consistent\n\n##### Reason\n\nThe default operations are conceptually a matched set. Their semantics are interrelated.\nUsers will be surprised if copy/move construction and copy/move assignment do logically different things. Users will be surprised if constructors and destructors do not provide a consistent view of resource management. Users will be surprised if copy and move don't reflect the way constructors and destructors work.\n\n##### Example, bad\n\n    class Silly {   // BAD: Inconsistent copy operations\n        class Impl {\n            // ...\n        };\n        shared_ptr<Impl> p;\n    public:\n        Silly(const Silly& a) : p(make_shared<Impl>()) { *p = *a.p; }   // deep copy\n        Silly& operator=(const Silly& a) { p = a.p; return *this; }   // shallow copy\n        // ...\n    };\n\nThese operations disagree about copy semantics. This will lead to confusion and bugs.\n\n##### Enforcement\n\n* (Complex) A copy/move constructor and the corresponding copy/move assignment operator should write to the same data members at the same level of dereference.\n* (Complex) Any data members written in a copy/move constructor should also be initialized by all other constructors.\n* (Complex) If a copy/move constructor performs a deep copy of a data member, then the destructor should modify the data member.\n* (Complex) If a destructor is modifying a data member, that data member should be written in any copy/move constructors or assignment operators.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-dtor\"></a>C.dtor: Destructors",
    "content": "## <a name=\"ss-dtor\"></a>C.dtor: Destructors\n\n\"Does this class need a destructor?\" is a surprisingly insightful design question.\nFor most classes the answer is \"no\" either because the class holds no resources or because destruction is handled by [the rule of zero](#rc-zero);\nthat is, its members can take care of themselves as concerns destruction.\nIf the answer is \"yes\", much of the design of the class follows (see [the rule of five](#rc-five)).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-dtor\"></a>C.30: Define a destructor if a class needs an explicit action at object destruction",
    "content": "### <a name=\"rc-dtor\"></a>C.30: Define a destructor if a class needs an explicit action at object destruction\n\n##### Reason\n\nA destructor is implicitly invoked at the end of an object's lifetime.\nIf the default destructor is sufficient, use it.\nOnly define a non-default destructor if a class needs to execute code that is not already part of its members' destructors.\n\n##### Example\n\n    template<typename A>\n    struct final_action {   // slightly simplified\n        A act;\n        final_action(A a) : act{a} {}\n        ~final_action() { act(); }\n    };\n\n    template<typename A>\n    final_action<A> finally(A act)   // deduce action type\n    {\n        return final_action<A>{act};\n    }\n\n    void test()\n    {\n        auto act = finally([] { cout << \"Exit test\\n\"; });  // establish exit action\n        // ...\n        if (something) return;   // act done here\n        // ...\n    } // act done here\n\nThe whole purpose of `final_action` is to get a piece of code (usually a lambda) executed upon destruction.\n\n##### Note\n\nThere are two general categories of classes that need a user-defined destructor:\n\n* A class with a resource that is not already represented as a class with a destructor, e.g., a `vector` or a transaction class.\n* A class that exists primarily to execute an action upon destruction, such as a tracer or `final_action`.\n\n##### Example, bad\n\n    class Foo {   // bad; use the default destructor\n    public:\n        // ...\n        ~Foo() { s = \"\"; i = 0; vi.clear(); }  // clean up\n    private:\n        string s;\n        int i;\n        vector<int> vi;\n    };\n\nThe default destructor does it better, more efficiently, and can't get it wrong.\n\n##### Enforcement\n\nLook for likely \"implicit resources\", such as pointers and references. Look for classes with destructors even though all their data members have destructors.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-dtor-release\"></a>C.31: All resources acquired by a class must be released by the class's destructor",
    "content": "### <a name=\"rc-dtor-release\"></a>C.31: All resources acquired by a class must be released by the class's destructor\n\n##### Reason\n\nPrevention of resource leaks, especially in error cases.\n\n##### Note\n\nFor resources represented as classes with a complete set of default operations, this happens automatically.\n\n##### Example\n\n    class X {\n        ifstream f;   // might own a file\n        // ... no default operations defined or =deleted ...\n    };\n\n`X`'s `ifstream` implicitly closes any file it might have open upon destruction of its `X`.\n\n##### Example, bad\n\n    class X2 {     // bad\n        FILE* f;   // might own a file\n        // ... no default operations defined or =deleted ...\n    };\n\n`X2` might leak a file handle.\n\n##### Note\n\nWhat about a socket that won't close? A destructor, close, or cleanup operation [should never fail](#rc-dtor-fail).\nIf it does nevertheless, we have a problem that has no really good solution.\nFor starters, the writer of a destructor does not know why the destructor is called and cannot \"refuse to act\" by throwing an exception.\nSee [discussion](#sd-never-fail).\nTo make the problem worse, many \"close/release\" operations are not retryable.\nMany have tried to solve this problem, but no general solution is known.\nIf at all possible, consider failure to close/clean up a fundamental design error and terminate.\n\n##### Note\n\nA class can hold pointers and references to objects that it does not own.\nObviously, such objects should not be `delete`d by the class's destructor.\nFor example:\n\n    Preprocessor pp { /* ... */ };\n    Parser p { pp, /* ... */ };\n    Type_checker tc { p, /* ... */ };\n\nHere `p` refers to `pp` but does not own it.\n\n##### Enforcement\n\n* (Simple) If a class has pointer or reference members that are owners\n  (e.g., deemed owners by using `gsl::owner`), then they should be referenced in its destructor.\n* (Hard) Determine if pointer or reference members are owners when there is no explicit statement of ownership\n  (e.g., look into the constructors).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-dtor-ptr\"></a>C.32: If a class has a raw pointer (`T*`) or reference (`T&`), consider whether it might be owning",
    "content": "### <a name=\"rc-dtor-ptr\"></a>C.32: If a class has a raw pointer (`T*`) or reference (`T&`), consider whether it might be owning\n\n##### Reason\n\nThere is a lot of code that is non-specific about ownership.\n\n##### Example\n\n    class legacy_class\n    {\n        foo* m_owning;   // Bad: change to unique_ptr<T> or owner<T*>\n        bar* m_observer; // OK: keep\n    }\n\nThe only way to determine ownership may be code analysis.\n\n##### Note\n\nOwnership should be clear in new code (and refactored legacy code) according to [R.20](#rr-owner) for owning\npointers and [R.3](#rr-ptr) for non-owning pointers.  References should never own [R.4](#rr-ref).\n\n##### Enforcement\n\nLook at the initialization of raw member pointers and member references and see if an allocation is used.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-dtor-ptr2\"></a>C.33: If a class has an owning pointer member, define a destructor",
    "content": "### <a name=\"rc-dtor-ptr2\"></a>C.33: If a class has an owning pointer member, define a destructor\n\n##### Reason\n\nAn owned object must be `delete`d upon destruction of the object that owns it.\n\n##### Example\n\nA pointer member could represent a resource.\n[A `T*` should not do so](#rr-ptr), but in older code, that's common.\nConsider a `T*` a possible owner and therefore suspect.\n\n    template<typename T>\n    class Smart_ptr {\n        T* p;   // BAD: vague about ownership of *p\n        // ...\n    public:\n        // ... no user-defined default operations ...\n    };\n\n    void use(Smart_ptr<int> p1)\n    {\n        // error: p2.p leaked (if not nullptr and not owned by some other code)\n        auto p2 = p1;\n    }\n\nNote that if you define a destructor, you must define or delete [all default operations](#rc-five):\n\n    template<typename T>\n    class Smart_ptr2 {\n        T* p;   // BAD: vague about ownership of *p\n        // ...\n    public:\n        // ... no user-defined copy operations ...\n        ~Smart_ptr2() { delete p; }  // p is an owner!\n    };\n\n    void use(Smart_ptr2<int> p1)\n    {\n        auto p2 = p1;   // error: double deletion\n    }\n\nThe default copy operation will just copy the `p1.p` into `p2.p` leading to a double destruction of `p1.p`. Be explicit about ownership:\n\n    template<typename T>\n    class Smart_ptr3 {\n        owner<T*> p;   // OK: explicit about ownership of *p\n        // ...\n    public:\n        // ...\n        // ... copy and move operations ...\n        ~Smart_ptr3() { delete p; }\n    };\n\n    void use(Smart_ptr3<int> p1)\n    {\n        auto p2 = p1;   // OK: no double deletion\n    }\n\n##### Note\n\nOften the simplest way to get a destructor is to replace the pointer with a smart pointer (e.g., `std::unique_ptr`) and let the compiler arrange for proper destruction to be done implicitly.\n\n##### Note\n\nWhy not just require all owning pointers to be \"smart pointers\"?\nThat would sometimes require non-trivial code changes and might affect ABIs.\n\n##### Enforcement\n\n* A class with a pointer data member is suspect.\n* A class with an `owner<T>` should define its default operations.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-dtor-virtual\"></a>C.35: A base class destructor should be either public and virtual, or protected and non-virtual",
    "content": "### <a name=\"rc-dtor-virtual\"></a>C.35: A base class destructor should be either public and virtual, or protected and non-virtual\n\n##### Reason\n\nTo prevent undefined behavior.\nIf the destructor is public, then calling code can attempt to destroy a derived class object through a base class pointer, and the result is undefined if the base class's destructor is non-virtual.\nIf the destructor is protected, then calling code cannot destroy through a base class pointer and the destructor does not need to be virtual; it does need to be protected, not private, so that derived destructors can invoke it.\nIn general, the writer of a base class does not know the appropriate action to be done upon destruction.\n\n##### Discussion\n\nSee [this in the Discussion section](#sd-dtor).\n\n##### Example, bad\n\n    struct Base {  // BAD: implicitly has a public non-virtual destructor\n        virtual void f();\n    };\n\n    struct D : Base {\n        string s {\"a resource needing cleanup\"};\n        ~D() { /* ... do some cleanup ... */ }\n        // ...\n    };\n\n    void use()\n    {\n        unique_ptr<Base> p = make_unique<D>();\n        // ...\n    } // p's destruction calls ~Base(), not ~D(), which leaks D::s and possibly more\n\n##### Note\n\nA virtual function defines an interface to derived classes that can be used without looking at the derived classes.\nIf the interface allows destroying, it should be safe to do so.\n\n##### Note\n\nA destructor must be non-private or it will prevent using the type:\n\n    class X {\n        ~X();   // private destructor\n        // ...\n    };\n\n    void use()\n    {\n        X a;                        // error: cannot destroy\n        auto p = make_unique<X>();  // error: cannot destroy\n    }\n\n##### Exception\n\nWe can imagine one case where you could want a protected virtual destructor: When an object of a derived type (and only of such a type) should be allowed to destroy *another* object (not itself) through a pointer to base. We haven't seen such a case in practice, though.\n\n\n##### Enforcement\n\n* A class with any virtual functions should have a destructor that is either public and virtual or else protected and non-virtual.\n* If a class inherits publicly from a base class, the base class should have a destructor that is either public and virtual or else protected and non-virtual.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-dtor-fail\"></a>C.36: A destructor must not fail",
    "content": "### <a name=\"rc-dtor-fail\"></a>C.36: A destructor must not fail\n\n##### Reason\n\nIn general we do not know how to write error-free code if a destructor should fail.\nThe standard library requires that all classes it deals with have destructors that do not exit by throwing.\n\n##### Example\n\n    class X {\n    public:\n        ~X() noexcept;\n        // ...\n    };\n\n    X::~X() noexcept\n    {\n        // ...\n        if (cannot_release_a_resource) terminate();\n        // ...\n    }\n\n##### Note\n\nMany have tried to devise a fool-proof scheme for dealing with failure in destructors.\nNone have succeeded to come up with a general scheme.\nThis can be a real practical problem: For example, what about a socket that won't close?\nThe writer of a destructor does not know why the destructor is called and cannot \"refuse to act\" by throwing an exception.\nSee [discussion](#sd-never-fail).\nTo make the problem worse, many \"close/release\" operations are not retryable.\nIf at all possible, consider failure to close/clean up a fundamental design error and terminate.\n\n##### Note\n\nDeclare a destructor `noexcept`. That will ensure that it either completes normally or terminates the program.\n\n##### Note\n\nIf a resource cannot be released and the program must not fail, try to signal the failure to the rest of the system somehow\n(maybe even by modifying some global state and hope something will notice and be able to take care of the problem).\nBe fully aware that this technique is special-purpose and error-prone.\nConsider the \"my connection will not close\" example.\nProbably there is a problem at the other end of the connection and only a piece of code responsible for both ends of the connection can properly handle the problem.\nThe destructor could send a message (somehow) to the responsible part of the system, consider that to have closed the connection, and return normally.\n\n##### Note\n\nIf a destructor uses operations that could fail, it can catch exceptions and in some cases still complete successfully\n(e.g., by using a different clean-up mechanism from the one that threw an exception).\n\n##### Enforcement\n\n(Simple) A destructor should be declared `noexcept` if it could throw.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-dtor-noexcept\"></a>C.37: Make destructors `noexcept`",
    "content": "### <a name=\"rc-dtor-noexcept\"></a>C.37: Make destructors `noexcept`\n\n##### Reason\n\n [A destructor must not fail](#rc-dtor-fail). If a destructor tries to exit with an exception, it's a bad design error and the program had better terminate.\n\n##### Note\n\nA destructor (either user-defined or compiler-generated) is implicitly declared `noexcept` (independently of what code is in its body) if all of the members of its class have `noexcept` destructors. By explicitly marking destructors `noexcept`, an author guards against the destructor becoming implicitly `noexcept(false)` through the addition or modification of a class member.\n\n##### Example\n\nNot all destructors are noexcept by default; one throwing member poisons the whole class hierarchy\n\n    struct X {\n        Details x;  // happens to have a throwing destructor\n        // ...\n        ~X() { }    // implicitly noexcept(false); aka can throw\n    };\n\nSo, if in doubt, declare a destructor noexcept.\n\n##### Note\n\nWhy not then declare all destructors noexcept?\nBecause that would in many cases -- especially simple cases -- be distracting clutter.\n\n##### Enforcement\n\n(Simple) A destructor should be declared `noexcept` if it could throw.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-ctor\"></a>C.ctor: Constructors",
    "content": "## <a name=\"ss-ctor\"></a>C.ctor: Constructors\n\nA constructor defines how an object is initialized (constructed).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-ctor\"></a>C.40: Define a constructor if a class has an invariant",
    "content": "### <a name=\"rc-ctor\"></a>C.40: Define a constructor if a class has an invariant\n\n##### Reason\n\nThat's what constructors are for.\n\n##### Example\n\n    class Date {  // a Date represents a valid date\n                  // in the January 1, 1900 to December 31, 2100 range\n        Date(int dd, int mm, int yy)\n            :d{dd}, m{mm}, y{yy}\n        {\n            if (!is_valid(d, m, y)) throw Bad_date{};  // enforce invariant\n        }\n        // ...\n    private:\n        int d, m, y;\n    };\n\nIt is often a good idea to express the invariant as an `Ensures` on the constructor.\n\n##### Note\n\nA constructor can be used for convenience even if a class does not have an invariant. For example:\n\n    struct Rec {\n        string s;\n        int i {0};\n        Rec(const string& ss) : s{ss} {}\n        Rec(int ii) :i{ii} {}\n    };\n\n    Rec r1 {7};\n    Rec r2 {\"Foo bar\"};\n\n##### Note\n\nThe C++11 initializer list rule eliminates the need for many constructors. For example:\n\n    struct Rec2{\n        string s;\n        int i;\n        Rec2(const string& ss, int ii = 0) :s{ss}, i{ii} {}   // redundant\n    };\n\n    Rec2 r1 {\"Foo\", 7};\n    Rec2 r2 {\"Bar\"};\n\nThe `Rec2` constructor is redundant.\nAlso, the default for `int` would be better done as a [default member initializer](#rc-in-class-initializer).\n\n**See also**: [construct valid object](#rc-complete) and [constructor throws](#rc-throw).\n\n##### Enforcement\n\n* Flag classes with user-defined copy operations but no constructor (a user-defined copy is a good indicator that the class has an invariant)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-complete\"></a>C.41: A constructor should create a fully initialized object",
    "content": "### <a name=\"rc-complete\"></a>C.41: A constructor should create a fully initialized object\n\n##### Reason\n\nA constructor establishes the invariant for a class. A user of a class should be able to assume that a constructed object is usable.\n\n##### Example, bad\n\n    class X1 {\n        FILE* f;   // call init() before any other function\n        // ...\n    public:\n        X1() {}\n        void init();   // initialize f\n        void read();   // read from f\n        // ...\n    };\n\n    void f()\n    {\n        X1 file;\n        file.read();   // crash or bad read!\n        // ...\n        file.init();   // too late\n        // ...\n    }\n\nCompilers do not read comments.\n\n##### Exception\n\nIf a valid object cannot conveniently be constructed by a constructor, [use a factory function](#rc-factory).\n\n##### Enforcement\n\n* (Simple) Every constructor should initialize every data member (either explicitly, via a delegating ctor call or via default construction).\n* (Unknown) If a constructor has an `Ensures` contract, try to see if it holds as a postcondition.\n\n##### Note\n\nIf a constructor acquires a resource (to create a valid object), that resource should be [released by the destructor](#rc-dtor-release).\nThe idiom of having constructors acquire resources and destructors release them is called [RAII](#rr-raii) (\"Resource Acquisition Is Initialization\").\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-throw\"></a>C.42: If a constructor cannot construct a valid object, throw an exception",
    "content": "### <a name=\"rc-throw\"></a>C.42: If a constructor cannot construct a valid object, throw an exception\n\n##### Reason\n\nLeaving behind an invalid object is asking for trouble.\n\n##### Example\n\n    class X2 {\n        FILE* f;\n        // ...\n    public:\n        X2(const string& name)\n            :f{fopen(name.c_str(), \"r\")}\n        {\n            if (!f) throw runtime_error{\"could not open\" + name};\n            // ...\n        }\n\n        void read();      // read from f\n        // ...\n    };\n\n    void f()\n    {\n        X2 file {\"Zeno\"}; // throws if file isn't open\n        file.read();      // fine\n        // ...\n    }\n\n##### Example, bad\n\n    class X3 {     // bad: the constructor leaves a non-valid object behind\n        FILE* f;   // call is_valid() before any other function\n        bool valid;\n        // ...\n    public:\n        X3(const string& name)\n            :f{fopen(name.c_str(), \"r\")}, valid{false}\n        {\n            if (f) valid = true;\n            // ...\n        }\n\n        bool is_valid() { return valid; }\n        void read();   // read from f\n        // ...\n    };\n\n    void f()\n    {\n        X3 file {\"Heraclides\"};\n        file.read();   // crash or bad read!\n        // ...\n        if (file.is_valid()) {\n            file.read();\n            // ...\n        }\n        else {\n            // ... handle error ...\n        }\n        // ...\n    }\n\n##### Note\n\nFor a variable definition (e.g., on the stack or as a member of another object) there is no explicit function call from which an error code could be returned.\nLeaving behind an invalid object and relying on users to consistently check an `is_valid()` function before use is tedious, error-prone, and inefficient.\n\n##### Exception\n\nThere are domains, such as some hard-real-time systems (think airplane controls) where (without additional tool support) exception handling is not sufficiently predictable from a timing perspective.\nThere the `is_valid()` technique must be used. In such cases, check `is_valid()` consistently and immediately to simulate [RAII](#rr-raii).\n\n##### Alternative\n\nIf you feel tempted to use some \"post-constructor initialization\" or \"two-stage initialization\" idiom, try not to do that.\nIf you really have to, look at [factory functions](#rc-factory).\n\n##### Note\n\nOne reason people have used `init()` functions rather than doing the initialization work in a constructor has been to avoid code replication.\n[Delegating constructors](#rc-delegating) and [default member initialization](#rc-in-class-initializer) do that better.\nAnother reason has been to delay initialization until an object is needed; the solution to that is often [not to declare a variable until it can be properly initialized](#res-init).\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-default0\"></a>C.43: Ensure that a copyable class has a default constructor",
    "content": "### <a name=\"rc-default0\"></a>C.43: Ensure that a copyable class has a default constructor\n\n##### Reason\n\nThat is, ensure that if a concrete class is copyable it also satisfies the rest of \"semiregular.\"\n\nMany language and library facilities rely on default constructors to initialize their elements, e.g. `T a[10]` and `std::vector<T> v(10)`.\nA default constructor often simplifies the task of defining a suitable [moved-from state](#???) for a type that is also copyable.\n\n##### Example\n\n    class Date { // BAD: no default constructor\n    public:\n        Date(int dd, int mm, int yyyy);\n        // ...\n    };\n\n    vector<Date> vd1(1000);   // default Date needed here\n    vector<Date> vd2(1000, Date{7, Month::October, 1885});   // alternative\n\nThe default constructor is only auto-generated if there is no user-declared constructor, hence it's impossible to initialize the vector `vd1` in the example above.\nThe absence of a default value can cause surprises for users and complicate its use, so if one can be reasonably defined, it should be.\n\n`Date` is chosen to encourage thought:\nThere is no \"natural\" default date (the big bang is too far back in time to be useful for most people), so this example is non-trivial.\n`{0, 0, 0}` is not a valid date in most calendar systems, so choosing that would be introducing something like floating-point's `NaN`.\nHowever, most realistic `Date` classes have a \"first date\" (e.g. January 1, 1970 is popular), so making that the default is usually trivial.\n\n    class Date {\n    public:\n        Date(int dd, int mm, int yyyy);\n        Date() = default; // [See also](#rc-default)\n        // ...\n    private:\n        int dd {1};\n        int mm {1};\n        int yyyy {1970};\n        // ...\n    };\n\n    vector<Date> vd1(1000);\n\n##### Note\n\nA class with members that all have default constructors implicitly gets a default constructor:\n\n    struct X {\n        string s;\n        vector<int> v;\n    };\n\n    X x; // means X{ { }, { } }; that is the empty string and the empty vector\n\nBeware that built-in types are not properly default constructed:\n\n    struct X {\n        string s;\n        int i;\n    };\n\n    void f()\n    {\n        X x;    // x.s is initialized to the empty string; x.i is uninitialized\n\n        cout << x.s << ' ' << x.i << '\\n';\n        ++x.i;\n    }\n\nStatically allocated objects of built-in types are by default initialized to `0`, but local built-in variables are not.\nBeware that your compiler might default initialize local built-in variables, whereas an optimized build will not.\nThus, code like the example above might appear to work, but it relies on undefined behavior.\nAssuming that you want initialization, an explicit default initialization can help:\n\n    struct X {\n        string s;\n        int i {};   // default initialize (to 0)\n    };\n\n##### Notes\n\nClasses that don't have a reasonable default construction are usually not copyable either, so they don't fall under this guideline.\n\nFor example, a base class should not be copyable, and so does not necessarily need a default constructor:\n\n    // Shape is an abstract base class, not a copyable type.\n    // It might or might not need a default constructor.\n    struct Shape {\n        virtual void draw() = 0;\n        virtual void rotate(int) = 0;\n        // =delete copy/move functions\n        // ...\n    };\n\nA class that must acquire a caller-provided resource during construction often cannot have a default constructor, but it does not fall under this guideline because such a class is usually not copyable anyway:\n\n    // std::lock_guard is not a copyable type.\n    // It does not have a default constructor.\n    lock_guard g {mx};  // guard the mutex mx\n    lock_guard g2;      // error: guarding nothing\n\nA class that has a \"special state\" that must be handled separately from other states by member functions or users causes extra work\n(and most likely more errors). Such a type can naturally use the special state as a default constructed value, whether or not it is copyable:\n\n    // std::ofstream is not a copyable type.\n    // It does happen to have a default constructor\n    // that goes along with a special \"not open\" state.\n    ofstream out {\"Foobar\"};\n    // ...\n    out << log(time, transaction);\n\nSimilar special-state types that are copyable, such as copyable smart pointers that have the special state \"==nullptr\", should use the special state as their default constructed value.\n\nHowever, it is preferable to have a default constructor default to a meaningful state such as `std::string`s `\"\"` and `std::vector`s `{}`.\n\n##### Enforcement\n\n* Flag classes that are copyable by `=` without a default constructor\n* Flag classes that are comparable with `==` but not copyable\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-default00\"></a>C.44: Prefer default constructors to be simple and non-throwing",
    "content": "### <a name=\"rc-default00\"></a>C.44: Prefer default constructors to be simple and non-throwing\n\n##### Reason\n\nBeing able to set a value to \"the default\" without operations that might fail simplifies error handling and reasoning about move operations.\n\n##### Example, problematic\n\n    template<typename T>\n    // elem points to space-elem element allocated using new\n    class Vector0 {\n    public:\n        Vector0() :Vector0{0} {}\n        Vector0(int n) :elem{new T[n]}, space{elem + n}, last{elem} {}\n        // ...\n    private:\n        own<T*> elem;\n        T* space;\n        T* last;\n    };\n\nThis is nice and general, but setting a `Vector0` to empty after an error involves an allocation, which might fail.\nAlso, having a default `Vector` represented as `{new T[0], 0, 0}` seems wasteful.\nFor example, `Vector0<int> v[100]` costs 100 allocations.\n\n##### Example\n\n    template<typename T>\n    // elem is nullptr or elem points to space-elem element allocated using new\n    class Vector1 {\n    public:\n        // sets the representation to {nullptr, nullptr, nullptr}; doesn't throw\n        Vector1() noexcept {}\n        Vector1(int n) :elem{new T[n]}, space{elem + n}, last{elem} {}\n        // ...\n    private:\n        own<T*> elem {};\n        T* space {};\n        T* last {};\n    };\n\nUsing `{nullptr, nullptr, nullptr}` makes `Vector1{}` cheap, but a special case and implies run-time checks.\nSetting a `Vector1` to empty after detecting an error is trivial.\n\n##### Enforcement\n\n* Flag throwing default constructors\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-default\"></a>C.45: Don't define a default constructor that only initializes data members; use default member initializers instead",
    "content": "### <a name=\"rc-default\"></a>C.45: Don't define a default constructor that only initializes data members; use default member initializers instead\n\n##### Reason\n\nUsing default member initializers lets the compiler generate the function for you. The compiler-generated function can be more efficient.\n\n##### Example, bad\n\n    class X1 { // BAD: doesn't use member initializers\n        string s;\n        int i;\n    public:\n        X1() :s{\"default\"}, i{1} { }\n        // ...\n    };\n\n##### Example\n\n    class X2 {\n        string s {\"default\"};\n        int i {1};\n    public:\n        // use compiler-generated default constructor\n        // ...\n    };\n\n##### Enforcement\n\n(Simple) Flag if a default constructor's explicit member initializer is a constant, and recommend that the constant should be written as a data member initializer instead.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-explicit\"></a>C.46: By default, declare single-argument constructors explicit",
    "content": "### <a name=\"rc-explicit\"></a>C.46: By default, declare single-argument constructors explicit\n\n##### Reason\n\nTo avoid unintended conversions.\n\n##### Example, bad\n\n    class String {\n    public:\n        String(int);   // BAD\n        // ...\n    };\n\n    String s = 10;   // surprise: string of size 10\n\n##### Exception\n\nIf you really want an implicit conversion from the constructor argument type to the class type, don't use `explicit`:\n\n    class Complex {\n    public:\n        Complex(double d);   // OK: we want a conversion from d to {d, 0}\n        // ...\n    };\n\n    Complex z = 10.7;   // unsurprising conversion\n\n**See also**: [Discussion of implicit conversions](#ro-conversion)\n\n##### Note\n\nCopy and move constructors should not be made `explicit` because they do not perform conversions. Explicit copy/move constructors make passing and returning by value difficult.\n\n##### Enforcement\n\n(Simple) Single-argument constructors should be declared `explicit`. Good single argument non-`explicit` constructors are rare in most code bases. Warn for all that are not on a \"positive list\".\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-order\"></a>C.47: Define and initialize data members in the order of member declaration",
    "content": "### <a name=\"rc-order\"></a>C.47: Define and initialize data members in the order of member declaration\n\n##### Reason\n\nTo minimize confusion and errors. That is the order in which the initialization happens (independent of the order of member initializers).\n\n##### Example, bad\n\n    class Foo {\n        int m1;\n        int m2;\n    public:\n        Foo(int x) :m2{x}, m1{++x} { }   // BAD: misleading initializer order\n        // ...\n    };\n\n    Foo x(1); // surprise: x.m1 == x.m2 == 2\n\n##### Enforcement\n\n(Simple) A member initializer list should mention the members in the same order they are declared.\n\n**See also**: [Discussion](#sd-order)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-in-class-initializer\"></a>C.48: Prefer default member initializers to member initializers in constructors for constant initializers",
    "content": "### <a name=\"rc-in-class-initializer\"></a>C.48: Prefer default member initializers to member initializers in constructors for constant initializers\n\n##### Reason\n\nMakes it explicit that the same value is expected to be used in all constructors. Avoids repetition. Avoids maintenance problems. It leads to the shortest and most efficient code.\n\n##### Example, bad\n\n    class X {   // BAD\n        int i;\n        string s;\n        int j;\n    public:\n        X() :i{666}, s{\"qqq\"} { }   // j is uninitialized\n        X(int ii) :i{ii} {}         // s is \"\" and j is uninitialized\n        // ...\n    };\n\nHow would a maintainer know whether `j` was deliberately uninitialized (probably a bad idea anyway) and whether it was intentional to give `s` the default value `\"\"` in one case and `qqq` in another (almost certainly a bug)? The problem with `j` (forgetting to initialize a member) often happens when a new member is added to an existing class.\n\n##### Example\n\n    class X2 {\n        int i {666};\n        string s {\"qqq\"};\n        int j {0};\n    public:\n        X2() = default;        // all members are initialized to their defaults\n        X2(int ii) :i{ii} {}   // s and j initialized to their defaults\n        // ...\n    };\n\n**Alternative**: We can get part of the benefits from default arguments to constructors, and that is not uncommon in older code. However, that is less explicit, causes more arguments to be passed, and is repetitive when there is more than one constructor:\n\n    class X3 {   // BAD: inexplicit, argument passing overhead\n        int i;\n        string s;\n        int j;\n    public:\n        X3(int ii = 666, const string& ss = \"qqq\", int jj = 0)\n            :i{ii}, s{ss}, j{jj} { }   // all members are initialized to their defaults\n        // ...\n    };\n\n##### Enforcement\n\n* (Simple) Every constructor should initialize every data member (either explicitly, via a delegating ctor call or via default construction).\n* (Simple) Default arguments to constructors suggest a default member initializer might be more appropriate.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-initialize\"></a>C.49: Prefer initialization to assignment in constructors",
    "content": "### <a name=\"rc-initialize\"></a>C.49: Prefer initialization to assignment in constructors\n\n##### Reason\n\nAn initialization explicitly states that initialization, rather than assignment, is done and can be more elegant and efficient. Prevents \"use before set\" errors.\n\n##### Example, good\n\n    class A {   // Good\n        string s1;\n    public:\n        A(czstring p) : s1{p} { }    // GOOD: directly construct (and the C-string is explicitly named)\n        // ...\n    };\n\n##### Example, bad\n\n    class B {   // BAD\n        string s1;\n    public:\n        B(const char* p) { s1 = p; }   // BAD: default constructor followed by assignment\n        // ...\n    };\n\n    class C {   // UGLY, aka very bad\n        int* p;\n    public:\n        C() { cout << *p; p = new int{10}; }   // accidental use before initialized\n        // ...\n    };\n\n##### Example, better still\n\nInstead of those `const char*`s we could use C++17 `std::string_view` or `gsl::span<char>`\nas [a more general way to present arguments to a function](#rstr-view):\n\n    class D {   // Good\n        string s1;\n    public:\n        D(string_view v) : s1{v} { }    // GOOD: directly construct\n        // ...\n    };\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-factory\"></a>C.50: Use a factory function if you need \"virtual behavior\" during initialization",
    "content": "### <a name=\"rc-factory\"></a>C.50: Use a factory function if you need \"virtual behavior\" during initialization\n\n##### Reason\n\nIf the state of a base class object must depend on the state of a derived part of the object, we need to use a virtual function (or equivalent) while minimizing the window of opportunity to misuse an imperfectly constructed object.\n\n##### Note\n\nThe return type of the factory should normally be `unique_ptr` by default; if some uses are shared, the caller can `move` the `unique_ptr` into a `shared_ptr`. However, if the factory author knows that all uses of the returned object will be shared uses, return `shared_ptr` and use `make_shared` in the body to save an allocation.\n\n##### Example, bad\n\n    class B {\n    public:\n        B()\n        {\n            /* ... */\n            f(); // BAD: C.82: Don't call virtual functions in constructors and destructors\n            /* ... */\n        }\n\n        virtual void f() = 0;\n    };\n\n##### Example\n\n    class B {\n    protected:\n        class Token {};\n\n    public:\n        explicit B(Token) { /* ... */ }  // create an imperfectly initialized object\n        virtual void f() = 0;\n\n        template<class T>\n        static shared_ptr<T> create()    // interface for creating shared objects\n        {\n            auto p = make_shared<T>(typename T::Token{});\n            p->post_initialize();\n            return p;\n        }\n\n    protected:\n        virtual void post_initialize()   // called right after construction\n            { /* ... */ f(); /* ... */ } // GOOD: virtual dispatch is safe\n    };\n\n    class D : public B {                 // some derived class\n    protected:\n        class Token {};\n\n    public:\n        explicit D(Token) : B{ B::Token{} } {}\n        void f() override { /* ...  */ };\n\n    protected:\n        template<class T>\n        friend shared_ptr<T> B::create();\n    };\n\n    shared_ptr<D> p = D::create<D>();  // creating a D object\n\n`make_shared` requires that the constructor is public. By requiring a protected `Token` the constructor cannot be publicly called anymore, so we avoid an incompletely constructed object escaping into the wild.\nBy providing the factory function `create()`, we make construction (on the free store) convenient.\n\n##### Note\n\nConventional factory functions allocate on the free store, rather than on the stack or in an enclosing object.\n\n**See also**: [Discussion](#sd-factory)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-delegating\"></a>C.51: Use delegating constructors to represent common actions for all constructors of a class",
    "content": "### <a name=\"rc-delegating\"></a>C.51: Use delegating constructors to represent common actions for all constructors of a class\n\n##### Reason\n\nTo avoid repetition and accidental differences.\n\n##### Example, bad\n\n    class Date {   // BAD: repetitive\n        int d;\n        Month m;\n        int y;\n    public:\n        Date(int dd, Month mm, year yy)\n            :d{dd}, m{mm}, y{yy}\n            { if (!valid(d, m, y)) throw Bad_date{}; }\n\n        Date(int dd, Month mm)\n            :d{dd}, m{mm} y{current_year()}\n            { if (!valid(d, m, y)) throw Bad_date{}; }\n        // ...\n    };\n\nThe common action gets tedious to write and might accidentally not be common.\n\n##### Example\n\n    class Date2 {\n        int d;\n        Month m;\n        int y;\n    public:\n        Date2(int dd, Month mm, year yy)\n            :d{dd}, m{mm}, y{yy}\n            { if (!valid(d, m, y)) throw Bad_date{}; }\n\n        Date2(int dd, Month mm)\n            :Date2{dd, mm, current_year()} {}\n        // ...\n    };\n\n**See also**: If the \"repeated action\" is a simple initialization, consider [a default member initializer](#rc-in-class-initializer).\n\n##### Enforcement\n\n(Moderate) Look for similar constructor bodies.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-inheriting\"></a>C.52: Use inheriting constructors to import constructors into a derived class that does not need further explicit initialization",
    "content": "### <a name=\"rc-inheriting\"></a>C.52: Use inheriting constructors to import constructors into a derived class that does not need further explicit initialization\n\n##### Reason\n\nIf you need those constructors for a derived class, re-implementing them is tedious and error-prone.\n\n##### Example\n\n`std::vector` has a lot of tricky constructors, so if I want my own `vector`, I don't want to reimplement them:\n\n    class Rec {\n        // ... data and lots of nice constructors ...\n    };\n\n    class Oper : public Rec {\n        using Rec::Rec;\n        // ... no data members ...\n        // ... lots of nice utility functions ...\n    };\n\n##### Example, bad\n\n    struct Rec2 : public Rec {\n        int x;\n        using Rec::Rec;\n    };\n\n    Rec2 r {\"foo\", 7};\n    int val = r.x;   // uninitialized\n\n##### Enforcement\n\nMake sure that every member of the derived class is initialized.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-copy\"></a>C.copy: Copy and move",
    "content": "## <a name=\"ss-copy\"></a>C.copy: Copy and move\n\nConcrete types should generally be copyable, but interfaces in a class hierarchy should not.\nResource handles might or might not be copyable.\nTypes can be defined to move for logical as well as performance reasons.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-copy-assignment\"></a>C.60: Make copy assignment non-`virtual`, take the parameter by `const&`, and return by non-`const&`",
    "content": "### <a name=\"rc-copy-assignment\"></a>C.60: Make copy assignment non-`virtual`, take the parameter by `const&`, and return by non-`const&`\n\n##### Reason\n\nIt is simple and efficient. If you want to optimize for rvalues, provide an overload that takes an `&&` (see [F.18](#rf-consume)).\n\n##### Example\n\n    class Foo {\n    public:\n        Foo& operator=(const Foo& x)\n        {\n            // GOOD: no need to check for self-assignment (other than performance)\n            auto tmp = x;\n            swap(tmp); // see C.83\n            return *this;\n        }\n        // ...\n    };\n\n    Foo a;\n    Foo b;\n    Foo f();\n\n    a = b;    // assign lvalue: copy\n    a = f();  // assign rvalue: potentially move\n\n##### Note\n\nThe `swap` implementation technique offers the [strong guarantee](#Abrahams01).\n\n##### Example\n\nBut what if you can get significantly better performance by not making a temporary copy? Consider a simple `Vector` intended for a domain where assignment of large, equal-sized `Vector`s is common. In this case, the copy of elements implied by the `swap` implementation technique could cause an order of magnitude increase in cost:\n\n    template<typename T>\n    class Vector {\n    public:\n        Vector& operator=(const Vector&);\n        // ...\n    private:\n        T* elem;\n        int sz;\n    };\n\n    Vector& Vector::operator=(const Vector& a)\n    {\n        if (a.sz > sz) {\n            // ... use the swap technique, it can't be bettered ...\n            return *this;\n        }\n        // ... copy sz elements from *a.elem to elem ...\n        if (a.sz < sz) {\n            // ... destroy the surplus elements in *this and adjust size ...\n        }\n        return *this;\n    }\n\nBy writing directly to the target elements, we will get only [the basic guarantee](#Abrahams01) rather than the strong guarantee offered by the `swap` technique. Beware of [self-assignment](#rc-copy-self).\n\n**Alternatives**: If you think you need a `virtual` assignment operator, and understand why that's deeply problematic, don't call it `operator=`. Make it a named function like `virtual void assign(const Foo&)`.\nSee [copy constructor vs. `clone()`](#rc-copy-virtual).\n\n##### Enforcement\n\n* (Simple) An assignment operator should not be virtual. Here be dragons!\n* (Simple) An assignment operator should return `T&` to enable chaining, not alternatives like `const T&` which interfere with composability and putting objects in containers.\n* (Moderate) An assignment operator should (implicitly or explicitly) invoke all base and member assignment operators.\n  Look at the destructor to determine if the type has pointer semantics or value semantics.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-copy-semantic\"></a>C.61: A copy operation should copy",
    "content": "### <a name=\"rc-copy-semantic\"></a>C.61: A copy operation should copy\n\n##### Reason\n\nThat is the generally assumed semantics. After `x = y`, we should have `x == y`.\nAfter a copy `x` and `y` can be independent objects (value semantics, the way non-pointer built-in types and the standard-library types work) or refer to a shared object (pointer semantics, the way pointers work).\n\n##### Example\n\n    class X {   // OK: value semantics\n    public:\n        X();\n        X(const X&);     // copy X\n        void modify();   // change the value of X\n        // ...\n        ~X() { delete[] p; }\n    private:\n        T* p;\n        int sz;\n    };\n\n    bool operator==(const X& a, const X& b)\n    {\n        return a.sz == b.sz && equal(a.p, a.p + a.sz, b.p, b.p + b.sz);\n    }\n\n    X::X(const X& a)\n        :p{new T[a.sz]}, sz{a.sz}\n    {\n        copy(a.p, a.p + sz, p);\n    }\n\n    X x;\n    X y = x;\n    if (x != y) throw Bad{};\n    x.modify();\n    if (x == y) throw Bad{};   // assume value semantics\n\n##### Example\n\n    class X2 {  // OK: pointer semantics\n    public:\n        X2();\n        X2(const X2&) = default; // shallow copy\n        ~X2() = default;\n        void modify();          // change the pointed-to value\n        // ...\n    private:\n        T* p;\n        int sz;\n    };\n\n    bool operator==(const X2& a, const X2& b)\n    {\n        return a.sz == b.sz && a.p == b.p;\n    }\n\n    X2 x;\n    X2 y = x;\n    if (x != y) throw Bad{};\n    x.modify();\n    if (x != y) throw Bad{};  // assume pointer semantics\n\n##### Note\n\nPrefer value semantics unless you are building a \"smart pointer\". Value semantics is the simplest to reason about and what the standard-library facilities expect.\n\n##### Enforcement\n\n(Not enforceable)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-copy-self\"></a>C.62: Make copy assignment safe for self-assignment",
    "content": "### <a name=\"rc-copy-self\"></a>C.62: Make copy assignment safe for self-assignment\n\n##### Reason\n\nIf `x = x` changes the value of `x`, people will be surprised and bad errors will occur (often including leaks).\n\n##### Example\n\nThe standard-library containers handle self-assignment elegantly and efficiently:\n\n    std::vector<int> v = {3, 1, 4, 1, 5, 9};\n    v = v;\n    // the value of v is still {3, 1, 4, 1, 5, 9}\n\n##### Note\n\nThe default assignment generated from members that handle self-assignment correctly handles self-assignment.\n\n    struct Bar {\n        vector<pair<int, int>> v;\n        map<string, int> m;\n        string s;\n    };\n\n    Bar b;\n    // ...\n    b = b;   // correct and efficient\n\n##### Note\n\nYou can handle self-assignment by explicitly testing for self-assignment, but often it is faster and more elegant to cope without such a test (e.g., [using `swap`](#rc-swap)).\n\n    class Foo {\n        string s;\n        int i;\n    public:\n        Foo& operator=(const Foo& a);\n        // ...\n    };\n\n    Foo& Foo::operator=(const Foo& a)   // OK, but there is a cost\n    {\n        if (this == &a) return *this;\n        s = a.s;\n        i = a.i;\n        return *this;\n    }\n\nThis is obviously safe and apparently efficient.\nHowever, what if we do one self-assignment per million assignments?\nThat's about a million redundant tests (but since the answer is essentially always the same, the computer's branch predictor will guess right essentially every time).\nConsider:\n\n    Foo& Foo::operator=(const Foo& a)   // simpler, and probably much better\n    {\n        s = a.s;\n        i = a.i;\n        return *this;\n    }\n\n`std::string` is safe for self-assignment and so are `int`. All the cost is carried by the (rare) case of self-assignment.\n\n##### Enforcement\n\n(Simple) Assignment operators should not contain the pattern `if (this == &a) return *this;` ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-move-assignment\"></a>C.63: Make move assignment non-`virtual`, take the parameter by `&&`, and return by non-`const&`",
    "content": "### <a name=\"rc-move-assignment\"></a>C.63: Make move assignment non-`virtual`, take the parameter by `&&`, and return by non-`const&`\n\n##### Reason\n\nIt is simple and efficient.\n\n**See**: [The rule for copy-assignment](#rc-copy-assignment).\n\n##### Enforcement\n\nEquivalent to what is done for [copy-assignment](#rc-copy-assignment).\n\n* (Simple) An assignment operator should not be virtual. Here be dragons!\n* (Simple) An assignment operator should return `T&` to enable chaining, not alternatives like `const T&` which interfere with composability and putting objects in containers.\n* (Moderate) A move assignment operator should (implicitly or explicitly) invoke all base and member move assignment operators.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-move-semantic\"></a>C.64: A move operation should move and leave its source in a valid state",
    "content": "### <a name=\"rc-move-semantic\"></a>C.64: A move operation should move and leave its source in a valid state\n\n##### Reason\n\nThat is the generally assumed semantics.\nAfter `y = std::move(x)` the value of `y` should be the value `x` had and `x` should be in a valid state.\n\n##### Example\n\n    class X {   // OK: value semantics\n    public:\n        X();\n        X(X&& a) noexcept;  // move X\n        X& operator=(X&& a) noexcept; // move-assign X\n        void modify();     // change the value of X\n        // ...\n        ~X() { delete[] p; }\n    private:\n        T* p;\n        int sz;\n    };\n\n    X::X(X&& a) noexcept\n        :p{a.p}, sz{a.sz}  // steal representation\n    {\n        a.p = nullptr;     // set to \"empty\"\n        a.sz = 0;\n    }\n\n    void use()\n    {\n        X x{};\n        // ...\n        X y = std::move(x);\n        x = X{};   // OK\n    } // OK: x can be destroyed\n\n##### Note\n\nIdeally, that moved-from should be the default value of the type.\nEnsure that unless there is an exceptionally good reason not to.\nHowever, not all types have a default value and for some types establishing the default value can be expensive.\nThe standard requires only that the moved-from object can be destroyed.\nOften, we can easily and cheaply do better: The standard library assumes that it is possible to assign to a moved-from object.\nAlways leave the moved-from object in some (necessarily specified) valid state.\n\n##### Note\n\nUnless there is an exceptionally strong reason not to, make `x = std::move(y); y = z;` work with the conventional semantics.\n\n##### Enforcement\n\n(Not enforceable) Look for assignments to members in the move operation. If there is a default constructor, compare those assignments to the initializations in the default constructor.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-move-self\"></a>C.65: Make move assignment safe for self-assignment",
    "content": "### <a name=\"rc-move-self\"></a>C.65: Make move assignment safe for self-assignment\n\n##### Reason\n\nIf `x = x` changes the value of `x`, people will be surprised and bad errors can occur. However, people don't usually directly write a self-assignment that turns into a move, but it can occur. However, `std::swap` is implemented using move operations so if you accidentally do `swap(a, b)` where `a` and `b` refer to the same object, failing to handle self-move could be a serious and subtle error.\n\n##### Example\n\n    class Foo {\n        string s;\n        int i;\n    public:\n        Foo& operator=(Foo&& a) noexcept;\n        // ...\n    };\n\n    Foo& Foo::operator=(Foo&& a) noexcept  // OK, but there is a cost\n    {\n        if (this == &a) return *this;  // this line is redundant\n        s = std::move(a.s);\n        i = a.i;\n        return *this;\n    }\n\nThe one-in-a-million argument against `if (this == &a) return *this;` tests from the discussion of [self-assignment](#rc-copy-self) is even more relevant for self-move.\n\n##### Note\n\nThere is no known general way of avoiding an `if (this == &a) return *this;` test for a move assignment and still getting a correct answer (i.e., after `x = x` the value of `x` is unchanged).\n\n##### Note\n\nThe ISO standard guarantees only a \"valid but unspecified\" state for the standard-library containers. Apparently this has not been a problem in about 10 years of experimental and production use. Please contact the editors if you find a counter example. The rule here is more caution and insists on complete safety.\n\n##### Example\n\nHere is a way to move a pointer without a test (imagine it as code in the implementation a move assignment):\n\n    // move from other.ptr to this->ptr\n    T* temp = other.ptr;\n    other.ptr = nullptr;\n    delete ptr; // in self-move, this->ptr is also null; delete is a no-op\n    ptr = temp; // in self-move, the original ptr is restored\n\n##### Enforcement\n\n* (Moderate) In the case of self-assignment, a move assignment operator should not leave the object holding pointer members that have been `delete`d or set to `nullptr`.\n* (Not enforceable) Look at the use of standard-library container types (incl. `string`) and consider them safe for ordinary (not life-critical) uses.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-move-noexcept\"></a>C.66: Make move operations `noexcept`",
    "content": "### <a name=\"rc-move-noexcept\"></a>C.66: Make move operations `noexcept`\n\n##### Reason\n\nA throwing move violates most people's reasonable assumptions.\nA non-throwing move will be used more efficiently by standard-library and language facilities.\n\n##### Example\n\n    template<typename T>\n    class Vector {\n    public:\n        Vector(Vector&& a) noexcept :elem{a.elem}, sz{a.sz} { a.elem = nullptr; a.sz = 0; }\n        Vector& operator=(Vector&& a) noexcept {\n            if (&a != this) {\n                delete elem;\n                elem = a.elem; a.elem = nullptr;\n                sz   = a.sz;   a.sz   = 0;\n            }\n            return *this;\n        }\n        // ...\n    private:\n        T* elem;\n        int sz;\n    };\n\nThese operations do not throw.\n\n##### Example, bad\n\n    template<typename T>\n    class Vector2 {\n    public:\n        Vector2(Vector2&& a) noexcept { *this = a; }             // just use the copy\n        Vector2& operator=(Vector2&& a) noexcept { *this = a; }  // just use the copy\n        // ...\n    private:\n        T* elem;\n        int sz;\n    };\n\nThis `Vector2` is not just inefficient, but since a vector copy requires allocation, it can throw.\n\n##### Enforcement\n\n(Simple) A move operation should be marked `noexcept`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-copy-virtual\"></a>C.67: A polymorphic class should suppress public copy/move",
    "content": "### <a name=\"rc-copy-virtual\"></a>C.67: A polymorphic class should suppress public copy/move\n\n##### Reason\n\nA *polymorphic class* is a class that defines or inherits at least one virtual function. It is likely that it will be used as a base class for other derived classes with polymorphic behavior. If it is accidentally passed by value, with the implicitly generated copy constructor and assignment, we risk slicing: only the base portion of a derived object will be copied, and the polymorphic behavior will be corrupted.\n\nIf the class has no data, `=delete` the copy/move functions. Otherwise, make them protected.\n\n##### Example, bad\n\n    class B { // BAD: polymorphic base class doesn't suppress copying\n    public:\n        virtual char m() { return 'B'; }\n        // ... nothing about copy operations, so uses default ...\n    };\n\n    class D : public B {\n    public:\n        char m() override { return 'D'; }\n        // ...\n    };\n\n    void f(B& b)\n    {\n        auto b2 = b; // oops, slices the object; b2.m() will return 'B'\n    }\n\n    D d;\n    f(d);\n\n##### Example\n\n    class B { // GOOD: polymorphic class suppresses copying\n    public:\n        B() = default;\n        B(const B&) = delete;\n        B& operator=(const B&) = delete;\n        virtual char m() { return 'B'; }\n        // ...\n    };\n\n    class D : public B {\n    public:\n        char m() override { return 'D'; }\n        // ...\n    };\n\n    void f(B& b)\n    {\n        auto b2 = b; // ok, compiler will detect inadvertent copying, and protest\n    }\n\n    D d;\n    f(d);\n\n##### Note\n\nIf you need to create deep copies of polymorphic objects, use `clone()` functions: see [C.130](#rh-copy).\n\n##### Exception\n\nClasses that represent exception objects need both to be polymorphic and copy-constructible.\n\n##### Enforcement\n\n* Flag a polymorphic class with a public copy operation.\n* Flag an assignment of polymorphic class objects.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "C.other: Other default operation rules",
    "content": "## C.other: Other default operation rules\n\nIn addition to the operations for which the language offers default implementations,\nthere are a few operations that are so foundational that specific rules for their definition are needed:\ncomparisons, `swap`, and `hash`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-eqdefault\"></a>C.80: Use `=default` if you have to be explicit about using the default semantics",
    "content": "### <a name=\"rc-eqdefault\"></a>C.80: Use `=default` if you have to be explicit about using the default semantics\n\n##### Reason\n\nThe compiler is more likely to get the default semantics right and you cannot implement these functions better than the compiler.\n\n##### Example\n\n    class Tracer {\n        string message;\n    public:\n        Tracer(const string& m) : message{m} { cerr << \"entering \" << message << '\\n'; }\n        ~Tracer() { cerr << \"exiting \" << message << '\\n'; }\n\n        Tracer(const Tracer&) = default;\n        Tracer& operator=(const Tracer&) = default;\n        Tracer(Tracer&&) noexcept = default;\n        Tracer& operator=(Tracer&&) noexcept = default;\n    };\n\nBecause we defined the destructor, we must define the copy and move operations. The `= default` is the best and simplest way of doing that.\n\n##### Example, bad\n\n    class Tracer2 {\n        string message;\n    public:\n        Tracer2(const string& m) : message{m} { cerr << \"entering \" << message << '\\n'; }\n        ~Tracer2() { cerr << \"exiting \" << message << '\\n'; }\n\n        Tracer2(const Tracer2& a) : message{a.message} {}\n        Tracer2& operator=(const Tracer2& a) { message = a.message; return *this; }\n        Tracer2(Tracer2&& a) noexcept :message{a.message} {}\n        Tracer2& operator=(Tracer2&& a) noexcept { message = a.message; return *this; }\n    };\n\nWriting out the bodies of the copy and move operations is verbose, tedious, and error-prone. A compiler does it better.\n\n##### Enforcement\n\n(Moderate) The body of a user-defined operation should not have the same semantics as the compiler-generated version, because that would be redundant.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-delete\"></a>C.81: Use `=delete` when you want to disable default behavior (without wanting an alternative)",
    "content": "### <a name=\"rc-delete\"></a>C.81: Use `=delete` when you want to disable default behavior (without wanting an alternative)\n\n##### Reason\n\nIn a few cases, a default operation is not desirable.\n\n##### Example\n\n    class Immortal {\n    public:\n        ~Immortal() = delete;   // do not allow destruction\n        // ...\n    };\n\n    void use()\n    {\n        Immortal ugh;   // error: ugh cannot be destroyed\n        Immortal* p = new Immortal{};\n        delete p;       // error: cannot destroy *p\n    }\n\n##### Example\n\nA `unique_ptr` can be moved, but not copied. To achieve that its copy operations are deleted. To avoid copying it is necessary to `=delete` its copy operations from lvalues:\n\n    template<class T, class D = default_delete<T>> class unique_ptr {\n    public:\n        // ...\n        constexpr unique_ptr() noexcept;\n        explicit unique_ptr(pointer p) noexcept;\n        // ...\n        unique_ptr(unique_ptr&& u) noexcept;   // move constructor\n        // ...\n        unique_ptr(const unique_ptr&) = delete; // disable copy from lvalue\n        // ...\n    };\n\n    unique_ptr<int> make();   // make \"something\" and return it by moving\n\n    void f()\n    {\n        unique_ptr<int> pi {};\n        auto pi2 {pi};      // error: no move constructor from lvalue\n        auto pi3 {make()};  // OK, move: the result of make() is an rvalue\n    }\n\nNote that deleted functions should be public.\n\n##### Enforcement\n\nThe elimination of a default operation is (should be) based on the desired semantics of the class. Consider such classes suspect, but maintain a \"positive list\" of classes where a human has asserted that the semantics is correct.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-ctor-virtual\"></a>C.82: Don't call virtual functions in constructors and destructors",
    "content": "### <a name=\"rc-ctor-virtual\"></a>C.82: Don't call virtual functions in constructors and destructors\n\n##### Reason\n\nThe function called will be that of the object constructed so far, rather than a possibly overriding function in a derived class.\nThis can be most confusing.\nWorse, a direct or indirect call to an unimplemented pure virtual function from a constructor or destructor results in undefined behavior.\n\n##### Example, bad\n\n    class Base {\n    public:\n        virtual void f() = 0;   // not implemented\n        virtual void g();       // implemented with Base version\n        virtual void h();       // implemented with Base version\n        virtual ~Base();        // implemented with Base version\n    };\n\n    class Derived : public Base {\n    public:\n        void g() override;   // provide Derived implementation\n        void h() final;      // provide Derived implementation\n\n        Derived()\n        {\n            // BAD: attempt to call an unimplemented virtual function\n            f();\n\n            // BAD: will call Derived::g, not dispatch further virtually\n            g();\n\n            // GOOD: explicitly state intent to call only the visible version\n            Derived::g();\n\n            // ok, no qualification needed, h is final\n            h();\n        }\n    };\n\nNote that calling a specific explicitly qualified function is not a virtual call even if the function is `virtual`.\n\n**See also** [factory functions](#rc-factory) for how to achieve the effect of a call to a derived class function without risking undefined behavior.\n\n##### Note\n\nThere is nothing inherently wrong with calling virtual functions from constructors and destructors.\nThe semantics of such calls is type safe.\nHowever, experience shows that such calls are rarely needed, easily confuse maintainers, and become a source of errors when used by novices.\n\n##### Enforcement\n\n* Flag calls of virtual functions from constructors and destructors.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-swap\"></a>C.83: For value-like types, consider providing a `noexcept` swap function",
    "content": "### <a name=\"rc-swap\"></a>C.83: For value-like types, consider providing a `noexcept` swap function\n\n##### Reason\n\nA `swap` can be handy for implementing a number of idioms, from smoothly moving objects around to implementing assignment easily to providing a guaranteed commit function that enables strongly error-safe calling code. Consider using swap to implement copy assignment in terms of copy construction. See also [destructors, deallocation, and swap must never fail](#re-never-fail).\n\n##### Example, good\n\n    class Foo {\n    public:\n        void swap(Foo& rhs) noexcept\n        {\n            m1.swap(rhs.m1);\n            std::swap(m2, rhs.m2);\n        }\n    private:\n        Bar m1;\n        int m2;\n    };\n\nProviding a non-member `swap` function in the same namespace as your type for callers' convenience.\n\n    void swap(Foo& a, Foo& b)\n    {\n        a.swap(b);\n    }\n\n##### Enforcement\n\n* Non-trivially copyable types should provide a member swap or a free swap overload.\n* (Simple) When a class has a `swap` member function, it should be declared `noexcept`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-swap-fail\"></a>C.84: A `swap` function must not fail",
    "content": "### <a name=\"rc-swap-fail\"></a>C.84: A `swap` function must not fail\n\n##### Reason\n\n `swap` is widely used in ways that are assumed never to fail and programs cannot easily be written to work correctly in the presence of a failing `swap`. The standard-library containers and algorithms will not work correctly if a swap of an element type fails.\n\n##### Example, bad\n\n    void swap(My_vector& x, My_vector& y)\n    {\n        auto tmp = x;   // copy elements\n        x = y;\n        y = tmp;\n    }\n\nThis is not just slow, but if a memory allocation occurs for the elements in `tmp`, this `swap` could throw and would make STL algorithms fail if used with them.\n\n##### Enforcement\n\n(Simple) When a class has a `swap` member function, it should be declared `noexcept`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-swap-noexcept\"></a>C.85: Make `swap` `noexcept`",
    "content": "### <a name=\"rc-swap-noexcept\"></a>C.85: Make `swap` `noexcept`\n\n##### Reason\n\n [A `swap` must not fail](#rc-swap-fail).\nIf a `swap` tries to exit with an exception, it's a bad design error and the program had better terminate.\n\n##### Enforcement\n\n(Simple) When a class has a `swap` member function, it should be declared `noexcept`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-eq\"></a>C.86: Make `==` symmetric with respect to operand types and `noexcept`",
    "content": "### <a name=\"rc-eq\"></a>C.86: Make `==` symmetric with respect to operand types and `noexcept`\n\n##### Reason\n\nAsymmetric treatment of operands is surprising and a source of errors where conversions are possible.\n`==` is a fundamental operation and programmers should be able to use it without fear of failure.\n\n##### Example\n\n    struct X {\n        string name;\n        int number;\n    };\n\n    bool operator==(const X& a, const X& b) noexcept {\n        return a.name == b.name && a.number == b.number;\n    }\n\n##### Example, bad\n\n    class B {\n        string name;\n        int number;\n        bool operator==(const B& a) const {\n            return name == a.name && number == a.number;\n        }\n        // ...\n    };\n\n`B`'s comparison accepts conversions for its second operand, but not its first.\n\n##### Note\n\nIf a class has a failure state, like `double`'s `NaN`, there is a temptation to make a comparison against the failure state throw.\nThe alternative is to make two failure states compare equal and any valid state compare false against the failure state.\n\n##### Note\n\nThis rule applies to all the usual comparison operators: `!=`, `<`, `<=`, `>`, and `>=`.\n\n##### Enforcement\n\n* Flag an `operator==()` for which the argument types differ; same for other comparison operators: `!=`, `<`, `<=`, `>`, and `>=`.\n* Flag member `operator==()`s; same for other comparison operators: `!=`, `<`, `<=`, `>`, and `>=`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-eq-base\"></a>C.87: Beware of `==` on base classes",
    "content": "### <a name=\"rc-eq-base\"></a>C.87: Beware of `==` on base classes\n\n##### Reason\n\nIt is really hard to write a foolproof and useful `==` for a hierarchy.\n\n##### Example, bad\n\n    class B {\n        string name;\n        int number;\n    public:\n        virtual bool operator==(const B& a) const\n        {\n             return name == a.name && number == a.number;\n        }\n        // ...\n    };\n\n`B`'s comparison accepts conversions for its second operand, but not its first.\n\n    class D : public B {\n        char character;\n    public:\n        virtual bool operator==(const D& a) const\n        {\n            return B::operator==(a) && character == a.character;\n        }\n        // ...\n    };\n\n    B b = ...\n    D d = ...\n    b == d;    // compares name and number, ignores d's character\n    d == b;    // compares name and number, ignores d's character\n    D d2;\n    d == d2;   // compares name, number, and character\n    B& b2 = d2;\n    b2 == d;   // compares name and number, ignores d2's and d's character\n\nOf course there are ways of making `==` work in a hierarchy, but the naive approaches do not scale.\n\n##### Note\n\nThis rule applies to all the usual comparison operators: `!=`, `<`, `<=`, `>`, `>=`, and `<=>`.\n\n##### Enforcement\n\n* Flag a virtual `operator==()`; same for other comparison operators: `!=`, `<`, `<=`, `>`, `>=`, and `<=>`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-hash\"></a>C.89: Make a `hash` `noexcept`",
    "content": "### <a name=\"rc-hash\"></a>C.89: Make a `hash` `noexcept`\n\n##### Reason\n\nUsers of hashed containers use hash indirectly and don't expect simple access to throw.\nIt's a standard-library requirement.\n\n##### Example, bad\n\n    template<>\n    struct hash<My_type> {  // thoroughly bad hash specialization\n        using result_type = size_t;\n        using argument_type = My_type;\n\n        size_t operator()(const My_type & x) const\n        {\n            size_t xs = x.s.size();\n            if (xs < 4) throw Bad_My_type{};    // \"Nobody expects the Spanish inquisition!\"\n            return hash<size_t>()(x.s.size()) ^ trim(x.s);\n        }\n    };\n\n    int main()\n    {\n        unordered_map<My_type, int> m;\n        My_type mt{ \"asdfg\" };\n        m[mt] = 7;\n        cout << m[My_type{ \"asdfg\" }] << '\\n';\n    }\n\nIf you have to define a `hash` specialization, try simply to let it combine standard-library `hash` specializations with `^` (xor).\nThat tends to work better than \"cleverness\" for non-specialists.\n\n##### Enforcement\n\n* Flag throwing `hash`es.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rc-memset\"></a>C.90: Rely on constructors and assignment operators, not `memset` and `memcpy`",
    "content": "### <a name=\"rc-memset\"></a>C.90: Rely on constructors and assignment operators, not `memset` and `memcpy`\n\n##### Reason\n\nThe standard C++ mechanism to construct an instance of a type is to call its constructor. As specified in guideline [C.41](#rc-complete): a constructor should create a fully initialized object. No additional initialization, such as by `memcpy`, should be required.\nA type will provide a copy constructor and/or copy assignment operator to appropriately make a copy of the class, preserving the type's invariants.  Using memcpy to copy a non-trivially copyable type has undefined behavior.  Frequently this results in slicing, or data corruption.\n\n##### Example, good\n\n    struct base {\n        virtual void update() = 0;\n        std::shared_ptr<int> sp;\n    };\n\n    struct derived : public base {\n        void update() override {}\n    };\n\n##### Example, bad\n\n    void init(derived& a)\n    {\n        memset(&a, 0, sizeof(derived));\n    }\n\nThis is type-unsafe and overwrites the vtable.\n\n##### Example, bad\n\n    void copy(derived& a, derived& b)\n    {\n        memcpy(&a, &b, sizeof(derived));\n    }\n\nThis is also type-unsafe and overwrites the vtable.\n\n##### Enforcement\n\n* Flag passing a non-trivially-copyable type to `memset` or `memcpy`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-containers\"></a>C.con: Containers and other resource handles",
    "content": "## <a name=\"ss-containers\"></a>C.con: Containers and other resource handles\n\nA container is an object holding a sequence of objects of some type; `std::vector` is the archetypical container.\nA resource handle is a class that owns a resource; `std::vector` is the typical resource handle; its resource is its sequence of elements.\n\nSummary of container rules:\n\n* [C.100: Follow the STL when defining a container](#rcon-stl)\n* [C.101: Give a container value semantics](#rcon-val)\n* [C.102: Give a container move operations](#rcon-move)\n* [C.103: Give a container an initializer list constructor](#rcon-init)\n* [C.104: Give a container a default constructor that sets it to empty](#rcon-empty)\n* ???\n* [C.109: If a resource handle has pointer semantics, provide `*` and `->`](#rcon-ptr)\n\n**See also**: [Resources](#s-resource)\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rcon-stl\"></a>C.100: Follow the STL when defining a container",
    "content": "### <a name=\"rcon-stl\"></a>C.100: Follow the STL when defining a container\n\n##### Reason\n\nThe STL containers are familiar to most C++ programmers and a fundamentally sound design.\n\n##### Note\n\nThere are of course other fundamentally sound design styles and sometimes reasons to depart from\nthe style of the standard library, but in the absence of a solid reason to differ, it is simpler\nand easier for both implementers and users to follow the standard.\n\nIn particular, `std::vector` and `std::map` provide useful relatively simple models.\n\n##### Example\n\n    // simplified (e.g., no allocators):\n\n    template<typename T>\n    class Sorted_vector {\n        using value_type = T;\n        // ... iterator types ...\n\n        Sorted_vector() = default;\n        Sorted_vector(initializer_list<T>);    // initializer-list constructor: sort and store\n        Sorted_vector(const Sorted_vector&) = default;\n        Sorted_vector(Sorted_vector&&) noexcept = default;\n        Sorted_vector& operator=(const Sorted_vector&) = default;     // copy assignment\n        Sorted_vector& operator=(Sorted_vector&&) noexcept = default; // move assignment\n        ~Sorted_vector() = default;\n\n        Sorted_vector(const std::vector<T>& v);   // store and sort\n        Sorted_vector(std::vector<T>&& v);        // sort and \"steal representation\"\n\n        const T& operator[](int i) const { return rep[i]; }\n        // no non-const direct access to preserve order\n\n        void push_back(const T&);   // insert in the right place (not necessarily at back)\n        void push_back(T&&);        // insert in the right place (not necessarily at back)\n\n        // ... cbegin(), cend() ...\n    private:\n        std::vector<T> rep;  // use a std::vector to hold elements\n    };\n\n    template<typename T> bool operator==(const Sorted_vector<T>&, const Sorted_vector<T>&);\n    template<typename T> bool operator!=(const Sorted_vector<T>&, const Sorted_vector<T>&);\n    // ...\n\nHere, the STL style is followed, but incompletely.\nThat's not uncommon.\nProvide only as much functionality as makes sense for a specific container.\nThe key is to define the conventional constructors, assignments, destructors, and iterators\n(as meaningful for the specific container) with their conventional semantics.\nFrom that base, the container can be expanded as needed.\nHere, special constructors from `std::vector` were added.\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rcon-val\"></a>C.101: Give a container value semantics",
    "content": "### <a name=\"rcon-val\"></a>C.101: Give a container value semantics\n\n##### Reason\n\nRegular objects are simpler to think and reason about than irregular ones.\nFamiliarity.\n\n##### Note\n\nIf meaningful, make a container `Regular` (the concept).\nIn particular, ensure that an object compares equal to its copy.\n\n##### Example\n\n    void f(const Sorted_vector<string>& v)\n    {\n        Sorted_vector<string> v2 {v};\n        if (v != v2)\n            cout << \"Behavior against reason and logic.\\n\";\n        // ...\n    }\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rcon-move\"></a>C.102: Give a container move operations",
    "content": "### <a name=\"rcon-move\"></a>C.102: Give a container move operations\n\n##### Reason\n\nContainers tend to get large; without a move constructor and a copy constructor an object can be\nexpensive to move around, thus tempting people to pass pointers to it around and getting into\nresource management problems.\n\n##### Example\n\n    Sorted_vector<int> read_sorted(istream& is)\n    {\n        vector<int> v;\n        cin >> v;   // assume we have a read operation for vectors\n        Sorted_vector<int> sv = v;  // sorts\n        return sv;\n    }\n\nA user can reasonably assume that returning a standard-like container is cheap.\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rcon-init\"></a>C.103: Give a container an initializer list constructor",
    "content": "### <a name=\"rcon-init\"></a>C.103: Give a container an initializer list constructor\n\n##### Reason\n\nPeople expect to be able to initialize a container with a set of values.\nFamiliarity.\n\n##### Example\n\n    Sorted_vector<int> sv {1, 3, -1, 7, 0, 0}; // Sorted_vector sorts elements as needed\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rcon-empty\"></a>C.104: Give a container a default constructor that sets it to empty",
    "content": "### <a name=\"rcon-empty\"></a>C.104: Give a container a default constructor that sets it to empty\n\n##### Reason\n\nTo make it `Regular`.\n\n##### Example\n\n    vector<Sorted_sequence<string>> vs(100);    // 100 Sorted_sequences each with the value \"\"\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rcon-ptr\"></a>C.109: If a resource handle has pointer semantics, provide `*` and `->`",
    "content": "### <a name=\"rcon-ptr\"></a>C.109: If a resource handle has pointer semantics, provide `*` and `->`\n\n##### Reason\n\nThat's what is expected from pointers.\nFamiliarity.\n\n##### Example\n\n    ???\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-lambdas\"></a>C.lambdas: Function objects and lambdas",
    "content": "## <a name=\"ss-lambdas\"></a>C.lambdas: Function objects and lambdas\n\nA function object is an object supplying an overloaded `()` so that you can call it.\nA lambda expression (colloquially often shortened to \"a lambda\") is a notation for generating a function object.\nFunction objects should be cheap to copy (and therefore [passed by value](#rf-in)).\n\nSummary:\n\n* [F.10: If an operation can be reused, give it a name](#rf-name)\n* [F.11: Use an unnamed lambda if you need a simple function object in one place only](#rf-lambda)\n* [F.50: Use a lambda when a function won't do (to capture local variables, or to write a local function)](#rf-capture-vs-overload)\n* [F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms](#rf-reference-capture)\n* [F.53: Avoid capturing by reference in lambdas that will be used non-locally, including returned, stored on the heap, or passed to another thread](#rf-value-capture)\n* [ES.28: Use lambdas for complex initialization, especially of `const` variables](#res-lambda-init)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-hier\"></a>C.hier: Class hierarchies (OOP)",
    "content": "## <a name=\"ss-hier\"></a>C.hier: Class hierarchies (OOP)\n\nA class hierarchy is constructed to represent a set of hierarchically organized concepts (only).\nTypically base classes act as interfaces.\nThere are two major uses for hierarchies, often named implementation inheritance and interface inheritance.\n\nClass hierarchy rule summary:\n\n* [C.120: Use class hierarchies to represent concepts with inherent hierarchical structure (only)](#rh-domain)\n* [C.121: If a base class is used as an interface, make it a pure abstract class](#rh-abstract)\n* [C.122: Use abstract classes as interfaces when complete separation of interface and implementation is needed](#rh-separation)\n\nDesigning rules for classes in a hierarchy summary:\n\n* [C.126: An abstract class typically doesn't need a user-written constructor](#rh-abstract-ctor)\n* [C.127: A class with a virtual function should have a virtual or protected destructor](#rh-dtor)\n* [C.128: Virtual functions should specify exactly one of `virtual`, `override`, or `final`](#rh-override)\n* [C.129: When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance](#rh-kind)\n* [C.130: For making deep copies of polymorphic classes prefer a virtual `clone` function instead of public copy construction/assignment](#rh-copy)\n* [C.131: Avoid trivial getters and setters](#rh-get)\n* [C.132: Don't make a function `virtual` without reason](#rh-virtual)\n* [C.133: Avoid `protected` data](#rh-protected)\n* [C.134: Ensure all non-`const` data members have the same access level](#rh-public)\n* [C.135: Use multiple inheritance to represent multiple distinct interfaces](#rh-mi-interface)\n* [C.136: Use multiple inheritance to represent the union of implementation attributes](#rh-mi-implementation)\n* [C.137: Use `virtual` bases to avoid overly general base classes](#rh-vbase)\n* [C.138: Create an overload set for a derived class and its bases with `using`](#rh-using)\n* [C.139: Use `final` on classes sparingly](#rh-final)\n* [C.140: Do not provide different default arguments for a virtual function and an overrider](#rh-virtual-default-arg)\n\nAccessing objects in a hierarchy rule summary:\n\n* [C.145: Access polymorphic objects through pointers and references](#rh-poly)\n* [C.146: Use `dynamic_cast` where class hierarchy navigation is unavoidable](#rh-dynamic_cast)\n* [C.147: Use `dynamic_cast` to a reference type when failure to find the required class is considered an error](#rh-ref-cast)\n* [C.148: Use `dynamic_cast` to a pointer type when failure to find the required class is considered a valid alternative](#rh-ptr-cast)\n* [C.149: Use `unique_ptr` or `shared_ptr` to avoid forgetting to `delete` objects created using `new`](#rh-smart)\n* [C.150: Use `make_unique()` to construct objects owned by `unique_ptr`s](#rh-make_unique)\n* [C.151: Use `make_shared()` to construct objects owned by `shared_ptr`s](#rh-make_shared)\n* [C.152: Never assign a pointer to an array of derived class objects to a pointer to its base](#rh-array)\n* [C.153: Prefer virtual function to casting](#rh-use-virtual)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-domain\"></a>C.120: Use class hierarchies to represent concepts with inherent hierarchical structure (only)",
    "content": "### <a name=\"rh-domain\"></a>C.120: Use class hierarchies to represent concepts with inherent hierarchical structure (only)\n\n##### Reason\n\nDirect representation of ideas in code eases comprehension and maintenance. Make sure the idea represented in the base class exactly matches all derived types and there is not a better way to express it than using the tight coupling of inheritance.\n\nDo *not* use inheritance when simply having a data member will do. Usually this means that the derived type needs to override a base virtual function or needs access to a protected member.\n\n##### Example\n\n    class DrawableUIElement {\n    public:\n        virtual void render() const = 0;\n        // ...\n    };\n\n    class AbstractButton : public DrawableUIElement {\n    public:\n        virtual void onClick() = 0;\n        // ...\n    };\n\n    class PushButton : public AbstractButton {\n        void render() const override;\n        void onClick() override;\n        // ...\n    };\n\n    class Checkbox : public AbstractButton {\n    // ...\n    };\n\n##### Example, bad\n\nDo *not* represent non-hierarchical domain concepts as class hierarchies.\n\n    template<typename T>\n    class Container {\n    public:\n        // list operations:\n        virtual T& get() = 0;\n        virtual void put(T&) = 0;\n        virtual void insert(Position) = 0;\n        // ...\n        // vector operations:\n        virtual T& operator[](int) = 0;\n        virtual void sort() = 0;\n        // ...\n        // tree operations:\n        virtual void balance() = 0;\n        // ...\n    };\n\nHere most overriding classes cannot implement most of the functions required in the interface well.\nThus the base class becomes an implementation burden.\nFurthermore, the user of `Container` cannot rely on the member functions actually performing meaningful operations reasonably efficiently;\nit might throw an exception instead.\nThus users have to resort to run-time checking and/or\nnot using this (over)general interface in favor of a particular interface found by a run-time type inquiry (e.g., a `dynamic_cast`).\n\n##### Enforcement\n\n* Look for classes with lots of members that do nothing but throw.\n* Flag every use of a non-public base class `B` where the derived class `D` does not override a virtual function or access a protected member in `B`, and `B` is not one of the following: empty, a template parameter or parameter pack of `D`, a class template specialized with `D`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-abstract\"></a>C.121: If a base class is used as an interface, make it a pure abstract class",
    "content": "### <a name=\"rh-abstract\"></a>C.121: If a base class is used as an interface, make it a pure abstract class\n\n##### Reason\n\nA class is more stable (less brittle) if it does not contain data.\nInterfaces should normally be composed entirely of public pure virtual functions and a default/empty virtual destructor.\n\n##### Example\n\n    class My_interface {\n    public:\n        // ... only pure virtual functions here ...\n        virtual ~My_interface() {}   // or =default\n    };\n\n##### Example, bad\n\n    class Goof {\n    public:\n        // ... only pure virtual functions here ...\n        // no virtual destructor\n    };\n\n    class Derived : public Goof {\n        string s;\n        // ...\n    };\n\n    void use()\n    {\n        unique_ptr<Goof> p {new Derived{\"here we go\"}};\n        f(p.get()); // use Derived through the Goof interface\n        g(p.get()); // use Derived through the Goof interface\n    } // leak\n\nThe `Derived` is `delete`d through its `Goof` interface, so its `string` is leaked.\nGive `Goof` a virtual destructor and all is well.\n\n\n##### Enforcement\n\n* Warn on any class that contains data members and also has an overridable (non-`final`) virtual function that wasn't inherited from a base class.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-separation\"></a>C.122: Use abstract classes as interfaces when complete separation of interface and implementation is needed",
    "content": "### <a name=\"rh-separation\"></a>C.122: Use abstract classes as interfaces when complete separation of interface and implementation is needed\n\n##### Reason\n\nSuch as on an ABI (link) boundary.\n\n##### Example\n\n    struct Device {\n        virtual ~Device() = default;\n        virtual void write(span<const char> outbuf) = 0;\n        virtual void read(span<char> inbuf) = 0;\n    };\n\n    class D1 : public Device {\n        // ... data ...\n\n        void write(span<const char> outbuf) override;\n        void read(span<char> inbuf) override;\n    };\n\n    class D2 : public Device {\n        // ... different data ...\n\n        void write(span<const char> outbuf) override;\n        void read(span<char> inbuf) override;\n    };\n\nA user can now use `D1`s and `D2`s interchangeably through the interface provided by `Device`.\nFurthermore, we can update `D1` and `D2` in ways that are not binary compatible with older versions as long as all access goes through `Device`.\n\n##### Enforcement\n\n    ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "C.hierclass: Designing classes in a hierarchy:",
    "content": "## C.hierclass: Designing classes in a hierarchy:\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-abstract-ctor\"></a>C.126: An abstract class typically doesn't need a user-written constructor",
    "content": "### <a name=\"rh-abstract-ctor\"></a>C.126: An abstract class typically doesn't need a user-written constructor\n\n##### Reason\n\nAn abstract class typically does not have any data for a constructor to initialize.\n\n##### Example\n\n    class Shape {\n    public:\n        // no user-written constructor needed in abstract base class\n        virtual Point center() const = 0;    // pure virtual\n        virtual void move(Point to) = 0;\n        // ... more pure virtual functions ...\n        virtual ~Shape() {}                 // destructor\n    };\n\n    class Circle : public Shape {\n    public:\n        Circle(Point p, int rad);           // constructor in derived class\n        Point center() const override { return x; }\n    };\n\n##### Exception\n\n* A base class constructor that does work, such as registering an object somewhere, might need a constructor.\n* In extremely rare cases, you might find it reasonable for an abstract class to have a bit of data shared by all derived classes\n  (e.g., use statistics data, debug information, etc.); such classes tend to have constructors. But be warned: Such classes also tend to be prone to requiring virtual inheritance.\n\n##### Enforcement\n\nFlag abstract classes with constructors.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-dtor\"></a>C.127: A class with a virtual function should have a virtual or protected destructor",
    "content": "### <a name=\"rh-dtor\"></a>C.127: A class with a virtual function should have a virtual or protected destructor\n\n##### Reason\n\nA class with a virtual function is usually (and in general) used via a pointer to base. Usually, the last user has to call delete on a pointer to base, often via a smart pointer to base, so the destructor should be public and virtual. Less commonly, if deletion through a pointer to base is not intended to be supported, the destructor should be protected and non-virtual; see [C.35](#rc-dtor-virtual).\n\n##### Example, bad\n\n    struct B {\n        virtual int f() = 0;\n        // ... no user-written destructor, defaults to public non-virtual ...\n    };\n\n    // bad: derived from a class without a virtual destructor\n    struct D : B {\n        string s {\"default\"};\n        // ...\n    };\n\n    void use()\n    {\n        unique_ptr<B> p = make_unique<D>();\n        // ...\n    } // undefined behavior, might call B::~B only and leak the string\n\n##### Note\n\nThere are people who don't follow this rule because they plan to use a class only through a `shared_ptr`: `std::shared_ptr<B> p = std::make_shared<D>(args);` Here, the shared pointer will take care of deletion, so no leak will occur from an inappropriate `delete` of the base. People who do this consistently can get a false positive, but the rule is important -- what if one was allocated using `make_unique`? It's not safe unless the author of `B` ensures that it can never be misused, such as by making all constructors private and providing a factory function to enforce the allocation with `make_shared`.\n\n##### Enforcement\n\n* A class with any virtual functions should have a destructor that is either public and virtual or else protected and non-virtual.\n* Flag `delete` of a class with a virtual function but no virtual destructor.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-override\"></a>C.128: Virtual functions should specify exactly one of `virtual`, `override`, or `final`",
    "content": "### <a name=\"rh-override\"></a>C.128: Virtual functions should specify exactly one of `virtual`, `override`, or `final`\n\n##### Reason\n\nReadability.\nDetection of mistakes.\nWriting explicit `virtual`, `override`, or `final` is self-documenting and enables the compiler to catch mismatch of types and/or names between base and derived classes. However, writing more than one of these three is both redundant and a potential source of errors.\n\nIt's simple and clear:\n\n* `virtual` means exactly and only \"this is a new virtual function.\"\n* `override` means exactly and only \"this is a non-final overrider.\"\n* `final` means exactly and only \"this is a final overrider.\"\n\n##### Example, bad\n\n    struct B {\n        void f1(int);\n        virtual void f2(int) const;\n        virtual void f3(int);\n        // ...\n    };\n\n    struct D : B {\n        void f1(int);        // bad (hope for a warning): D::f1() hides B::f1()\n        void f2(int) const;  // bad (but conventional and valid): no explicit override\n        void f3(double);     // bad (hope for a warning): D::f3() hides B::f3()\n        // ...\n    };\n\n##### Example, good\n\n    struct Better : B {\n        void f1(int) override;        // error (caught): Better::f1() hides B::f1()\n        void f2(int) const override;\n        void f3(double) override;     // error (caught): Better::f3() hides B::f3()\n        // ...\n    };\n\n#### Discussion\n\nWe want to eliminate two particular classes of errors:\n\n* **implicit virtual**: the programmer intended the function to be implicitly virtual and it is (but readers of the code can't tell); or the programmer intended the function to be implicitly virtual but it isn't (e.g., because of a subtle parameter list mismatch); or the programmer did not intend the function to be virtual but it is (because it happens to have the same signature as a virtual in the base class)\n* **implicit override**: the programmer intended the function to be implicitly an overrider and it is (but readers of the code can't tell); or the programmer intended the function to be implicitly an overrider but it isn't (e.g., because of a subtle parameter list mismatch); or the programmer did not intend the function to be an overrider but it is (because it happens to have the same signature as a virtual in the base class -- note this problem arises whether or not the function is explicitly declared virtual, because the programmer might have intended to create either a new virtual function or a new non-virtual function)\n\nNote: On a class defined as `final`, each individual virtual function should use either `override` or `final`; there is no semantic difference in this case.\n\nNote: Use `final` on functions sparingly. It does not necessarily lead to optimization, and it precludes further overriding.\n\n##### Enforcement\n\n* Compare virtual function names in base and derived classes and flag uses of the same name that do not override.\n* Flag overrides with neither `override` nor `final`.\n* Flag function declarations that use more than one of `virtual`, `override`, and `final`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-kind\"></a>C.129: When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance",
    "content": "### <a name=\"rh-kind\"></a>C.129: When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance\n\n##### Reason\n\nImplementation details in an interface make the interface brittle;\nthat is, make its users vulnerable to having to recompile after changes in the implementation.\nData in a base class increases the complexity of implementing the base and can lead to replication of code.\n\n##### Note\n\nDefinition:\n\n* interface inheritance is the use of inheritance to separate users from implementations,\nin particular to allow derived classes to be added and changed without affecting the users of base classes.\n* implementation inheritance is the use of inheritance to simplify implementation of new facilities\nby making useful operations available for implementers of related new operations (sometimes called \"programming by difference\").\n\nA pure interface class is simply a set of pure virtual functions; see [I.25](#ri-abstract).\n\nIn early OOP (e.g., in the 1980s and 1990s), implementation inheritance and interface inheritance were often mixed\nand bad habits die hard.\nEven now, mixtures are not uncommon in old code bases and in old-style teaching material.\n\nThe importance of keeping the two kinds of inheritance increases\n\n* with the size of a hierarchy (e.g., dozens of derived classes),\n* with the length of time the hierarchy is used (e.g., decades), and\n* with the number of distinct organizations in which a hierarchy is used\n(e.g., it can be difficult to distribute an update to a base class)\n\n\n##### Example, bad\n\n    class Shape {   // BAD, mixed interface and implementation\n    public:\n        Shape();\n        Shape(Point ce = {0, 0}, Color co = none): cent{ce}, col {co} { /* ... */}\n\n        Point center() const { return cent; }\n        Color color() const { return col; }\n\n        virtual void rotate(int) = 0;\n        virtual void move(Point p) { cent = p; redraw(); }\n\n        virtual void redraw();\n\n        // ...\n    private:\n        Point cent;\n        Color col;\n    };\n\n    class Circle : public Shape {\n    public:\n        Circle(Point c, int r) : Shape{c}, rad{r} { /* ... */ }\n\n        // ...\n    private:\n        int rad;\n    };\n\n    class Triangle : public Shape {\n    public:\n        Triangle(Point p1, Point p2, Point p3); // calculate center\n        // ...\n    };\n\nProblems:\n\n* As the hierarchy grows and more data is added to `Shape`, the constructors get harder to write and maintain.\n* Why calculate the center for the `Triangle`? We might never use it.\n* Add a data member to `Shape` (e.g., drawing style or canvas)\nand all classes derived from `Shape` and all code using `Shape` will need to be reviewed, possibly changed, and probably recompiled.\n\nThe implementation of `Shape::move()` is an example of implementation inheritance:\nwe have defined `move()` once and for all, for all derived classes.\nThe more code there is in such base class member function implementations and the more data is shared by placing it in the base,\nthe more benefits we gain - and the less stable the hierarchy is.\n\n##### Example\n\nThis Shape hierarchy can be rewritten using interface inheritance:\n\n    class Shape {  // pure interface\n    public:\n        virtual Point center() const = 0;\n        virtual Color color() const = 0;\n\n        virtual void rotate(int) = 0;\n        virtual void move(Point p) = 0;\n\n        virtual void redraw() = 0;\n\n        // ...\n    };\n\nNote that a pure interface rarely has constructors: there is nothing to construct.\n\n    class Circle : public Shape {\n    public:\n        Circle(Point c, int r, Color c) : cent{c}, rad{r}, col{c} { /* ... */ }\n\n        Point center() const override { return cent; }\n        Color color() const override { return col; }\n\n        // ...\n    private:\n        Point cent;\n        int rad;\n        Color col;\n    };\n\nThe interface is now less brittle, but there is more work in implementing the member functions.\nFor example, `center` has to be implemented by every class derived from `Shape`.\n\n##### Example, dual hierarchy\n\nHow can we gain the benefit of stable hierarchies from interface hierarchies and the benefit of implementation reuse from implementation inheritance?\nOne popular technique is dual hierarchies.\nThere are many ways of implementing the idea of dual hierarchies; here, we use a multiple-inheritance variant.\n\nFirst we devise a hierarchy of interface classes:\n\n    class Shape {   // pure interface\n    public:\n        virtual Point center() const = 0;\n        virtual Color color() const = 0;\n\n        virtual void rotate(int) = 0;\n        virtual void move(Point p) = 0;\n\n        virtual void redraw() = 0;\n\n        // ...\n    };\n\n    class Circle : public virtual Shape {   // pure interface\n    public:\n        virtual int radius() = 0;\n        // ...\n    };\n\nTo make this interface useful, we must provide its implementation classes (here, named equivalently, but in the `Impl` namespace):\n\n    class Impl::Shape : public virtual ::Shape { // implementation\n    public:\n        // constructors, destructor\n        // ...\n        Point center() const override { /* ... */ }\n        Color color() const override { /* ... */ }\n\n        void rotate(int) override { /* ... */ }\n        void move(Point p) override { /* ... */ }\n\n        void redraw() override { /* ... */ }\n\n        // ...\n    };\n\nNow `Shape` is a poor example of a class with an implementation,\nbut bear with us because this is just a simple example of a technique aimed at more complex hierarchies.\n\n    class Impl::Circle : public virtual ::Circle, public Impl::Shape {   // implementation\n    public:\n        // constructors, destructor\n\n        int radius() override { /* ... */ }\n        // ...\n    };\n\nAnd we could extend the hierarchies by adding a Smiley class (:-)):\n\n    class Smiley : public virtual Circle { // pure interface\n    public:\n        // ...\n    };\n\n    class Impl::Smiley : public virtual ::Smiley, public Impl::Circle {   // implementation\n    public:\n        // constructors, destructor\n        // ...\n    }\n\nThere are now two hierarchies:\n\n* interface: Smiley -> Circle -> Shape\n* implementation: Impl::Smiley -> Impl::Circle -> Impl::Shape\n\nSince each implementation is derived from its interface as well as its implementation base class we get a lattice (DAG):\n\n    Smiley     ->         Circle     ->  Shape\n      ^                     ^               ^\n      |                     |               |\n    Impl::Smiley -> Impl::Circle -> Impl::Shape\n\nAs mentioned, this is just one way to construct a dual hierarchy.\n\nThe implementation hierarchy can be used directly, rather than through the abstract interface.\n\n    void work_with_shape(Shape&);\n\n    int user()\n    {\n        Impl::Smiley my_smiley{ /* args */ };   // create concrete shape\n        // ...\n        my_smiley.some_member();        // use implementation class directly\n        // ...\n        work_with_shape(my_smiley);     // use implementation through abstract interface\n        // ...\n    }\n\nThis can be useful when the implementation class has members that are not offered in the abstract interface\nor if direct use of a member offers optimization opportunities (e.g., if an implementation member function is `final`).\n\n##### Note\n\nAnother (related) technique for separating interface and implementation is [Pimpl](#ri-pimpl).\n\n##### Note\n\nThere is often a choice between offering common functionality as (implemented) base class functions and freestanding functions\n(in an implementation namespace).\nBase classes give a shorter notation and easier access to shared data (in the base)\nat the cost of the functionality being available only to users of the hierarchy.\n\n##### Enforcement\n\n* Flag a derived to base conversion to a base with both data and virtual functions\n(except for calls from a derived class member to a base class member)\n* ???\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-copy\"></a>C.130: For making deep copies of polymorphic classes prefer a virtual `clone` function instead of public copy construction/assignment",
    "content": "### <a name=\"rh-copy\"></a>C.130: For making deep copies of polymorphic classes prefer a virtual `clone` function instead of public copy construction/assignment\n\n##### Reason\n\nCopying a polymorphic class is discouraged due to the slicing problem, see [C.67](#rc-copy-virtual). If you really need copy semantics, copy deeply: Provide a virtual `clone` function that will copy the actual most-derived type and return an owning pointer to the new object, and then in derived classes return the derived type (use a covariant return type).\n\n##### Example\n\n    class B {\n    public:\n        B() = default;\n        virtual ~B() = default;\n        virtual gsl::owner<B*> clone() const = 0;\n    protected:\n         B(const B&) = default;\n         B& operator=(const B&) = default;\n         B(B&&) noexcept = default;\n         B& operator=(B&&) noexcept = default;\n        // ...\n    };\n\n    class D : public B {\n    public:\n        gsl::owner<D*> clone() const override\n        {\n            return new D{*this};\n        };\n    };\n\nGenerally, it is recommended to use smart pointers to represent ownership (see [R.20](#rr-owner)). However, because of language rules, the covariant return type cannot be a smart pointer: `D::clone` can't return a `unique_ptr<D>` while `B::clone` returns `unique_ptr<B>`. Therefore, you either need to consistently return `unique_ptr<B>` in all overrides, or use `owner<>` utility from the [Guidelines Support Library](#ss-views).\n\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-get\"></a>C.131: Avoid trivial getters and setters",
    "content": "### <a name=\"rh-get\"></a>C.131: Avoid trivial getters and setters\n\n##### Reason\n\nA trivial getter or setter adds no semantic value; the data item could just as well be `public`.\n\n##### Example\n\n    class Point {   // Bad: verbose\n        int x;\n        int y;\n    public:\n        Point(int xx, int yy) : x{xx}, y{yy} { }\n        int get_x() const { return x; }\n        void set_x(int xx) { x = xx; }\n        int get_y() const { return y; }\n        void set_y(int yy) { y = yy; }\n        // no behavioral member functions\n    };\n\nConsider making such a class a `struct` -- that is, a behaviorless bunch of variables, all public data and no member functions.\n\n    struct Point {\n        int x {0};\n        int y {0};\n    };\n\nNote that we can put default initializers on data members: [C.49: Prefer initialization to assignment in constructors](#rc-initialize).\n\n##### Note\n\nThe key to this rule is whether the semantics of the getter/setter are trivial. While it is not a complete definition of \"trivial\", consider whether there would be any difference beyond syntax if the getter/setter was a public data member instead. Examples of non-trivial semantics would be: maintaining a class invariant or converting between an internal type and an interface type.\n\n##### Enforcement\n\nFlag multiple `get` and `set` member functions that simply access a member without additional semantics.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-virtual\"></a>C.132: Don't make a function `virtual` without reason",
    "content": "### <a name=\"rh-virtual\"></a>C.132: Don't make a function `virtual` without reason\n\n##### Reason\n\nRedundant `virtual` increases run-time and object-code size.\nA virtual function can be overridden and is thus open to mistakes in a derived class.\nA virtual function ensures code replication in a templated hierarchy.\n\n##### Example, bad\n\n    template<class T>\n    class Vector {\n    public:\n        // ...\n        virtual int size() const { return sz; }   // bad: what good could a derived class do?\n    private:\n        T* elem;   // the elements\n        int sz;    // number of elements\n    };\n\nThis kind of \"vector\" isn't meant to be used as a base class at all.\n\n##### Enforcement\n\n* Flag a class with virtual functions but no derived classes.\n* Flag a class where all member functions are virtual and have implementations.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-protected\"></a>C.133: Avoid `protected` data",
    "content": "### <a name=\"rh-protected\"></a>C.133: Avoid `protected` data\n\n**Alternative formulation**: Make member data `public` or (preferably) `private`.\n\n##### Reason\n\n`protected` data is a source of complexity and errors.\n`protected` data complicates the statement of invariants.\n`protected` data inherently violates the guidance against putting data in base classes, which usually leads to having to deal with virtual inheritance as well.\n\n##### Example, bad\n\n    class Shape {\n    public:\n        // ... interface functions ...\n    protected:\n        // data for use in derived classes:\n        Color fill_color;\n        Color edge_color;\n        Style st;\n    };\n\nNow it is up to every derived `Shape` to manipulate the protected data correctly.\nThis has been popular, but also a major source of maintenance problems.\nIn a large class hierarchy, the consistent use of protected data is hard to maintain because there can be a lot of code,\nspread over a lot of classes.\nThe set of classes that can touch that data is open: anyone can derive a new class and start manipulating the protected data.\nOften, it is not possible to examine the complete set of classes, so any change to the representation of the class becomes infeasible.\nThere is no enforced invariant for the protected data; it is much like a set of global variables.\nThe protected data has de facto become global to a large body of code.\n\n##### Note\n\nProtected data often looks tempting to enable arbitrary improvements through derivation.\nOften, what you get is unprincipled changes and errors.\n[Prefer `private` data](#rc-private) with a well-specified and enforced invariant.\nAlternatively, and often better, [keep data out of any class used as an interface](#rh-abstract).\n\n##### Note\n\nProtected member function can be just fine.\n\n##### Enforcement\n\nFlag classes with `protected` data.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-public\"></a>C.134: Ensure all non-`const` data members have the same access level",
    "content": "### <a name=\"rh-public\"></a>C.134: Ensure all non-`const` data members have the same access level\n\n##### Reason\n\nPrevention of logical confusion leading to errors.\nIf the non-`const` data members don't have the same access level, the type is confused about what it's trying to do.\nIs it a type that maintains an invariant or simply a collection of values?\n\n##### Discussion\n\nThe core question is: What code is responsible for maintaining a meaningful/correct value for that variable?\n\nThere are exactly two kinds of data members:\n\n* A: Ones that don't participate in the object's invariant. Any combination of values for these members is valid.\n* B: Ones that do participate in the object's invariant. Not every combination of values is meaningful (else there'd be no invariant). Therefore all code that has write access to these variables must know about the invariant, know the semantics, and know (and actively implement and enforce) the rules for keeping the values correct.\n\nData members in category A should just be `public` (or, more rarely, `protected` if you only want derived classes to see them). They don't need encapsulation. All code in the system might as well see and manipulate them.\n\nData members in category B should be `private` or `const`. This is because encapsulation is important. To make them non-`private` and non-`const` would mean that the object can't control its own state: An unbounded amount of code beyond the class would need to know about the invariant and participate in maintaining it accurately -- if these data members were `public`, that would be all calling code that uses the object; if they were `protected`, it would be all the code in current and future derived classes. This leads to brittle and tightly coupled code that quickly becomes a nightmare to maintain. Any code that inadvertently sets the data members to an invalid or unexpected combination of values would corrupt the object and all subsequent uses of the object.\n\nMost classes are either all A or all B:\n\n* *All public*: If you're writing an aggregate bundle-of-variables without an invariant across those variables, then all the variables should be `public`.\n  [By convention, declare such classes `struct` rather than `class`](#rc-struct)\n* *All private*: If you're writing a type that maintains an invariant, then all the non-`const` variables should be private -- it should be encapsulated.\n\n##### Exception\n\nOccasionally classes will mix A and B, usually for debug reasons. An encapsulated object might contain something like non-`const` debug instrumentation that isn't part of the invariant and so falls into category A -- it isn't really part of the object's value or meaningful observable state either. In that case, the A parts should be treated as A's (made `public`, or in rarer cases `protected` if they should be visible only to derived classes) and the B parts should still be treated like B's (`private` or `const`).\n\n##### Enforcement\n\nFlag any class that has non-`const` data members with different access levels.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-mi-interface\"></a>C.135: Use multiple inheritance to represent multiple distinct interfaces",
    "content": "### <a name=\"rh-mi-interface\"></a>C.135: Use multiple inheritance to represent multiple distinct interfaces\n\n##### Reason\n\nNot all classes will necessarily support all interfaces, and not all callers will necessarily want to deal with all operations.\nEspecially to break apart monolithic interfaces into \"aspects\" of behavior supported by a given derived class.\n\n##### Example\n\n    class iostream : public istream, public ostream {   // very simplified\n        // ...\n    };\n\n`istream` provides the interface to input operations; `ostream` provides the interface to output operations.\n`iostream` provides the union of the `istream` and `ostream` interfaces and the synchronization needed to allow both on a single stream.\n\n##### Note\n\nThis is a very common use of inheritance because the need for multiple different interfaces to an implementation is common\nand such interfaces are often not easily or naturally organized into a single-rooted hierarchy.\n\n##### Note\n\nSuch interfaces are typically abstract classes.\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-mi-implementation\"></a>C.136: Use multiple inheritance to represent the union of implementation attributes",
    "content": "### <a name=\"rh-mi-implementation\"></a>C.136: Use multiple inheritance to represent the union of implementation attributes\n\n##### Reason\n\nSome forms of mixins have state and often operations on that state.\nIf the operations are virtual the use of inheritance is necessary, if not using inheritance can avoid boilerplate and forwarding.\n\n##### Example\n\n    class iostream : public istream, public ostream {   // very simplified\n        // ...\n    };\n\n`istream` provides the interface to input operations (and some data); `ostream` provides the interface to output operations (and some data).\n`iostream` provides the union of the `istream` and `ostream` interfaces and the synchronization needed to allow both on a single stream.\n\n##### Note\n\nThis is a relatively rare use because implementation can often be organized into a single-rooted hierarchy.\n\n##### Example\n\nSometimes, an \"implementation attribute\" is more like a \"mixin\" that determines the behavior of an implementation and injects\nmembers to enable the implementation of the policies it requires.\nFor example, see `std::enable_shared_from_this`\nor various bases from boost.intrusive (e.g. `list_base_hook` or `intrusive_ref_counter`).\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-vbase\"></a>C.137: Use `virtual` bases to avoid overly general base classes",
    "content": "### <a name=\"rh-vbase\"></a>C.137: Use `virtual` bases to avoid overly general base classes\n\n##### Reason\n\n Allow separation of shared data and interface.\n To avoid all shared data to being put into an ultimate base class.\n\n##### Example\n\n    struct Interface {\n        virtual void f();\n        virtual int g();\n        // ... no data here ...\n    };\n\n    class Utility {  // with data\n        void utility1();\n        virtual void utility2();    // customization point\n    public:\n        int x;\n        int y;\n    };\n\n    class Derive1 : public Interface, virtual protected Utility {\n        // override Interface functions\n        // Maybe override Utility virtual functions\n        // ...\n    };\n\n    class Derive2 : public Interface, virtual protected Utility {\n        // override Interface functions\n        // Maybe override Utility virtual functions\n        // ...\n    };\n\nFactoring out `Utility` makes sense if many derived classes share significant \"implementation details.\"\n\n\n##### Note\n\nObviously, the example is too \"theoretical\", but it is hard to find a *small* realistic example.\n`Interface` is the root of an [interface hierarchy](#rh-abstract)\nand `Utility` is the root of an [implementation hierarchy](#rh-kind).\nHere is [a slightly more realistic example](https://www.quora.com/What-are-the-uses-and-advantages-of-virtual-base-class-in-C%2B%2B/answer/Lance-Diduck) with an explanation.\n\n##### Note\n\nOften, linearization of a hierarchy is a better solution.\n\n##### Enforcement\n\nFlag mixed interface and implementation hierarchies.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-using\"></a>C.138: Create an overload set for a derived class and its bases with `using`",
    "content": "### <a name=\"rh-using\"></a>C.138: Create an overload set for a derived class and its bases with `using`\n\n##### Reason\n\nWithout a using declaration, member functions in the derived class hide the entire inherited overload sets.\n\n##### Example, bad\n\n    #include <iostream>\n    class B {\n    public:\n        virtual int f(int i) { std::cout << \"f(int): \"; return i; }\n        virtual double f(double d) { std::cout << \"f(double): \"; return d; }\n        virtual ~B() = default;\n    };\n    class D: public B {\n    public:\n        int f(int i) override { std::cout << \"f(int): \"; return i + 1; }\n    };\n    int main()\n    {\n        D d;\n        std::cout << d.f(2) << '\\n';   // prints \"f(int): 3\"\n        std::cout << d.f(2.3) << '\\n'; // prints \"f(int): 3\"\n    }\n\n##### Example, good\n\n    class D: public B {\n    public:\n        int f(int i) override { std::cout << \"f(int): \"; return i + 1; }\n        using B::f; // exposes f(double)\n    };\n\n##### Note\n\nThis issue affects both virtual and non-virtual member functions\n\nFor variadic bases, C++17 introduced a variadic form of the using-declaration,\n\n    template<class... Ts>\n    struct Overloader : Ts... {\n        using Ts::operator()...; // exposes operator() from every base\n    };\n\n##### Enforcement\n\nDiagnose name hiding\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-final\"></a>C.139: Use `final` on classes sparingly",
    "content": "### <a name=\"rh-final\"></a>C.139: Use `final` on classes sparingly\n\n##### Reason\n\nCapping a hierarchy with `final` classes is rarely needed for logical reasons and can be damaging to the extensibility of a hierarchy.\n\n##### Example, bad\n\n    class Widget { /* ... */ };\n\n    // nobody will ever want to improve My_widget (or so you thought)\n    class My_widget final : public Widget { /* ... */ };\n\n    class My_improved_widget : public My_widget { /* ... */ };  // error: can't do that\n\n##### Note\n\nNot every class is meant to be a base class.\nMost standard-library classes are examples of that (e.g., `std::vector` and `std::string` are not designed to be derived from).\nThis rule is about using `final` on classes with virtual functions meant to be interfaces for a class hierarchy.\n\n##### Note\n\nClaims of performance improvements from `final` should be substantiated.\nToo often, such claims are based on conjecture or experience with other languages.\n\nThere are examples where `final` can be important for both logical and performance reasons.\nOne example is a performance-critical AST hierarchy in a compiler or language analysis tool.\nNew derived classes are not added every year and only by library implementers.\nHowever, misuses are (or at least have been) far more common.\n\n##### Enforcement\n\nFlag uses of `final` on classes.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-virtual-default-arg\"></a>C.140: Do not provide different default arguments for a virtual function and an overrider",
    "content": "### <a name=\"rh-virtual-default-arg\"></a>C.140: Do not provide different default arguments for a virtual function and an overrider\n\n##### Reason\n\nThat can cause confusion: An overrider does not inherit default arguments.\n\n##### Example, bad\n\n    class Base {\n    public:\n        virtual int multiply(int value, int factor = 2) = 0;\n        virtual ~Base() = default;\n    };\n\n    class Derived : public Base {\n    public:\n        int multiply(int value, int factor = 10) override;\n    };\n\n    Derived d;\n    Base& b = d;\n\n    b.multiply(10);  // these two calls will call the same function but\n    d.multiply(10);  // with different arguments and so different results\n\n##### Enforcement\n\nFlag default arguments on virtual functions if they differ between base and derived declarations.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "C.hier-access: Accessing objects in a hierarchy",
    "content": "## C.hier-access: Accessing objects in a hierarchy\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-poly\"></a>C.145: Access polymorphic objects through pointers and references",
    "content": "### <a name=\"rh-poly\"></a>C.145: Access polymorphic objects through pointers and references\n\n##### Reason\n\nIf you have a class with a virtual function, you don't (in general) know which class provided the function to be used.\n\n##### Example\n\n    struct B { int a; virtual int f(); virtual ~B() = default };\n    struct D : B { int b; int f() override; };\n\n    void use(B b)\n    {\n        D d;\n        B b2 = d;   // slice\n        B b3 = b;\n    }\n\n    void use2()\n    {\n        D d;\n        use(d);   // slice\n    }\n\nBoth `d`s are sliced.\n\n##### Exception\n\nYou can safely access a named polymorphic object in the scope of its definition, just don't slice it.\n\n    void use3()\n    {\n        D d;\n        d.f();   // OK\n    }\n\n##### See also\n\n[A polymorphic class should suppress copying](#rc-copy-virtual)\n\n##### Enforcement\n\nFlag all slicing.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-dynamic_cast\"></a>C.146: Use `dynamic_cast` where class hierarchy navigation is unavoidable",
    "content": "### <a name=\"rh-dynamic_cast\"></a>C.146: Use `dynamic_cast` where class hierarchy navigation is unavoidable\n\n##### Reason\n\n`dynamic_cast` is checked at run time.\n\n##### Example\n\n    struct B {   // an interface\n        virtual void f();\n        virtual void g();\n        virtual ~B();\n    };\n\n    struct D : B {   // a wider interface\n        void f() override;\n        virtual void h();\n    };\n\n    void user(B* pb)\n    {\n        if (D* pd = dynamic_cast<D*>(pb)) {\n            // ... use D's interface ...\n        }\n        else {\n            // ... make do with B's interface ...\n        }\n    }\n\nUse of the other casts can violate type safety and cause the program to access a variable that is actually of type `X` to be accessed as if it were of an unrelated type `Z`:\n\n    void user2(B* pb)   // bad\n    {\n        D* pd = static_cast<D*>(pb);    // I know that pb really points to a D; trust me\n        // ... use D's interface ...\n    }\n\n    void user3(B* pb)    // unsafe\n    {\n        if (some_condition) {\n            D* pd = static_cast<D*>(pb);   // I know that pb really points to a D; trust me\n            // ... use D's interface ...\n        }\n        else {\n            // ... make do with B's interface ...\n        }\n    }\n\n    void f()\n    {\n        B b;\n        user(&b);   // OK\n        user2(&b);  // bad error\n        user3(&b);  // OK *if* the programmer got the some_condition check right\n    }\n\n##### Note\n\nLike other casts, `dynamic_cast` is overused.\n[Prefer virtual functions to casting](#rh-use-virtual).\nPrefer [static polymorphism](#???) to hierarchy navigation where it is possible (no run-time resolution necessary)\nand reasonably convenient.\n\n##### Note\n\nSome people use `dynamic_cast` where a `typeid` would have been more appropriate;\n`dynamic_cast` is a general \"is kind of\" operation for discovering the best interface to an object,\nwhereas `typeid` is a \"give me the exact type of this object\" operation to discover the actual type of an object.\nThe latter is an inherently simpler operation that ought to be faster.\nThe latter (`typeid`) is easily hand-crafted if necessary (e.g., if working on a system where RTTI is -- for some reason -- prohibited),\nthe former (`dynamic_cast`) is far harder to implement correctly in general.\n\nConsider:\n\n    struct B {\n        const char* name {\"B\"};\n        // if pb1->id() == pb2->id() *pb1 is the same type as *pb2\n        virtual const char* id() const { return name; }\n        // ...\n    };\n\n    struct D : B {\n        const char* name {\"D\"};\n        const char* id() const override { return name; }\n        // ...\n    };\n\n    void use()\n    {\n        B* pb1 = new B;\n        B* pb2 = new D;\n\n        cout << pb1->id(); // \"B\"\n        cout << pb2->id(); // \"D\"\n\n\n        if (pb2->id() == \"D\") {         // looks innocent\n            D* pd = static_cast<D*>(pb2);\n            // ...\n        }\n        // ...\n    }\n\nThe result of `pb2->id() == \"D\"` is actually implementation defined.\nWe added it to warn of the dangers of home-brew RTTI.\nThis code might work as expected for years, just to fail on a new machine, new compiler, or a new linker that does not unify character literals.\n\nIf you implement your own RTTI, be careful.\n\n##### Exception\n\nIf your implementation provided a really slow `dynamic_cast`, you might have to use a workaround.\nHowever, all workarounds that cannot be statically resolved involve explicit casting (typically `static_cast`) and are error-prone.\nYou will basically be crafting your own special-purpose `dynamic_cast`.\nSo, first make sure that your `dynamic_cast` really is as slow as you think it is (there are a fair number of unsupported rumors about)\nand that your use of `dynamic_cast` is really performance critical.\n\nWe are of the opinion that current implementations of `dynamic_cast` are unnecessarily slow.\nFor example, under suitable conditions, it is possible to perform a `dynamic_cast` in [fast constant time](https://www.stroustrup.com/fast_dynamic_casting.pdf).\nHowever, compatibility makes changes difficult even if all agree that an effort to optimize is worthwhile.\n\nIn very rare cases, if you have measured that the `dynamic_cast` overhead is material, you have other means to statically guarantee that a downcast will succeed (e.g., you are using CRTP carefully), and there is no virtual inheritance involved, consider tactically resorting `static_cast` with a prominent comment and disclaimer summarizing this paragraph and that human attention is needed under maintenance because the type system can't verify correctness. Even so, in our experience such \"I know what I'm doing\" situations are still a known bug source.\n\n##### Exception\n\nConsider:\n\n    template<typename B>\n    class Dx : B {\n        // ...\n    };\n\n##### Enforcement\n\n* Flag all uses of `static_cast` for downcasts, including C-style casts that perform a `static_cast`.\n* This rule is part of the [type-safety profile](#pro-type-downcast).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-ref-cast\"></a>C.147: Use `dynamic_cast` to a reference type when failure to find the required class is considered an error",
    "content": "### <a name=\"rh-ref-cast\"></a>C.147: Use `dynamic_cast` to a reference type when failure to find the required class is considered an error\n\n##### Reason\n\nCasting to a reference expresses that you intend to end up with a valid object, so the cast must succeed. `dynamic_cast` will then throw if it does not succeed.\n\n##### Example\n\n    std::string f(Base& b)\n    {\n        return dynamic_cast<Derived&>(b).to_string();\n    }\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-ptr-cast\"></a>C.148: Use `dynamic_cast` to a pointer type when failure to find the required class is considered a valid alternative",
    "content": "### <a name=\"rh-ptr-cast\"></a>C.148: Use `dynamic_cast` to a pointer type when failure to find the required class is considered a valid alternative\n\n##### Reason\n\nThe `dynamic_cast` conversion allows to test whether a pointer is pointing at a polymorphic object that has a given class in its hierarchy. Since failure to find the class merely returns a null value, it can be tested during run time. This allows writing code that can choose alternative paths depending on the results.\n\nContrast with [C.147](#rh-ref-cast), where failure is an error, and should not be used for conditional execution.\n\n##### Example\n\nThe example below describes the `add` function of a `Shape_owner` that takes ownership of constructed `Shape` objects. The objects are also sorted into views, according to their geometric attributes.\nIn this example, `Shape` does not inherit from `Geometric_attributes`. Only its subclasses do.\n\n    void add(Shape* const item)\n    {\n      // Ownership is always taken\n      owned_shapes.emplace_back(item);\n\n      // Check the Geometric_attributes and add the shape to none/one/some/all of the views\n\n      if (auto even = dynamic_cast<Even_sided*>(item))\n      {\n        view_of_evens.emplace_back(even);\n      }\n\n      if (auto trisym = dynamic_cast<Trilaterally_symmetrical*>(item))\n      {\n        view_of_trisyms.emplace_back(trisym);\n      }\n    }\n\n##### Notes\n\nA failure to find the required class will cause `dynamic_cast` to return a null value, and de-referencing a null-valued pointer will lead to undefined behavior.\nTherefore the result of the `dynamic_cast` should always be treated as if it might contain a null value, and tested.\n\n##### Enforcement\n\n* (Complex) Unless there is a null test on the result of a `dynamic_cast` of a pointer type, warn upon dereference of the pointer.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-smart\"></a>C.149: Use `unique_ptr` or `shared_ptr` to avoid forgetting to `delete` objects created using `new`",
    "content": "### <a name=\"rh-smart\"></a>C.149: Use `unique_ptr` or `shared_ptr` to avoid forgetting to `delete` objects created using `new`\n\n##### Reason\n\nAvoid resource leaks.\n\n##### Example\n\n    void use(int i)\n    {\n        auto p = new int {7};           // bad: initialize local pointers with new\n        auto q = make_unique<int>(9);   // ok: guarantee the release of the memory-allocated for 9\n        if (0 < i) return;              // maybe return and leak\n        delete p;                       // too late\n    }\n\n##### Enforcement\n\n* Flag initialization of a naked pointer with the result of a `new`\n* Flag `delete` of local variable\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-make_unique\"></a>C.150: Use `make_unique()` to construct objects owned by `unique_ptr`s",
    "content": "### <a name=\"rh-make_unique\"></a>C.150: Use `make_unique()` to construct objects owned by `unique_ptr`s\n\nSee [R.23](#rr-make_unique)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-make_shared\"></a>C.151: Use `make_shared()` to construct objects owned by `shared_ptr`s",
    "content": "### <a name=\"rh-make_shared\"></a>C.151: Use `make_shared()` to construct objects owned by `shared_ptr`s\n\nSee [R.22](#rr-make_shared)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-array\"></a>C.152: Never assign a pointer to an array of derived class objects to a pointer to its base",
    "content": "### <a name=\"rh-array\"></a>C.152: Never assign a pointer to an array of derived class objects to a pointer to its base\n\n##### Reason\n\nSubscripting the resulting base pointer will lead to invalid object access and probably to memory corruption.\n\n##### Example\n\n    struct B { int x; };\n    struct D : B { int y; };\n\n    void use(B*);\n\n    D a[] = { {1, 2}, {3, 4}, {5, 6} };\n    B* p = a;     // bad: a decays to &a[0] which is converted to a B*\n    p[1].x = 7;   // overwrite a[0].y\n\n    use(a);       // bad: a decays to &a[0] which is converted to a B*\n\n##### Enforcement\n\n* Flag all combinations of array decay and base to derived conversions.\n* Pass an array as a `span` rather than as a pointer, and don't let the array name suffer a derived-to-base conversion before getting into the `span`\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rh-use-virtual\"></a>C.153: Prefer virtual function to casting",
    "content": "### <a name=\"rh-use-virtual\"></a>C.153: Prefer virtual function to casting\n\n##### Reason\n\nA virtual function call is safe, whereas casting is error-prone.\nA virtual function call reaches the most derived function, whereas a cast might reach an intermediate class and therefore\ngive a wrong result (especially as a hierarchy is modified during maintenance).\n\n##### Example\n\n    ???\n\n##### Enforcement\n\nSee [C.146](#rh-dynamic_cast) and ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-overload\"></a>C.over: Overloading and overloaded operators",
    "content": "## <a name=\"ss-overload\"></a>C.over: Overloading and overloaded operators\n\nYou can overload ordinary functions, function templates, and operators.\nYou cannot overload function objects.\n\nOverload rule summary:\n\n* [C.160: Define operators primarily to mimic conventional usage](#ro-conventional)\n* [C.161: Use non-member functions for symmetric operators](#ro-symmetric)\n* [C.162: Overload operations that are roughly equivalent](#ro-equivalent)\n* [C.163: Overload only for operations that are roughly equivalent](#ro-equivalent-2)\n* [C.164: Avoid implicit conversion operators](#ro-conversion)\n* [C.165: Use `using` for customization points](#ro-custom)\n* [C.166: Overload unary `&` only as part of a system of smart pointers and references](#ro-address-of)\n* [C.167: Use an operator for an operation with its conventional meaning](#ro-overload)\n* [C.168: Define overloaded operators in the namespace of their operands](#ro-namespace)\n* [C.170: If you feel like overloading a lambda, use a generic lambda](#ro-lambda)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ro-conventional\"></a>C.160: Define operators primarily to mimic conventional usage",
    "content": "### <a name=\"ro-conventional\"></a>C.160: Define operators primarily to mimic conventional usage\n\n##### Reason\n\nMinimize surprises.\n\n##### Example\n\n    class X {\n    public:\n        // ...\n        X& operator=(const X&); // member function defining assignment\n        friend bool operator==(const X&, const X&); // == needs access to representation\n                                                    // after a = b we have a == b\n        // ...\n    };\n\nHere, the conventional semantics is maintained: [Copies compare equal](#ss-copy).\n\n##### Example, bad\n\n    X operator+(X a, X b) { return a.v - b.v; }   // bad: makes + subtract\n\n##### Note\n\nNon-member operators should be either friends or defined in [the same namespace as their operands](#ro-namespace).\n[Binary operators should treat their operands equivalently](#ro-symmetric).\n\n##### Enforcement\n\nPossibly impossible.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ro-symmetric\"></a>C.161: Use non-member functions for symmetric operators",
    "content": "### <a name=\"ro-symmetric\"></a>C.161: Use non-member functions for symmetric operators\n\n##### Reason\n\nIf you use member functions, you need two.\nUnless you use a non-member function for (say) `==`, `a == b` and `b == a` will be subtly different.\n\n##### Example\n\n    bool operator==(Point a, Point b) { return a.x == b.x && a.y == b.y; }\n\n##### Enforcement\n\nFlag member operator functions.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ro-equivalent\"></a>C.162: Overload operations that are roughly equivalent",
    "content": "### <a name=\"ro-equivalent\"></a>C.162: Overload operations that are roughly equivalent\n\n##### Reason\n\nHaving different names for logically equivalent operations on different argument types is confusing, leads to encoding type information in function names, and inhibits generic programming.\n\n##### Example\n\nConsider:\n\n    void print(int a);\n    void print(int a, int base);\n    void print(const string&);\n\nThese three functions all print their arguments (appropriately). Conversely:\n\n    void print_int(int a);\n    void print_based(int a, int base);\n    void print_string(const string&);\n\nThese three functions all print their arguments (appropriately). Adding to the name just introduced verbosity and inhibits generic code.\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ro-equivalent-2\"></a>C.163: Overload only for operations that are roughly equivalent",
    "content": "### <a name=\"ro-equivalent-2\"></a>C.163: Overload only for operations that are roughly equivalent\n\n##### Reason\n\nHaving the same name for logically different functions is confusing and leads to errors when using generic programming.\n\n##### Example\n\nConsider:\n\n    void open_gate(Gate& g);   // remove obstacle from garage exit lane\n    void fopen(const char* name, const char* mode);   // open file\n\nThe two operations are fundamentally different (and unrelated) so it is good that their names differ. Conversely:\n\n    void open(Gate& g);   // remove obstacle from garage exit lane\n    void open(const char* name, const char* mode =\"r\");   // open file\n\nThe two operations are still fundamentally different (and unrelated) but the names have been reduced to their (common) minimum, opening opportunities for confusion.\nFortunately, the type system will catch many such mistakes.\n\n##### Note\n\nBe particularly careful about common and popular names, such as `open`, `move`, `+`, and `==`.\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ro-conversion\"></a>C.164: Avoid implicit conversion operators",
    "content": "### <a name=\"ro-conversion\"></a>C.164: Avoid implicit conversion operators\n\n##### Reason\n\nImplicit conversions can be essential (e.g., `double` to `int`) but often cause surprises (e.g., `String` to C-style string).\n\n##### Note\n\nPrefer explicitly named conversions until a serious need is demonstrated.\nBy \"serious need\" we mean a reason that is fundamental in the application domain (such as an integer to complex number conversion)\nand frequently needed. Do not introduce implicit conversions (through conversion operators or non-`explicit` constructors)\njust to gain a minor convenience.\n\n##### Example\n\n    struct S1 {\n        string s;\n        // ...\n        operator char*() { return s.data(); }  // BAD, likely to cause surprises\n    };\n\n    struct S2 {\n        string s;\n        // ...\n        explicit operator char*() { return s.data(); }\n    };\n\n    void f(S1 s1, S2 s2)\n    {\n        char* x1 = s1;     // OK, but can cause surprises in many contexts\n        char* x2 = s2;     // error (and that's usually a good thing)\n        char* x3 = static_cast<char*>(s2); // we can be explicit (on your head be it)\n    }\n\nThe surprising and potentially damaging implicit conversion can occur in arbitrarily hard-to spot contexts, e.g.,\n\n    S1 ff();\n\n    char* g()\n    {\n        return ff();\n    }\n\nThe string returned by `ff()` is destroyed before the returned pointer into it can be used.\n\n##### Enforcement\n\nFlag all non-explicit conversion operators.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ro-custom\"></a>C.165: Use `using` for customization points",
    "content": "### <a name=\"ro-custom\"></a>C.165: Use `using` for customization points\n\n##### Reason\n\nTo find function objects and functions defined in a separate namespace to \"customize\" a common function.\n\n##### Example\n\nConsider `swap`. It is a general (standard-library) function with a definition that will work for just about any type.\nHowever, it is desirable to define specific `swap()`s for specific types.\nFor example, the general `swap()` will copy the elements of two `vector`s being swapped, whereas a good specific implementation will not copy elements at all.\n\n    namespace N {\n        My_type X { /* ... */ };\n        void swap(X&, X&);   // optimized swap for N::X\n        // ...\n    }\n\n    void f1(N::X& a, N::X& b)\n    {\n        std::swap(a, b);   // probably not what we wanted: calls std::swap()\n    }\n\nThe `std::swap()` in `f1()` does exactly what we asked it to do: it calls the `swap()` in namespace `std`.\nUnfortunately, that's probably not what we wanted.\nHow do we get `N::X` considered?\n\n    void f2(N::X& a, N::X& b)\n    {\n        swap(a, b);   // calls N::swap\n    }\n\nBut that might not be what we wanted for generic code.\nThere, we typically want the specific function if it exists and the general function if not.\nThis is done by including the general function in the lookup for the function:\n\n    void f3(N::X& a, N::X& b)\n    {\n        using std::swap;  // make std::swap available\n        swap(a, b);        // calls N::swap if it exists, otherwise std::swap\n    }\n\n##### Enforcement\n\nUnlikely, except for known customization points, such as `swap`.\nThe problem is that the unqualified and qualified lookups both have uses.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ro-address-of\"></a>C.166: Overload unary `&` only as part of a system of smart pointers and references",
    "content": "### <a name=\"ro-address-of\"></a>C.166: Overload unary `&` only as part of a system of smart pointers and references\n\n##### Reason\n\nThe `&` operator is fundamental in C++.\nMany parts of the C++ semantics assume its default meaning.\n\n##### Example\n\n    class Ptr { // a somewhat smart pointer\n        Ptr(X* pp) : p(pp) { /* check */ }\n        X* operator->() { /* check */ return p; }\n        X operator[](int i);\n        X operator*();\n    private:\n        T* p;\n    };\n\n    class X {\n        Ptr operator&() { return Ptr{this}; }\n        // ...\n    };\n\n##### Note\n\nIf you \"mess with\" operator `&` be sure that its definition has matching meanings for `->`, `[]`, `*`, and `.` on the result type.\nNote that operator `.` currently cannot be overloaded so a perfect system is impossible.\nWe hope to remedy that: [Operator Dot (R2)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4477.pdf).\nNote that `std::addressof()` always yields a built-in pointer.\n\n##### Enforcement\n\nTricky. Warn if `&` is user-defined without also defining `->` for the result type.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ro-overload\"></a>C.167: Use an operator for an operation with its conventional meaning",
    "content": "### <a name=\"ro-overload\"></a>C.167: Use an operator for an operation with its conventional meaning\n\n##### Reason\n\nReadability. Convention. Reusability. Support for generic code\n\n##### Example\n\n    void cout_my_class(const My_class& c) // confusing, not conventional, not generic\n    {\n        std::cout << /* class members here */;\n    }\n\n    std::ostream& operator<<(std::ostream& os, const my_class& c) // OK\n    {\n        return os << /* class members here */;\n    }\n\nBy itself, `cout_my_class` would be OK, but it is not usable/composable with code that relies on the `<<` convention for output:\n\n    My_class var { /* ... */ };\n    // ...\n    cout << \"var = \" << var << '\\n';\n\n##### Note\n\nThere are strong and vigorous conventions for the meaning of most operators, such as\n\n* comparisons (`==`, `!=`, `<`, `<=`, `>`, `>=`, and `<=>`),\n* arithmetic operations (`+`, `-`, `*`, `/`, and `%`)\n* access operations (`.`, `->`, unary `*`, and `[]`)\n* assignment (`=`)\n\nDon't define those unconventionally and don't invent your own names for them.\n\n##### Enforcement\n\nTricky. Requires semantic insight.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ro-namespace\"></a>C.168: Define overloaded operators in the namespace of their operands",
    "content": "### <a name=\"ro-namespace\"></a>C.168: Define overloaded operators in the namespace of their operands\n\n##### Reason\n\nReadability.\nAbility for find operators using ADL.\nAvoiding inconsistent definition in different namespaces\n\n##### Example\n\n    struct S { };\n    S operator+(S, S);   // OK: in the same namespace as S, and even next to S\n    S s;\n\n    S r = s + s;\n\n##### Example\n\n    namespace N {\n        struct S { };\n        S operator+(S, S);   // OK: in the same namespace as S, and even next to S\n    }\n\n    N::S s;\n\n    S r = s + s;  // finds N::operator+() by ADL\n\n##### Example, bad\n\n    struct S { };\n    S s;\n\n    namespace N {\n        bool operator!(S a) { return true; }\n        bool not_s = !s;\n    }\n\n    namespace M {\n        bool operator!(S a) { return false; }\n        bool not_s = !s;\n    }\n\nHere, the meaning of `!s` differs in `N` and `M`.\nThis can be most confusing.\nRemove the definition of `namespace M` and the confusion is replaced by an opportunity to make the mistake.\n\n##### Note\n\nIf a binary operator is defined for two types that are defined in different namespaces, you cannot follow this rule.\nFor example:\n\n    Vec::Vector operator*(const Vec::Vector&, const Mat::Matrix&);\n\nThis might be something best avoided.\n\n##### See also\n\nThis is a special case of the rule that [helper functions should be defined in the same namespace as their class](#rc-helper).\n\n##### Enforcement\n\n* Flag operator definitions that are not in the namespace of their operands\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ro-lambda\"></a>C.170: If you feel like overloading a lambda, use a generic lambda",
    "content": "### <a name=\"ro-lambda\"></a>C.170: If you feel like overloading a lambda, use a generic lambda\n\n##### Reason\n\nYou cannot overload by defining two different lambdas with the same name.\n\n##### Example\n\n    void f(int);\n    void f(double);\n    auto f = [](char);   // error: cannot overload variable and function\n\n    auto g = [](int) { /* ... */ };\n    auto g = [](double) { /* ... */ };   // error: cannot overload variables\n\n    auto h = [](auto) { /* ... */ };   // OK\n\n##### Enforcement\n\nThe compiler catches the attempt to overload a lambda.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-union\"></a>C.union: Unions",
    "content": "## <a name=\"ss-union\"></a>C.union: Unions\n\nA `union` is a `struct` where all members start at the same address so that it can hold only one member at a time.\nA `union` does not keep track of which member is stored so the programmer has to get it right;\nthis is inherently error-prone, but there are ways to compensate.\n\nA type that is a `union` plus an indicator of which member is currently held is called a *tagged union*, a *discriminated union*, or a *variant*.\n\nUnion rule summary:\n\n* [C.180: Use `union`s to save Memory](#ru-union)\n* [C.181: Avoid \"naked\" `union`s](#ru-naked)\n* [C.182: Use anonymous `union`s to implement tagged unions](#ru-anonymous)\n* [C.183: Don't use a `union` for type punning](#ru-pun)\n* ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ru-union\"></a>C.180: Use `union`s to save memory",
    "content": "### <a name=\"ru-union\"></a>C.180: Use `union`s to save memory\n\n##### Reason\n\nA `union` allows a single piece of memory to be used for different types of objects at different times.\nConsequently, it can be used to save memory when we have several objects that are never used at the same time.\n\n##### Example\n\n    union Value {\n        int x;\n        double d;\n    };\n\n    Value v = { 123 };  // now v holds an int\n    cout << v.x << '\\n';    // write 123\n    v.d = 987.654;  // now v holds a double\n    cout << v.d << '\\n';    // write 987.654\n\nBut heed the warning: [Avoid \"naked\" `union`s](#ru-naked)\n\n##### Example\n\n    // Short-string optimization\n\n    constexpr size_t buffer_size = 16; // Slightly larger than the size of a pointer\n\n    class Immutable_string {\n    public:\n        Immutable_string(const char* str) :\n            size(strlen(str))\n        {\n            if (size < buffer_size)\n                strcpy_s(string_buffer, buffer_size, str);\n            else {\n                string_ptr = new char[size + 1];\n                strcpy_s(string_ptr, size + 1, str);\n            }\n        }\n\n        ~Immutable_string()\n        {\n            if (size >= buffer_size)\n                delete[] string_ptr;\n        }\n\n        const char* get_str() const\n        {\n            return (size < buffer_size) ? string_buffer : string_ptr;\n        }\n\n    private:\n        // If the string is short enough, we store the string itself\n        // instead of a pointer to the string.\n        union {\n            char* string_ptr;\n            char string_buffer[buffer_size];\n        };\n\n        const size_t size;\n    };\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ru-naked\"></a>C.181: Avoid \"naked\" `union`s",
    "content": "### <a name=\"ru-naked\"></a>C.181: Avoid \"naked\" `union`s\n\n##### Reason\n\nA *naked union* is a union without an associated indicator which member (if any) it holds,\nso that the programmer has to keep track.\nNaked unions are a source of type errors.\n\n##### Example, bad\n\n    union Value {\n        int x;\n        double d;\n    };\n\n    Value v;\n    v.d = 987.654;  // v holds a double\n\nSo far, so good, but we can easily misuse the `union`:\n\n    cout << v.x << '\\n';    // BAD, undefined behavior: v holds a double, but we read it as an int\n\nNote that the type error happened without any explicit cast.\nWhen we tested that program the last value printed was `1683627180` which is the integer value for the bit pattern for `987.654`.\nWhat we have here is an \"invisible\" type error that happens to give a result that could easily look innocent.\n\nAnd, talking about \"invisible\", this code produced no output:\n\n    v.x = 123;\n    cout << v.d << '\\n';    // BAD: undefined behavior\n\n##### Alternative\n\nWrap a `union` in a class together with a type field.\n\nThe C++17 `variant` type (found in `<variant>`) does that for you:\n\n    variant<int, double> v;\n    v = 123;        // v holds an int\n    int x = get<int>(v);\n    v = 123.456;    // v holds a double\n    double w = get<double>(v);\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ru-anonymous\"></a>C.182: Use anonymous `union`s to implement tagged unions",
    "content": "### <a name=\"ru-anonymous\"></a>C.182: Use anonymous `union`s to implement tagged unions\n\n##### Reason\n\nA well-designed tagged union is type safe.\nAn *anonymous* union simplifies the definition of a class with a (tag, union) pair.\n\n##### Example\n\nThis example is mostly borrowed from TC++PL4, pp. 216--218.\nYou can look there for an explanation.\n\nThe code is somewhat elaborate.\nHandling a type with user-defined assignment and destructor is tricky.\nSaving programmers from having to write such code is one reason for including `variant` in the standard.\n\n    class Value { // two alternative representations represented as a union\n    private:\n        enum class Tag { number, text };\n        Tag type; // discriminant\n\n        union { // representation (note: anonymous union)\n            int i;\n            string s; // string has default constructor, copy operations, and destructor\n        };\n    public:\n        struct Bad_entry { }; // used for exceptions\n\n        ~Value();\n        Value& operator=(const Value&);   // necessary because of the string variant\n        Value(const Value&);\n        // ...\n        int number() const;\n        string text() const;\n\n        void set_number(int n);\n        void set_text(const string&);\n        // ...\n    };\n\n    int Value::number() const\n    {\n        if (type != Tag::number) throw Bad_entry{};\n        return i;\n    }\n\n    string Value::text() const\n    {\n        if (type != Tag::text) throw Bad_entry{};\n        return s;\n    }\n\n    void Value::set_number(int n)\n    {\n        if (type == Tag::text) {\n            s.~string();      // explicitly destroy string\n            type = Tag::number;\n        }\n        i = n;\n    }\n\n    void Value::set_text(const string& ss)\n    {\n        if (type == Tag::text)\n            s = ss;\n        else {\n            new(&s) string{ss};   // placement new: explicitly construct string\n            type = Tag::text;\n        }\n    }\n\n    Value& Value::operator=(const Value& e)   // necessary because of the string variant\n    {\n        if (type == Tag::text && e.type == Tag::text) {\n            s = e.s;    // usual string assignment\n            return *this;\n        }\n\n        if (type == Tag::text) s.~string(); // explicit destroy\n\n        switch (e.type) {\n        case Tag::number:\n            i = e.i;\n            break;\n        case Tag::text:\n            new(&s) string(e.s);   // placement new: explicit construct\n        }\n\n        type = e.type;\n        return *this;\n    }\n\n    Value::~Value()\n    {\n        if (type == Tag::text) s.~string(); // explicit destroy\n    }\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ru-pun\"></a>C.183: Don't use a `union` for type punning",
    "content": "### <a name=\"ru-pun\"></a>C.183: Don't use a `union` for type punning\n\n##### Reason\n\nIt is undefined behavior to read a `union` member with a different type from the one with which it was written.\nSuch punning is invisible, or at least harder to spot than using a named cast.\nType punning using a `union` is a source of errors.\n\n##### Example, bad\n\n    union Pun {\n        int x;\n        unsigned char c[sizeof(int)];\n    };\n\nThe idea of `Pun` is to be able to look at the character representation of an `int`.\n\n    void bad(Pun& u)\n    {\n        u.x = 'x';\n        cout << u.c[0] << '\\n';     // undefined behavior\n    }\n\nIf you wanted to see the bytes of an `int`, use a (named) cast:\n\n    void if_you_must_pun(int& x)\n    {\n        auto p = reinterpret_cast<std::byte*>(&x);\n        cout << to_integer<unsigned>(p[0]) << '\\n'; // OK; better\n        // ...\n    }\n\nAccessing the result of a `reinterpret_cast` from the object's declared type to `char*`, `unsigned char*`, or `std::byte*` is defined behavior. (Using `reinterpret_cast` is discouraged,\nbut at least we can see that something tricky is going on.)\n\n##### Note\n\nUnfortunately, `union`s are commonly used for type punning.\nWe don't consider \"sometimes, it works as expected\" a conclusive argument.\n\nModern C++ introduced `std::byte` (C++17) and `std::bit_cast` (C++20) to facilitate operations on raw object representations.\nUse `reinterpret_cast` along with `std::byte` instead of `unsigned char` or `char` for these operations.\n\n\n##### Enforcement\n\n???\n\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-enum\"></a>Enum: Enumerations",
    "content": "# <a name=\"s-enum\"></a>Enum: Enumerations\n\nEnumerations are used to define sets of integer values and for defining types for such sets of values.\nThere are two kinds of enumerations, \"plain\" `enum`s and `class enum`s.\n\nEnumeration rule summary:\n\n* [Enum.1: Prefer enumerations over macros](#renum-macro)\n* [Enum.2: Use enumerations to represent sets of related named constants](#renum-set)\n* [Enum.3: Prefer `enum class`es over \"plain\" `enum`s](#renum-class)\n* [Enum.4: Define operations on enumerations for safe and simple use](#renum-oper)\n* [Enum.5: Don't use `ALL_CAPS` for enumerators](#renum-caps)\n* [Enum.6: Avoid unnamed enumerations](#renum-unnamed)\n* [Enum.7: Specify the underlying type of an enumeration only when necessary](#renum-underlying)\n* [Enum.8: Specify enumerator values only when necessary](#renum-value)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"renum-macro\"></a>Enum.1: Prefer enumerations over macros",
    "content": "### <a name=\"renum-macro\"></a>Enum.1: Prefer enumerations over macros\n\n##### Reason\n\nMacros do not obey scope and type rules. Also, macro names are removed during preprocessing and so usually don't appear in tools like debuggers.\n\n##### Example\n\nFirst some bad old code:\n\n    // webcolors.h (third party header)\n    #define RED   0xFF0000\n    #define GREEN 0x00FF00\n    #define BLUE  0x0000FF\n\n    // productinfo.h\n    // The following define product subtypes based on color\n    #define RED    0\n    #define PURPLE 1\n    #define BLUE   2\n\n    int webby = BLUE;   // webby == 2; probably not what was desired\n\nInstead use an `enum`:\n\n    enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };\n    enum class Product_info { red = 0, purple = 1, blue = 2 };\n\n    int webby = blue;   // error: be specific\n    Web_color webby = Web_color::blue;\n\nWe used an `enum class` to avoid name clashes.\n\n##### Note\n\nAlso consider `constexpr` and `const inline` variables.\n\n##### Enforcement\n\nFlag macros that define integer values. Use `enum` or `const inline` or another non-macro alternative instead.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"renum-set\"></a>Enum.2: Use enumerations to represent sets of related named constants",
    "content": "### <a name=\"renum-set\"></a>Enum.2: Use enumerations to represent sets of related named constants\n\n##### Reason\n\nAn enumeration shows the enumerators to be related and can be a named type.\n\n\n\n##### Example\n\n    enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };\n\n\n##### Note\n\nSwitching on an enumeration is common and the compiler can warn against unusual patterns of case labels. For example:\n\n    enum class Product_info { red = 0, purple = 1, blue = 2 };\n\n    void print(Product_info inf)\n    {\n        switch (inf) {\n        case Product_info::red: cout << \"red\"; break;\n        case Product_info::purple: cout << \"purple\"; break;\n        }\n    }\n\nSuch off-by-one `switch`-statements are often the results of an added enumerator and insufficient testing.\n\n##### Enforcement\n\n* Flag `switch`-statements where the `case`s cover most but not all enumerators of an enumeration.\n* Flag `switch`-statements where the `case`s cover a few enumerators of an enumeration, but there is no `default`.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"renum-class\"></a>Enum.3: Prefer class enums over \"plain\" enums",
    "content": "### <a name=\"renum-class\"></a>Enum.3: Prefer class enums over \"plain\" enums\n\n##### Reason\n\nTo minimize surprises: traditional enums convert to int too readily.\n\n##### Example\n\n    void Print_color(int color);\n\n    enum Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };\n    enum Product_info { red = 0, purple = 1, blue = 2 };\n\n    Web_color webby = Web_color::blue;\n\n    // Clearly at least one of these calls is buggy.\n    Print_color(webby);\n    Print_color(Product_info::blue);\n\nInstead use an `enum class`:\n\n    void Print_color(int color);\n\n    enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };\n    enum class Product_info { red = 0, purple = 1, blue = 2 };\n\n    Web_color webby = Web_color::blue;\n    Print_color(webby);  // Error: cannot convert Web_color to int.\n    Print_color(Product_info::red);  // Error: cannot convert Product_info to int.\n\n##### Enforcement\n\n(Simple) Warn on any non-class `enum` definition.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"renum-oper\"></a>Enum.4: Define operations on enumerations for safe and simple use",
    "content": "### <a name=\"renum-oper\"></a>Enum.4: Define operations on enumerations for safe and simple use\n\n##### Reason\n\nConvenience of use and avoidance of errors.\n\n##### Example\n\n    enum class Day { mon, tue, wed, thu, fri, sat, sun };\n\n    Day& operator++(Day& d)\n    {\n        return d = (d == Day::sun) ? Day::mon : static_cast<Day>(static_cast<int>(d)+1);\n    }\n\n    Day today = Day::sat;\n    Day tomorrow = ++today;\n\nThe use of a `static_cast` is not pretty, but\n\n    Day& operator++(Day& d)\n    {\n        return d = (d == Day::sun) ? Day::mon : Day{++d};    // error\n    }\n\nis an infinite recursion, and writing it without a cast, using a `switch` on all cases is long-winded.\n\n\n##### Enforcement\n\nFlag repeated expressions cast back into an enumeration.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"renum-caps\"></a>Enum.5: Don't use `ALL_CAPS` for enumerators",
    "content": "### <a name=\"renum-caps\"></a>Enum.5: Don't use `ALL_CAPS` for enumerators\n\n##### Reason\n\nAvoid clashes with macros.\n\n##### Example, bad\n\n     // webcolors.h (third party header)\n    #define RED   0xFF0000\n    #define GREEN 0x00FF00\n    #define BLUE  0x0000FF\n\n    // productinfo.h\n    // The following define product subtypes based on color\n\n    enum class Product_info { RED, PURPLE, BLUE };   // syntax error\n\n##### Enforcement\n\nFlag ALL_CAPS enumerators.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"renum-unnamed\"></a>Enum.6: Avoid unnamed enumerations",
    "content": "### <a name=\"renum-unnamed\"></a>Enum.6: Avoid unnamed enumerations\n\n##### Reason\n\nIf you can't name an enumeration, the values are not related\n\n##### Example, bad\n\n    enum { red = 0xFF0000, scale = 4, is_signed = 1 };\n\nSuch code is not uncommon in code written before there were convenient alternative ways of specifying integer constants.\n\n##### Alternative\n\nUse `constexpr` values instead. For example:\n\n    constexpr int red = 0xFF0000;\n    constexpr short scale = 4;\n    constexpr bool is_signed = true;\n\n##### Enforcement\n\nFlag unnamed enumerations.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"renum-underlying\"></a>Enum.7: Specify the underlying type of an enumeration only when necessary",
    "content": "### <a name=\"renum-underlying\"></a>Enum.7: Specify the underlying type of an enumeration only when necessary\n\n##### Reason\n\nThe default is the easiest to read and write.\n`int` is the default integer type.\n`int` is compatible with C `enum`s.\n\n##### Example\n\n    enum class Direction : char { n, s, e, w,\n                                  ne, nw, se, sw };  // underlying type saves space\n\n    enum class Web_color : int32_t { red   = 0xFF0000,\n                                     green = 0x00FF00,\n                                     blue  = 0x0000FF };  // underlying type is redundant\n\n##### Note\n\nSpecifying the underlying type is necessary to forward-declare an enum or enum class:\n\n    enum Flags : char;\n\n    void f(Flags);\n\n    // ....\n\n    enum Flags : char { /* ... */ };\n\nor to ensure that values of that type have a specified bit-precision:\n\n    enum Bitboard : uint64_t { /* ... */ };\n\n##### Enforcement\n\n????\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"renum-value\"></a>Enum.8: Specify enumerator values only when necessary",
    "content": "### <a name=\"renum-value\"></a>Enum.8: Specify enumerator values only when necessary\n\n##### Reason\n\nIt's the simplest.\nIt avoids duplicate enumerator values.\nThe default gives a consecutive set of values that is good for `switch`-statement implementations.\n\n##### Example\n\n    enum class Col1 { red, yellow, blue };\n    enum class Col2 { red = 1, yellow = 2, blue = 2 }; // typo\n    enum class Month { jan = 1, feb, mar, apr, may, jun,\n                       jul, august, sep, oct, nov, dec }; // starting with 1 is conventional\n    enum class Base_flag { dec = 1, oct = dec << 1, hex = dec << 2 }; // set of bits\n\nSpecifying values is necessary to match conventional values (e.g., `Month`)\nand where consecutive values are undesirable (e.g., to get separate bits as in `Base_flag`).\n\n##### Enforcement\n\n* Flag duplicate enumerator values\n* Flag explicitly specified all-consecutive enumerator values\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-resource\"></a>R: Resource management",
    "content": "# <a name=\"s-resource\"></a>R: Resource management\n\nThis section contains rules related to resources.\nA resource is anything that must be acquired and (explicitly or implicitly) released, such as memory, file handles, sockets, and locks.\nThe reason it must be released is typically that it can be in short supply, so even delayed release might do harm.\nThe fundamental aim is to ensure that we don't leak any resources and that we don't hold a resource longer than we need to.\nAn entity that is responsible for releasing a resource is called an owner.\n\nThere are a few cases where leaks can be acceptable or even optimal:\nIf you are writing a program that simply produces an output based on an input and the amount of memory needed is proportional to the size of the input, the optimal strategy (for performance and ease of programming) is sometimes simply never to delete anything.\nIf you have enough memory to handle your largest input, leak away, but be sure to give a good error message if you are wrong.\nHere, we ignore such cases.\n\n* Resource management rule summary:\n\n  * [R.1: Manage resources automatically using resource handles and RAII (Resource Acquisition Is Initialization)](#rr-raii)\n  * [R.2: In interfaces, use raw pointers to denote individual objects (only)](#rr-use-ptr)\n  * [R.3: A raw pointer (a `T*`) is non-owning](#rr-ptr)\n  * [R.4: A raw reference (a `T&`) is non-owning](#rr-ref)\n  * [R.5: Prefer scoped objects, don't heap-allocate unnecessarily](#rr-scoped)\n  * [R.6: Avoid non-`const` global variables](#rr-global)\n\n* Allocation and deallocation rule summary:\n\n  * [R.10: Avoid `malloc()` and `free()`](#rr-mallocfree)\n  * [R.11: Avoid calling `new` and `delete` explicitly](#rr-newdelete)\n  * [R.12: Immediately give the result of an explicit resource allocation to a manager object](#rr-immediate-alloc)\n  * [R.13: Perform at most one explicit resource allocation in a single expression statement](#rr-single-alloc)\n  * [R.14: Avoid `[]` parameters, prefer `span`](#rr-ap)\n  * [R.15: Always overload matched allocation/deallocation pairs](#rr-pair)\n\n* <a name=\"rr-summary-smartptrs\"></a>Smart pointer rule summary:\n\n  * [R.20: Use `unique_ptr` or `shared_ptr` to represent ownership](#rr-owner)\n  * [R.21: Prefer `unique_ptr` over `shared_ptr` unless you need to share ownership](#rr-unique)\n  * [R.22: Use `make_shared()` to make `shared_ptr`s](#rr-make_shared)\n  * [R.23: Use `make_unique()` to make `unique_ptr`s](#rr-make_unique)\n  * [R.24: Use `std::weak_ptr` to break cycles of `shared_ptr`s](#rr-weak_ptr)\n  * [R.30: Take smart pointers as parameters only to explicitly express lifetime semantics](#rr-smartptrparam)\n  * [R.31: If you have non-`std` smart pointers, follow the basic pattern from `std`](#rr-smart)\n  * [R.32: Take a `unique_ptr<widget>` parameter to express that a function assumes ownership of a `widget`](#rr-uniqueptrparam)\n  * [R.33: Take a `unique_ptr<widget>&` parameter to express that a function reseats the `widget`](#rr-reseat)\n  * [R.34: Take a `shared_ptr<widget>` parameter to express shared ownership](#rr-sharedptrparam-owner)\n  * [R.35: Take a `shared_ptr<widget>&` parameter to express that a function might reseat the shared pointer](#rr-sharedptrparam)\n  * [R.36: Take a `const shared_ptr<widget>&` parameter to express that it might retain a reference count to the object ???](#rr-sharedptrparam-const)\n  * [R.37: Do not pass a pointer or reference obtained from an aliased smart pointer](#rr-smartptrget)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-raii\"></a>R.1: Manage resources automatically using resource handles and RAII (Resource Acquisition Is Initialization)",
    "content": "### <a name=\"rr-raii\"></a>R.1: Manage resources automatically using resource handles and RAII (Resource Acquisition Is Initialization)\n\n##### Reason\n\nTo avoid leaks and the complexity of manual resource management.\nC++'s language-enforced constructor/destructor symmetry mirrors the symmetry inherent in resource acquire/release function pairs such as `fopen`/`fclose`, `lock`/`unlock`, and `new`/`delete`.\nWhenever you deal with a resource that needs paired acquire/release function calls, encapsulate that resource in an object that enforces pairing for you -- acquire the resource in its constructor, and release it in its destructor.\n\n##### Example, bad\n\nConsider:\n\n    void send(X* x, string_view destination)\n    {\n        auto port = open_port(destination);\n        my_mutex.lock();\n        // ...\n        send(port, x);\n        // ...\n        my_mutex.unlock();\n        close_port(port);\n        delete x;\n    }\n\nIn this code, you have to remember to `unlock`, `close_port`, and `delete` on all paths, and do each exactly once.\nFurther, if any of the code marked `...` throws an exception, then `x` is leaked and `my_mutex` remains locked.\n\n##### Example\n\nConsider:\n\n    void send(unique_ptr<X> x, string_view destination)  // x owns the X\n    {\n        Port port{destination};            // port owns the PortHandle\n        lock_guard<mutex> guard{my_mutex}; // guard owns the lock\n        // ...\n        send(port, x);\n        // ...\n    } // automatically unlocks my_mutex and deletes the pointer in x\n\nNow all resource cleanup is automatic, performed once on all paths whether or not there is an exception. As a bonus, the function now advertises that it takes over ownership of the pointer.\n\nWhat is `Port`? A handy wrapper that encapsulates the resource:\n\n    class Port {\n        PortHandle port;\n    public:\n        Port(string_view destination) : port{open_port(destination)} { }\n        ~Port() { close_port(port); }\n        operator PortHandle() { return port; }\n\n        // port handles can't usually be cloned, so disable copying and assignment if necessary\n        Port(const Port&) = delete;\n        Port& operator=(const Port&) = delete;\n    };\n\n##### Note\n\nWhere a resource is \"ill-behaved\" in that it isn't represented as a class with a destructor, wrap it in a class or use [`finally`](#re-finally)\n\n**See also**: [RAII](#re-raii)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-use-ptr\"></a>R.2: In interfaces, use raw pointers to denote individual objects (only)",
    "content": "### <a name=\"rr-use-ptr\"></a>R.2: In interfaces, use raw pointers to denote individual objects (only)\n\n##### Reason\n\nArrays are best represented by a container type (e.g., `vector` (owning)) or a `span` (non-owning).\nSuch containers and views hold sufficient information to do range checking.\n\n##### Example, bad\n\n    void f(int* p, int n)   // n is the number of elements in p[]\n    {\n        // ...\n        p[2] = 7;   // bad: subscript raw pointer\n        // ...\n    }\n\nThe compiler does not read comments, and without reading other code you do not know whether `p` really points to `n` elements.\nUse a `span` instead.\n\n##### Example\n\n    void g(int* p, int fmt)   // print *p using format #fmt\n    {\n        // ... uses *p and p[0] only ...\n    }\n\n##### Exception\n\nC-style strings are passed as single pointers to a zero-terminated sequence of characters.\nUse `zstring` rather than `char*` to indicate that you rely on that convention.\n\n##### Note\n\nMany current uses of pointers to a single element could be references.\nHowever, where `nullptr` is a possible value, a reference might not be a reasonable alternative.\n\n##### Enforcement\n\n* Flag pointer arithmetic (including `++`) on a pointer that is not part of a container, view, or iterator.\n  This rule would generate a huge number of false positives if applied to an older code base.\n* Flag array names passed as simple pointers\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-ptr\"></a>R.3: A raw pointer (a `T*`) is non-owning",
    "content": "### <a name=\"rr-ptr\"></a>R.3: A raw pointer (a `T*`) is non-owning\n\n##### Reason\n\nThere is nothing (in the C++ standard or in most code) to say otherwise and most raw pointers are non-owning.\nWe want owning pointers identified so that we can reliably and efficiently delete the objects pointed to by owning pointers.\n\n##### Example\n\n    void f()\n    {\n        int* p1 = new int{7};           // bad: raw owning pointer\n        auto p2 = make_unique<int>(7);  // OK: the int is owned by a unique pointer\n        // ...\n    }\n\nThe `unique_ptr` protects against leaks by guaranteeing the deletion of its object (even in the presence of exceptions). The `T*` does not.\n\n##### Example\n\n    template<typename T>\n    class X {\n    public:\n        T* p;   // bad: it is unclear whether p is owning or not\n        T* q;   // bad: it is unclear whether q is owning or not\n        // ...\n    };\n\nWe can fix that problem by making ownership explicit:\n\n    template<typename T>\n    class X2 {\n    public:\n        owner<T*> p;  // OK: p is owning\n        T* q;         // OK: q is not owning\n        // ...\n    };\n\n##### Exception\n\nA major class of exception is legacy code, especially code that must remain compilable as C or interface with C and C-style C++ through ABIs.\nThe fact that there are billions of lines of code that violate this rule against owning `T*`s cannot be ignored.\nWe'd love to see program transformation tools turning 20-year-old \"legacy\" code into shiny modern code,\nwe encourage the development, deployment and use of such tools,\nwe hope the guidelines will help the development of such tools,\nand we even contributed (and contribute) to the research and development in this area.\nHowever, it will take time: \"legacy code\" is generated faster than we can renovate old code, and so it will be for a few years.\n\nThis code cannot all be rewritten (even assuming good code transformation software), especially not soon.\nThis problem cannot be solved (at scale) by transforming all owning pointers to `unique_ptr`s and `shared_ptr`s,\npartly because we need/use owning \"raw pointers\" as well as simple pointers in the implementation of our fundamental resource handles.\nFor example, common `vector` implementations have one owning pointer and two non-owning pointers.\nMany ABIs (and essentially all interfaces to C code) use `T*`s, some of them owning.\nSome interfaces cannot be simply annotated with `owner` because they need to remain compilable as C\n(although this would be a rare good use for a macro, that expands to `owner` in C++ mode only).\n\n##### Note\n\n`owner<T*>` has no default semantics beyond `T*`. It can be used without changing any code using it and without affecting ABIs.\nIt is simply an indicator to programmers and analysis tools.\nFor example, if an `owner<T*>` is a member of a class, that class better have a destructor that `delete`s it.\n\n##### Example, bad\n\nReturning a (raw) pointer imposes a lifetime management uncertainty on the caller; that is, who deletes the pointed-to object?\n\n    Gadget* make_gadget(int n)\n    {\n        auto p = new Gadget{n};\n        // ...\n        return p;\n    }\n\n    void caller(int n)\n    {\n        auto p = make_gadget(n);   // remember to delete p\n        // ...\n        delete p;\n    }\n\nIn addition to suffering from the problem of [leak](#rp-leak), this adds a spurious allocation and deallocation operation, and is needlessly verbose. If Gadget is cheap to move out of a function (i.e., is small or has an efficient move operation), just return it \"by value\" (see [\"out\" return values](#rf-out)):\n\n    Gadget make_gadget(int n)\n    {\n        Gadget g{n};\n        // ...\n        return g;\n    }\n\n##### Note\n\nThis rule applies to factory functions.\n\n##### Note\n\nIf pointer semantics are required (e.g., because the return type needs to refer to a base class of a class hierarchy (an interface)), return a \"smart pointer.\"\n\n##### Enforcement\n\n* (Simple) Warn on `delete` of a raw pointer that is not an `owner<T>`.\n* (Moderate) Warn on failure to either `reset` or explicitly `delete` an `owner<T>` pointer on every code path.\n* (Simple) Warn if the return value of `new` is assigned to a raw pointer.\n* (Simple) Warn if a function returns an object that was allocated within the function but has a move constructor.\n  Suggest considering returning it by value instead.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-ref\"></a>R.4: A raw reference (a `T&`) is non-owning",
    "content": "### <a name=\"rr-ref\"></a>R.4: A raw reference (a `T&`) is non-owning\n\n##### Reason\n\nThere is nothing (in the C++ standard or in most code) to say otherwise and most raw references are non-owning.\nWe want owners identified so that we can reliably and efficiently delete the objects pointed to by owning pointers.\n\n##### Example\n\n    void f()\n    {\n        int& r = *new int{7};  // bad: raw owning reference\n        // ...\n        delete &r;             // bad: violated the rule against deleting raw pointers\n    }\n\n**See also**: [The raw pointer rule](#rr-ptr)\n\n##### Enforcement\n\nSee [the raw pointer rule](#rr-ptr)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-scoped\"></a>R.5: Prefer scoped objects, don't heap-allocate unnecessarily",
    "content": "### <a name=\"rr-scoped\"></a>R.5: Prefer scoped objects, don't heap-allocate unnecessarily\n\n##### Reason\n\nA scoped object is a local object, a global object, or a member.\nThis implies that there is no separate allocation and deallocation cost in excess of that already used for the containing scope or object.\nThe members of a scoped object are themselves scoped and the scoped object's constructor and destructor manage the members' lifetimes.\n\n##### Example\n\nThe following example is inefficient (because it has unnecessary allocation and deallocation), vulnerable to exception throws and returns in the `...` part (leading to leaks), and verbose:\n\n    void f(int n)\n    {\n        auto p = new Gadget{n};\n        // ...\n        delete p;\n    }\n\nInstead, use a local variable:\n\n    void f(int n)\n    {\n        Gadget g{n};\n        // ...\n    }\n\n##### Enforcement\n\n* (Moderate) Warn if an object is allocated and then deallocated on all paths within a function. Suggest it should be a local stack object instead.\n* (Simple) Warn if a local `Unique_pointer` or `Shared_pointer` that is not moved, copied, reassigned or `reset` before its lifetime ends is not declared `const`.\nException: Do not produce such a warning on a local `Unique_pointer` to an unbounded array. (See below.)\n\n##### Exception\n\nIf your stack space is limited, it is OK to create a local `const unique_ptr<BigObject>` to store the object on the heap instead of the stack.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-global\"></a>R.6: Avoid non-`const` global variables",
    "content": "### <a name=\"rr-global\"></a>R.6: Avoid non-`const` global variables\n\nSee [I.2](#ri-global)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-alloc\"></a>R.alloc: Allocation and deallocation",
    "content": "## <a name=\"ss-alloc\"></a>R.alloc: Allocation and deallocation\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-mallocfree\"></a>R.10: Avoid `malloc()` and `free()`",
    "content": "### <a name=\"rr-mallocfree\"></a>R.10: Avoid `malloc()` and `free()`\n\n##### Reason\n\n `malloc()` and `free()` do not support construction and destruction, and do not mix well with `new` and `delete`.\n\n##### Example\n\n    class Record {\n        int id;\n        string name;\n        // ...\n    };\n\n    void use()\n    {\n        // p1 might be nullptr\n        // *p1 is not initialized; in particular,\n        // that string isn't a string, but a string-sized bag of bits\n        Record* p1 = static_cast<Record*>(malloc(sizeof(Record)));\n\n        auto p2 = new Record;\n\n        // unless an exception is thrown, *p2 is default initialized\n        auto p3 = new(nothrow) Record;\n        // p3 might be nullptr; if not, *p3 is default initialized\n\n        // ...\n\n        delete p1;    // error: cannot delete object allocated by malloc()\n        free(p2);    // error: cannot free() object allocated by new\n    }\n\nIn some implementations that `delete` and that `free()` might work, or maybe they will cause run-time errors.\n\n##### Exception\n\nThere are applications and sections of code where exceptions are not acceptable.\nSome of the best such examples are in life-critical hard-real-time code.\nBeware that many bans on exception use are based on superstition (bad)\nor by concerns for older code bases with unsystematic resource management (unfortunately, but sometimes necessary).\nIn such cases, consider the `nothrow` versions of `new`.\n\n##### Enforcement\n\nFlag explicit use of `malloc` and `free`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-newdelete\"></a>R.11: Avoid calling `new` and `delete` explicitly",
    "content": "### <a name=\"rr-newdelete\"></a>R.11: Avoid calling `new` and `delete` explicitly\n\n##### Reason\n\nThe pointer returned by `new` should belong to a resource handle (that can call `delete`).\nIf the pointer returned by `new` is assigned to a plain/naked pointer, the object can be leaked.\n\n##### Note\n\nIn a large program, a naked `delete` (that is a `delete` in application code, rather than part of code devoted to resource management)\nis a likely bug: if you have N `delete`s, how can you be certain that you don't need N+1 or N-1?\nThe bug might be latent: it might emerge only during maintenance.\nIf you have a naked `new`, you probably need a naked `delete` somewhere, so you probably have a bug.\n\n##### Enforcement\n\n(Simple) Warn on any explicit use of `new` and `delete`. Suggest using `make_unique` instead.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-immediate-alloc\"></a>R.12: Immediately give the result of an explicit resource allocation to a manager object",
    "content": "### <a name=\"rr-immediate-alloc\"></a>R.12: Immediately give the result of an explicit resource allocation to a manager object\n\n##### Reason\n\nIf you don't, an exception or a return might lead to a leak.\n\n##### Example, bad\n\n    void func(const string& name)\n    {\n        FILE* f = fopen(name, \"r\");            // open the file\n        vector<char> buf(1024);\n        auto _ = finally([f] { fclose(f); });  // remember to close the file\n        // ...\n    }\n\nThe allocation of `buf` might fail and leak the file handle.\n\n##### Example\n\n    void func(const string& name)\n    {\n        ifstream f{name};   // open the file\n        vector<char> buf(1024);\n        // ...\n    }\n\nThe use of the file handle (in `ifstream`) is simple, efficient, and safe.\n\n##### Enforcement\n\n* Flag explicit allocations used to initialize pointers (problem: how many direct resource allocations can we recognize?)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-single-alloc\"></a>R.13: Perform at most one explicit resource allocation in a single expression statement",
    "content": "### <a name=\"rr-single-alloc\"></a>R.13: Perform at most one explicit resource allocation in a single expression statement\n\n##### Reason\n\nIf you perform two explicit resource allocations in one statement, you could leak resources because the order of evaluation of many subexpressions, including function arguments, is unspecified.\n\n##### Example\n\n    void fun(shared_ptr<Widget> sp1, shared_ptr<Widget> sp2);\n\nThis `fun` can be called like this:\n\n    // BAD: potential leak\n    fun(shared_ptr<Widget>(new Widget(a, b)), shared_ptr<Widget>(new Widget(c, d)));\n\nThis is exception-unsafe because the compiler might reorder the two expressions building the function's two arguments.\nIn particular, the compiler can interleave execution of the two expressions:\nMemory allocation (by calling `operator new`) could be done first for both objects, followed by attempts to call the two `Widget` constructors.\nIf one of the constructor calls throws an exception, then the other object's memory will never be released!\n\nThis subtle problem has a simple solution: Never perform more than one explicit resource allocation in a single expression statement.\nFor example:\n\n    shared_ptr<Widget> sp1(new Widget(a, b)); // Better, but messy\n    fun(sp1, new Widget(c, d));\n\nThe best solution is to avoid explicit allocation entirely, use factory functions that return owning objects:\n\n    fun(make_shared<Widget>(a, b), make_shared<Widget>(c, d)); // Best\n\nWrite your own factory wrapper if there is not one already.\n\n##### Enforcement\n\n* Flag expressions with multiple explicit resource allocations (problem: how many direct resource allocations can we recognize?)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-ap\"></a>R.14: Avoid `[]` parameters, prefer `span`",
    "content": "### <a name=\"rr-ap\"></a>R.14: Avoid `[]` parameters, prefer `span`\n\n##### Reason\n\nAn array decays to a pointer, thereby losing its size, opening the opportunity for range errors.\nUse `span` to preserve size information.\n\n##### Example\n\n    void f(int[]);          // not recommended\n\n    void f(int*);           // not recommended for multiple objects\n                            // (a pointer should point to a single object, do not subscript)\n\n    void f(gsl::span<int>); // good, recommended\n\n##### Enforcement\n\nFlag `[]` parameters. Use `span` instead.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-pair\"></a>R.15: Always overload matched allocation/deallocation pairs",
    "content": "### <a name=\"rr-pair\"></a>R.15: Always overload matched allocation/deallocation pairs\n\n##### Reason\n\nOtherwise you get mismatched operations and chaos.\n\n##### Example\n\n    class X {\n        // ...\n        void* operator new(size_t s);\n        void operator delete(void*);\n        // ...\n    };\n\n##### Note\n\nIf you want memory that cannot be deallocated, `=delete` the deallocation operation.\nDon't leave it undeclared.\n\n##### Enforcement\n\nFlag incomplete pairs.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-smart\"></a>R.smart: Smart pointers",
    "content": "## <a name=\"ss-smart\"></a>R.smart: Smart pointers\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-owner\"></a>R.20: Use `unique_ptr` or `shared_ptr` to represent ownership",
    "content": "### <a name=\"rr-owner\"></a>R.20: Use `unique_ptr` or `shared_ptr` to represent ownership\n\n##### Reason\n\nThey can prevent resource leaks.\n\n##### Example\n\nConsider:\n\n    void f()\n    {\n        X* p1 { new X };              // bad, p1 will leak\n        auto p2 = make_unique<X>();   // good, unique ownership\n        auto p3 = make_shared<X>();   // good, shared ownership\n    }\n\nThis will leak the object used to initialize `p1` (only).\n\n##### Enforcement\n\n* (Simple) Warn if the return value of `new` is assigned to a raw pointer.\n* (Simple) Warn if the result of a function returning a raw owning pointer is assigned to a raw pointer.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-unique\"></a>R.21: Prefer `unique_ptr` over `shared_ptr` unless you need to share ownership",
    "content": "### <a name=\"rr-unique\"></a>R.21: Prefer `unique_ptr` over `shared_ptr` unless you need to share ownership\n\n##### Reason\n\nA `unique_ptr` is conceptually simpler and more predictable (you know when destruction happens) and faster (you don't implicitly maintain a use count).\n\n##### Example, bad\n\nThis needlessly adds and maintains a reference count.\n\n    void f()\n    {\n        shared_ptr<Base> base = make_shared<Derived>();\n        // use base locally, without copying it -- refcount never exceeds 1\n    } // destroy base\n\n##### Example\n\nThis is more efficient:\n\n    void f()\n    {\n        unique_ptr<Base> base = make_unique<Derived>();\n        // use base locally\n    } // destroy base\n\n##### Enforcement\n\n(Simple) Warn if a function uses a `Shared_pointer` with an object allocated within the function, but never returns the `Shared_pointer` or passes it to a function requiring a `Shared_pointer`. Suggest using `unique_ptr` instead.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-make_shared\"></a>R.22: Use `make_shared()` to make `shared_ptr`s",
    "content": "### <a name=\"rr-make_shared\"></a>R.22: Use `make_shared()` to make `shared_ptr`s\n\n##### Reason\n\n`make_shared` gives a more concise statement of the construction.\nIt also gives an opportunity to eliminate a separate allocation for the reference counts, by placing the `shared_ptr`'s use counts next to its object.\nIt also ensures exception safety in complex expressions (in pre-C++17 code).\n\n##### Example\n\nConsider:\n\n    shared_ptr<X> p1 { new X{2} }; // bad\n    auto p = make_shared<X>(2);    // good\n\nThe `make_shared()` version mentions `X` only once, so it is usually shorter (as well as faster) than the version with the explicit `new`.\n\n##### Enforcement\n\n(Simple) Warn if a `shared_ptr` is constructed from the result of `new` rather than `make_shared`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-make_unique\"></a>R.23: Use `make_unique()` to make `unique_ptr`s",
    "content": "### <a name=\"rr-make_unique\"></a>R.23: Use `make_unique()` to make `unique_ptr`s\n\n##### Reason\n\n`make_unique` gives a more concise statement of the construction.\nIt also ensures exception safety in complex expressions (in pre-C++17 code).\n\n##### Example\n\n    unique_ptr<Foo> p {new Foo{7}};    // OK: but repetitive\n\n    auto q = make_unique<Foo>(7);      // Better: no repetition of Foo\n\n##### Enforcement\n\n(Simple) Warn if a `unique_ptr` is constructed from the result of `new` rather than `make_unique`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-weak_ptr\"></a>R.24: Use `std::weak_ptr` to break cycles of `shared_ptr`s",
    "content": "### <a name=\"rr-weak_ptr\"></a>R.24: Use `std::weak_ptr` to break cycles of `shared_ptr`s\n\n##### Reason\n\n `shared_ptr`s rely on use counting and the use count for a cyclic structure never goes to zero, so we need a mechanism to\nbe able to destroy a cyclic structure.\n\n##### Example\n\n    #include <memory>\n\n    class bar;\n\n    class foo {\n    public:\n      explicit foo(const std::shared_ptr<bar>& forward_reference)\n        : forward_reference_(forward_reference)\n      { }\n    private:\n      std::shared_ptr<bar> forward_reference_;\n    };\n\n    class bar {\n    public:\n      explicit bar(const std::weak_ptr<foo>& back_reference)\n        : back_reference_(back_reference)\n      { }\n      void do_something()\n      {\n        if (auto shared_back_reference = back_reference_.lock()) {\n          // Use *shared_back_reference\n        }\n      }\n    private:\n      std::weak_ptr<foo> back_reference_;\n    };\n\n##### Note\n\n ??? (HS: A lot of people say \"to break cycles\", while I think \"temporary shared ownership\" is more to the point.)\n???(BS: breaking cycles is what you must do; temporarily sharing ownership is how you do it.\nYou could \"temporarily share ownership\" simply by using another `shared_ptr`.)\n\n##### Enforcement\n\n??? probably impossible. If we could statically detect cycles, we wouldn't need `weak_ptr`\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-smartptrparam\"></a>R.30: Take smart pointers as parameters only to explicitly express lifetime semantics",
    "content": "### <a name=\"rr-smartptrparam\"></a>R.30: Take smart pointers as parameters only to explicitly express lifetime semantics\n\nSee [F.7](#rf-smart).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-smart\"></a>R.31: If you have non-`std` smart pointers, follow the basic pattern from `std`",
    "content": "### <a name=\"rr-smart\"></a>R.31: If you have non-`std` smart pointers, follow the basic pattern from `std`\n\n##### Reason\n\nThe rules in the following section also work for other kinds of third-party and custom smart pointers and are very useful for diagnosing common smart pointer errors that cause performance and correctness problems.\nYou want the rules to work on all the smart pointers you use.\n\nAny type (including primary template or specialization) that overloads unary `*` and `->` is considered a smart pointer:\n\n* If it is copyable, it is recognized as a reference-counted `shared_ptr`.\n* If it is not copyable, it is recognized as a unique `unique_ptr`.\n\n##### Example, bad\n\n    // use Boost's intrusive_ptr\n    #include <boost/intrusive_ptr.hpp>\n    void f(boost::intrusive_ptr<widget> p)  // error under rule 'sharedptrparam'\n    {\n        p->foo();\n    }\n\n    // use Microsoft's CComPtr\n    #include <atlbase.h>\n    void f(CComPtr<widget> p)               // error under rule 'sharedptrparam'\n    {\n        p->foo();\n    }\n\nBoth cases are an error under the [`sharedptrparam` guideline](#rr-smartptrparam):\n`p` is a `Shared_pointer`, but nothing about its sharedness is used here and passing it by value is a silent pessimization;\nthese functions should accept a smart pointer only if they need to participate in the widget's lifetime management. Otherwise they should accept a `widget*`, if it can be `nullptr`. Otherwise, and ideally, the function should accept a `widget&`.\nThese smart pointers match the `Shared_pointer` concept, so these guideline enforcement rules work on them out of the box and expose this common pessimization.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-uniqueptrparam\"></a>R.32: Take a `unique_ptr<widget>` parameter to express that a function assumes ownership of a `widget`",
    "content": "### <a name=\"rr-uniqueptrparam\"></a>R.32: Take a `unique_ptr<widget>` parameter to express that a function assumes ownership of a `widget`\n\n##### Reason\n\nUsing `unique_ptr` in this way both documents and enforces the function call's ownership transfer.\n\n##### Example\n\n    void sink(unique_ptr<widget>); // takes ownership of the widget\n\n    void uses(widget*);            // just uses the widget\n\n##### Enforcement\n\n* (Simple) Warn if a function takes a `Unique_pointer<T>` parameter by lvalue reference and does not either assign to it or call `reset()` on it on at least one code path. Suggest taking a `T*` or `T&` instead.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-reseat\"></a>R.33: Take a `unique_ptr<widget>&` parameter to express that a function reseats the `widget`",
    "content": "### <a name=\"rr-reseat\"></a>R.33: Take a `unique_ptr<widget>&` parameter to express that a function reseats the `widget`\n\n##### Reason\n\nUsing `unique_ptr` in this way both documents and enforces the function call's reseating semantics.\n\n##### Note\n\n\"reseat\" means \"making a pointer or a smart pointer refer to a different object.\"\n\n##### Example\n\n    void reseat(unique_ptr<widget>&); // \"will\" or \"might\" reseat pointer\n\n##### Enforcement\n\n* (Simple) Warn if a function takes a `Unique_pointer<T>` parameter by lvalue reference and does not either assign to it or call `reset()` on it on at least one code path. Suggest taking a `T*` or `T&` instead.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-sharedptrparam-owner\"></a>R.34: Take a `shared_ptr<widget>` parameter to express shared ownership",
    "content": "### <a name=\"rr-sharedptrparam-owner\"></a>R.34: Take a `shared_ptr<widget>` parameter to express shared ownership\n\n##### Reason\n\nThis makes the function's ownership sharing explicit.\n\n##### Example, good\n\n    class WidgetUser\n    {\n    public:\n        // WidgetUser will share ownership of the widget\n        explicit WidgetUser(std::shared_ptr<widget> w) noexcept:\n            m_widget{std::move(w)} {}\n        // ...\n    private:\n        std::shared_ptr<widget> m_widget;\n    };\n\n##### Enforcement\n\n* (Simple) Warn if a function takes a `Shared_pointer<T>` parameter by lvalue reference and does not either assign to it or call `reset()` on it on at least one code path. Suggest taking a `T*` or `T&` instead.\n* (Simple) ((Foundation)) Warn if a function takes a `Shared_pointer<T>` by value or by reference to `const` and does not copy or move it to another `Shared_pointer` on at least one code path. Suggest taking a `T*` or `T&` instead.\n* (Simple) ((Foundation)) Warn if a function takes a `Shared_pointer<T>` by rvalue reference. Suggesting taking it by value instead.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-sharedptrparam\"></a>R.35: Take a `shared_ptr<widget>&` parameter to express that a function might reseat the shared pointer",
    "content": "### <a name=\"rr-sharedptrparam\"></a>R.35: Take a `shared_ptr<widget>&` parameter to express that a function might reseat the shared pointer\n\n##### Reason\n\nThis makes the function's reseating explicit.\n\n##### Note\n\n\"reseat\" means \"making a reference or a smart pointer refer to a different object.\"\n\n##### Example, good\n\n    void ChangeWidget(std::shared_ptr<widget>& w)\n    {\n        // This will change the callers widget\n        w = std::make_shared<widget>(widget{});\n    }\n\n##### Enforcement\n\n* (Simple) Warn if a function takes a `Shared_pointer<T>` parameter by lvalue reference and does not either assign to it or call `reset()` on it on at least one code path. Suggest taking a `T*` or `T&` instead.\n* (Simple) ((Foundation)) Warn if a function takes a `Shared_pointer<T>` by value or by reference to `const` and does not copy or move it to another `Shared_pointer` on at least one code path. Suggest taking a `T*` or `T&` instead.\n* (Simple) ((Foundation)) Warn if a function takes a `Shared_pointer<T>` by rvalue reference. Suggesting taking it by value instead.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-sharedptrparam-const\"></a>R.36: Take a `const shared_ptr<widget>&` parameter to express that it might retain a reference count to the object ???",
    "content": "### <a name=\"rr-sharedptrparam-const\"></a>R.36: Take a `const shared_ptr<widget>&` parameter to express that it might retain a reference count to the object ???\n\n##### Reason\n\nThis makes the function's ??? explicit.\n\n##### Example, good\n\n    void share(shared_ptr<widget>);            // share -- \"will\" retain refcount\n\n    void reseat(shared_ptr<widget>&);          // \"might\" reseat ptr\n\n    void may_share(const shared_ptr<widget>&); // \"might\" retain refcount\n\n##### Enforcement\n\n* (Simple) Warn if a function takes a `Shared_pointer<T>` parameter by lvalue reference and does not either assign to it or call `reset()` on it on at least one code path. Suggest taking a `T*` or `T&` instead.\n* (Simple) ((Foundation)) Warn if a function takes a `Shared_pointer<T>` by value or by reference to `const` and does not copy or move it to another `Shared_pointer` on at least one code path. Suggest taking a `T*` or `T&` instead.\n* (Simple) ((Foundation)) Warn if a function takes a `Shared_pointer<T>` by rvalue reference. Suggesting taking it by value instead.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rr-smartptrget\"></a>R.37: Do not pass a pointer or reference obtained from an aliased smart pointer",
    "content": "### <a name=\"rr-smartptrget\"></a>R.37: Do not pass a pointer or reference obtained from an aliased smart pointer\n\n##### Reason\n\nViolating this rule is the number one cause of losing reference counts and finding yourself with a dangling pointer.\nFunctions should prefer to pass raw pointers and references down call chains.\nAt the top of the call tree where you obtain the raw pointer or reference from a smart pointer that keeps the object alive.\nYou need to be sure that the smart pointer cannot inadvertently be reset or reassigned from within the call tree below.\n\n##### Note\n\nTo do this, sometimes you need to take a local copy of a smart pointer, which firmly keeps the object alive for the duration of the function and the call tree.\n\n##### Example\n\nConsider this code:\n\n    // global (static or heap), or aliased local ...\n    shared_ptr<widget> g_p = ...;\n\n    void f(widget& w)\n    {\n        g();\n        use(w);  // A\n    }\n\n    void g()\n    {\n        g_p = ...; // oops, if this was the last shared_ptr to that widget, destroys the widget\n    }\n\nThe following should not pass code review:\n\n    void my_code()\n    {\n        // BAD: passing pointer or reference obtained from a non-local smart pointer\n        //      that could be inadvertently reset somewhere inside f or its callees\n        f(*g_p);\n\n        // BAD: same reason, just passing it as a \"this\" pointer\n        g_p->func();\n    }\n\nThe fix is simple -- take a local copy of the pointer to \"keep a ref count\" for your call tree:\n\n    void my_code()\n    {\n        // cheap: 1 increment covers this entire function and all the call trees below us\n        auto pin = g_p;\n\n        // GOOD: passing pointer or reference obtained from a local unaliased smart pointer\n        f(*pin);\n\n        // GOOD: same reason\n        pin->func();\n    }\n\n##### Enforcement\n\n* (Simple) Warn if a pointer or reference obtained from a smart pointer variable (`Unique_pointer` or `Shared_pointer`) that is non-local, or that is local but potentially aliased, is used in a function call. If the smart pointer is a `Shared_pointer` then suggest taking a local copy of the smart pointer and obtain a pointer or reference from that instead.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-expr\"></a>ES: Expressions and statements",
    "content": "# <a name=\"s-expr\"></a>ES: Expressions and statements\n\nExpressions and statements are the lowest and most direct way of expressing actions and computation. Declarations in local scopes are statements.\n\nFor naming, commenting, and indentation rules, see [NL: Naming and layout](#s-naming).\n\nGeneral rules:\n\n* [ES.1: Prefer the standard library to other libraries and to \"handcrafted code\"](#res-lib)\n* [ES.2: Prefer suitable abstractions to direct use of language features](#res-abstr)\n* [ES.3: Don't repeat yourself, avoid redundant code](#res-dry)\n\nDeclaration rules:\n\n* [ES.5: Keep scopes small](#res-scope)\n* [ES.6: Declare names in for-statement initializers and conditions to limit scope](#res-cond)\n* [ES.7: Keep common and local names short, and keep uncommon and non-local names longer](#res-name-length)\n* [ES.8: Avoid similar-looking names](#res-name-similar)\n* [ES.9: Avoid `ALL_CAPS` names](#res-not-caps)\n* [ES.10: Declare one name (only) per declaration](#res-name-one)\n* [ES.11: Use `auto` to avoid redundant repetition of type names](#res-auto)\n* [ES.12: Do not reuse names in nested scopes](#res-reuse)\n* [ES.20: Always initialize an object](#res-always)\n* [ES.21: Don't introduce a variable (or constant) before you need to use it](#res-introduce)\n* [ES.22: Don't declare a variable until you have a value to initialize it with](#res-init)\n* [ES.23: Prefer the `{}`-initializer syntax](#res-list)\n* [ES.24: Use a `unique_ptr<T>` to hold pointers](#res-unique)\n* [ES.25: Declare an object `const` or `constexpr` unless you want to modify its value later on](#res-const)\n* [ES.26: Don't use a variable for two unrelated purposes](#res-recycle)\n* [ES.27: Use `std::array` or `stack_array` for arrays on the stack](#res-stack)\n* [ES.28: Use lambdas for complex initialization, especially of `const` variables](#res-lambda-init)\n* [ES.30: Don't use macros for program text manipulation](#res-macros)\n* [ES.31: Don't use macros for constants or \"functions\"](#res-macros2)\n* [ES.32: Use `ALL_CAPS` for all macro names](#res-all_caps)\n* [ES.33: If you must use macros, give them unique names](#res-macros3)\n* [ES.34: Don't define a (C-style) variadic function](#res-ellipses)\n\nExpression rules:\n\n* [ES.40: Avoid complicated expressions](#res-complicated)\n* [ES.41: If in doubt about operator precedence, parenthesize](#res-parens)\n* [ES.42: Keep use of pointers simple and straightforward](#res-ptr)\n* [ES.43: Avoid expressions with undefined order of evaluation](#res-order)\n* [ES.44: Don't depend on order of evaluation of function arguments](#res-order-fct)\n* [ES.45: Avoid \"magic constants\"; use symbolic constants](#res-magic)\n* [ES.46: Avoid narrowing conversions](#res-narrowing)\n* [ES.47: Use `nullptr` rather than `0` or `NULL`](#res-nullptr)\n* [ES.48: Avoid casts](#res-casts)\n* [ES.49: If you must use a cast, use a named cast](#res-casts-named)\n* [ES.50: Don't cast away `const`](#res-casts-const)\n* [ES.55: Avoid the need for range checking](#res-range-checking)\n* [ES.56: Write `std::move()` only when you need to explicitly move an object to another scope](#res-move)\n* [ES.60: Avoid `new` and `delete` outside resource management functions](#res-new)\n* [ES.61: Delete arrays using `delete[]` and non-arrays using `delete`](#res-del)\n* [ES.62: Don't compare pointers into different arrays](#res-arr2)\n* [ES.63: Don't slice](#res-slice)\n* [ES.64: Use the `T{e}`notation for construction](#res-construct)\n* [ES.65: Don't dereference an invalid pointer](#res-deref)\n\nStatement rules:\n\n* [ES.70: Prefer a `switch`-statement to an `if`-statement when there is a choice](#res-switch-if)\n* [ES.71: Prefer a range-`for`-statement to a `for`-statement when there is a choice](#res-for-range)\n* [ES.72: Prefer a `for`-statement to a `while`-statement when there is an obvious loop variable](#res-for-while)\n* [ES.73: Prefer a `while`-statement to a `for`-statement when there is no obvious loop variable](#res-while-for)\n* [ES.74: Prefer to declare a loop variable in the initializer part of a `for`-statement](#res-for-init)\n* [ES.75: Avoid `do`-statements](#res-do)\n* [ES.76: Avoid `goto`](#res-goto)\n* [ES.77: Minimize the use of `break` and `continue` in loops](#res-continue)\n* [ES.78: Don't rely on implicit fallthrough in `switch` statements](#res-break)\n* [ES.79: Use `default` to handle common cases (only)](#res-default)\n* [ES.84: Don't try to declare a local variable with no name](#res-noname)\n* [ES.85: Make empty statements visible](#res-empty)\n* [ES.86: Avoid modifying loop control variables inside the body of raw for-loops](#res-loop-counter)\n* [ES.87: Don't add redundant `==` or `!=` to conditions](#res-if)\n\nArithmetic rules:\n\n* [ES.100: Don't mix signed and unsigned arithmetic](#res-mix)\n* [ES.101: Use unsigned types for bit manipulation](#res-unsigned)\n* [ES.102: Use signed types for arithmetic](#res-signed)\n* [ES.103: Don't overflow](#res-overflow)\n* [ES.104: Don't underflow](#res-underflow)\n* [ES.105: Don't divide by integer zero](#res-zero)\n* [ES.106: Don't try to avoid negative values by using `unsigned`](#res-nonnegative)\n* [ES.107: Don't use `unsigned` for subscripts, prefer `gsl::index`](#res-subscripts)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-lib\"></a>ES.1: Prefer the standard library to other libraries and to \"handcrafted code\"",
    "content": "### <a name=\"res-lib\"></a>ES.1: Prefer the standard library to other libraries and to \"handcrafted code\"\n\n##### Reason\n\nCode using a library can be much easier to write than code working directly with language features, much shorter, tend to be of a higher level of abstraction, and the library code is presumably already tested.\nThe ISO C++ Standard Library is among the most widely known and best tested libraries.\nIt is available as part of all C++ implementations.\n\n##### Example\n\n    auto sum = accumulate(begin(a), end(a), 0.0);   // good\n\na range version of `accumulate` would be even better:\n\n    auto sum = accumulate(v, 0.0); // better\n\nbut don't hand-code a well-known algorithm:\n\n    int max = v.size();   // bad: verbose, purpose unstated\n    double sum = 0.0;\n    for (int i = 0; i < max; ++i)\n        sum = sum + v[i];\n\n##### Exception\n\nLarge parts of the standard library rely on dynamic allocation (free store). These parts, notably the containers but not the algorithms, are unsuitable for some hard-real-time and embedded applications. In such cases, consider providing/using similar facilities, e.g.,  a standard-library-style container implemented using a pool allocator.\n\n##### Enforcement\n\nNot easy. ??? Look for messy loops, nested loops, long functions, absence of function calls, lack of use of built-in types. Cyclomatic complexity?\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-abstr\"></a>ES.2: Prefer suitable abstractions to direct use of language features",
    "content": "### <a name=\"res-abstr\"></a>ES.2: Prefer suitable abstractions to direct use of language features\n\n##### Reason\n\nA \"suitable abstraction\" (e.g., library or class) is closer to the application concepts than the bare language, leads to shorter and clearer code, and is likely to be better tested.\n\n##### Example\n\n    vector<string> read1(istream& is)   // good\n    {\n        vector<string> res;\n        for (string s; is >> s;)\n            res.push_back(s);\n        return res;\n    }\n\nThe more traditional and lower-level near-equivalent is longer, messier, harder to get right, and most likely slower:\n\n    char** read2(istream& is, int maxelem, int maxstring, int* nread)   // bad: verbose and incomplete\n    {\n        auto res = new char*[maxelem];\n        int elemcount = 0;\n        while (is && elemcount < maxelem) {\n            auto s = new char[maxstring];\n            is.read(s, maxstring);\n            res[elemcount++] = s;\n        }\n        *nread = elemcount;\n        return res;\n    }\n\nOnce the checking for overflow and error handling has been added that code gets quite messy, and there is the problem remembering to `delete` the returned pointer and the C-style strings that array contains.\n\n##### Enforcement\n\nNot easy. ??? Look for messy loops, nested loops, long functions, absence of function calls, lack of use of built-in types. Cyclomatic complexity?\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-dry\"></a>ES.3: Don't repeat yourself, avoid redundant code",
    "content": "### <a name=\"res-dry\"></a>ES.3: Don't repeat yourself, avoid redundant code\n\nDuplicated or otherwise redundant code obscures intent, makes it harder to understand the logic, and makes maintenance harder, among other problems. It often arises from cut-and-paste programming.\n\nUse standard algorithms where appropriate, instead of writing some own implementation.\n\n**See also**: [SL.1](#rsl-lib), [ES.11](#res-auto)\n\n##### Example\n\n    void func(bool flag)    // Bad, duplicated code.\n    {\n        if (flag) {\n            x();\n            y();\n        }\n        else {\n            x();\n            z();\n        }\n    }\n\n    void func(bool flag)    // Better, no duplicated code.\n    {\n        x();\n\n        if (flag)\n            y();\n        else\n            z();\n    }\n\n\n##### Enforcement\n\n* Use a static analyzer. It will catch at least some redundant constructs.\n* Code review\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "ES.dcl: Declarations",
    "content": "## ES.dcl: Declarations\n\nA declaration is a statement. A declaration introduces a name into a scope and might cause the construction of a named object.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-scope\"></a>ES.5: Keep scopes small",
    "content": "### <a name=\"res-scope\"></a>ES.5: Keep scopes small\n\n##### Reason\n\nReadability. Minimize resource retention. Avoid accidental misuse of value.\n\n**Alternative formulation**: Don't declare a name in an unnecessarily large scope.\n\n##### Example\n\n    void use()\n    {\n        int i;    // bad: i is needlessly accessible after loop\n        for (i = 0; i < 20; ++i) { /* ... */ }\n        // no intended use of i here\n        for (int i = 0; i < 20; ++i) { /* ... */ }  // good: i is local to for-loop\n\n        if (auto pc = dynamic_cast<Circle*>(ps)) {  // good: pc is local to if-statement\n            // ... deal with Circle ...\n        }\n        else {\n            // ... handle error ...\n        }\n    }\n\n##### Example, bad\n\n    void use(const string& name)\n    {\n        string fn = name + \".txt\";\n        ifstream is {fn};\n        Record r;\n        is >> r;\n        // ... 200 lines of code without intended use of fn or is ...\n    }\n\nThis function is by most measures too long anyway, but the point is that the resources used by `fn` and the file handle held by `is`\nare retained for much longer than needed and that unanticipated use of `is` and `fn` could happen later in the function.\nIn this case, it might be a good idea to factor out the read:\n\n    Record load_record(const string& name)\n    {\n        string fn = name + \".txt\";\n        ifstream is {fn};\n        Record r;\n        is >> r;\n        return r;\n    }\n\n    void use(const string& name)\n    {\n        Record r = load_record(name);\n        // ... 200 lines of code ...\n    }\n\n##### Enforcement\n\n* Flag loop variable declared outside a loop and not used after the loop\n* Flag when expensive resources, such as file handles and locks are not used for N-lines (for some suitable N)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-cond\"></a>ES.6: Declare names in for-statement initializers and conditions to limit scope",
    "content": "### <a name=\"res-cond\"></a>ES.6: Declare names in for-statement initializers and conditions to limit scope\n\n##### Reason\n\nReadability.\nLimit the loop variable visibility to the scope of the loop.\nAvoid using the loop variable for other purposes after the loop.\nMinimize resource retention.\n\n##### Example\n\n    void use()\n    {\n        for (string s; cin >> s;)\n            v.push_back(s);\n\n        for (int i = 0; i < 20; ++i) {   // good: i is local to for-loop\n            // ...\n        }\n\n        if (auto pc = dynamic_cast<Circle*>(ps)) {   // good: pc is local to if-statement\n            // ... deal with Circle ...\n        }\n        else {\n            // ... handle error ...\n        }\n    }\n\n##### Example, don't\n\n    int j;                            // BAD: j is visible outside the loop\n    for (j = 0; j < 100; ++j) {\n        // ...\n    }\n    // j is still visible here and isn't needed\n\n**See also**: [Don't use a variable for two unrelated purposes](#res-recycle)\n\n##### Enforcement\n\n* Warn when a variable modified inside the `for`-statement is declared outside the loop and not being used outside the loop.\n* (hard) Flag loop variables declared before the loop and used after the loop for an unrelated purpose.\n\n**Discussion**: Scoping the loop variable to the loop body also helps code optimizers greatly. Recognizing that the induction variable\nis only accessible in the loop body unblocks optimizations such as hoisting, strength reduction, loop-invariant code motion, etc.\n\n##### C++17 and C++20 example\n\nNote: C++17 and C++20 also add `if`, `switch`, and range-`for` initializer statements. These require C++17 and C++20 support.\n\n    map<int, string> mymap;\n\n    if (auto result = mymap.insert(value); result.second) {\n        // insert succeeded, and result is valid for this block\n        use(result.first);  // ok\n        // ...\n    } // result is destroyed here\n\n##### C++17 and C++20 enforcement (if using a C++17 or C++20 compiler)\n\n* Flag selection/loop variables declared before the body and not used after the body\n* (hard) Flag selection/loop variables declared before the body and used after the body for an unrelated purpose.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-name-length\"></a>ES.7: Keep common and local names short, and keep uncommon and non-local names longer",
    "content": "### <a name=\"res-name-length\"></a>ES.7: Keep common and local names short, and keep uncommon and non-local names longer\n\n##### Reason\n\nReadability. Lowering the chance of clashes between unrelated non-local names.\n\n##### Example\n\nConventional short, local names increase readability:\n\n    template<typename T>    // good\n    void print(ostream& os, const vector<T>& v)\n    {\n        for (gsl::index i = 0; i < v.size(); ++i)\n            os << v[i] << '\\n';\n    }\n\nAn index is conventionally called `i` and there is no hint about the meaning of the vector in this generic function, so `v` is as good a name as any. Compare\n\n    template<typename Element_type>   // bad: verbose, hard to read\n    void print(ostream& target_stream, const vector<Element_type>& current_vector)\n    {\n        for (gsl::index current_element_index = 0;\n             current_element_index < current_vector.size();\n             ++current_element_index\n        )\n        target_stream << current_vector[current_element_index] << '\\n';\n    }\n\nYes, it is a caricature, but we have seen worse.\n\n##### Example\n\nUnconventional and short non-local names obscure code:\n\n    void use1(const string& s)\n    {\n        // ...\n        tt(s);   // bad: what is tt()?\n        // ...\n    }\n\nBetter, give non-local entities readable names:\n\n    void use1(const string& s)\n    {\n        // ...\n        trim_tail(s);   // better\n        // ...\n    }\n\nHere, there is a chance that the reader knows what `trim_tail` means and that the reader can remember it after looking it up.\n\n##### Example, bad\n\nArgument names of large functions are de facto non-local and should be meaningful:\n\n    void complicated_algorithm(vector<Record>& vr, const vector<int>& vi, map<string, int>& out)\n    // read from events in vr (marking used Records) for the indices in\n    // vi placing (name, index) pairs into out\n    {\n        // ... 500 lines of code using vr, vi, and out ...\n    }\n\nWe recommend keeping functions short, but that rule isn't universally adhered to and naming should reflect that.\n\n##### Enforcement\n\nCheck length of local and non-local names. Also take function length into account.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-name-similar\"></a>ES.8: Avoid similar-looking names",
    "content": "### <a name=\"res-name-similar\"></a>ES.8: Avoid similar-looking names\n\n##### Reason\n\nCode clarity and readability. Too-similar names slow down comprehension and increase the likelihood of error.\n\n##### Example, bad\n\n    if (readable(i1 + l1 + ol + o1 + o0 + ol + o1 + I0 + l0)) surprise();\n\n##### Example, bad\n\nDo not declare a non-type with the same name as a type in the same scope. This removes the need to disambiguate with a keyword such as `struct` or `enum`. It also removes a source of errors, as `struct X` can implicitly declare `X` if lookup fails.\n\n    struct foo { int n; };\n    struct foo foo();       // BAD, foo is a type already in scope\n    struct foo x = foo();   // requires disambiguation\n\n##### Exception\n\nAntique header files might declare non-types and types with the same name in the same scope.\n\n##### Enforcement\n\n* Check names against a list of known confusing letter and digit combinations.\n* Flag a declaration of a variable, function, or enumerator that hides a class or enumeration declared in the same scope.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-not-caps\"></a>ES.9: Avoid `ALL_CAPS` names",
    "content": "### <a name=\"res-not-caps\"></a>ES.9: Avoid `ALL_CAPS` names\n\n##### Reason\n\nSuch names are commonly used for macros. Thus, `ALL_CAPS` name are vulnerable to unintended macro substitution.\n\n##### Example\n\n    // somewhere in some header:\n    #define NE !=\n\n    // somewhere else in some other header:\n    enum Coord { N, NE, NW, S, SE, SW, E, W };\n\n    // somewhere third in some poor programmer's .cpp:\n    switch (direction) {\n    case N:\n        // ...\n    case NE:\n        // ...\n    // ...\n    }\n\n##### Note\n\nDo not use `ALL_CAPS` for constants just because constants used to be macros.\n\n##### Enforcement\n\nFlag all uses of ALL CAPS. For older code, accept ALL CAPS for macro names and flag all non-all-CAPS macro names.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-name-one\"></a>ES.10: Declare one name (only) per declaration",
    "content": "### <a name=\"res-name-one\"></a>ES.10: Declare one name (only) per declaration\n\n##### Reason\n\nOne declaration per line increases readability and avoids mistakes related to\nthe C/C++ grammar. It also leaves room for a more descriptive end-of-line\ncomment.\n\n##### Example, bad\n\n    char *p, c, a[7], *pp[7], **aa[10];   // yuck!\n\n##### Exception\n\nA function declaration can contain several function argument declarations.\n\n##### Exception\n\nA structured binding (C++17) is specifically designed to introduce several variables:\n\n    auto [iter, inserted] = m.insert_or_assign(k, val);\n    if (inserted) { /* new entry was inserted */ }\n\n##### Example\n\n    template<class InputIterator, class Predicate>\n    bool any_of(InputIterator first, InputIterator last, Predicate pred);\n\nor better using concepts:\n\n    bool any_of(input_iterator auto first, input_iterator auto last, predicate auto pred);\n\n##### Example\n\n    double scalbn(double x, int n);   // OK: x * pow(FLT_RADIX, n); FLT_RADIX is usually 2\n\nor:\n\n    double scalbn(    // better: x * pow(FLT_RADIX, n); FLT_RADIX is usually 2\n        double x,     // base value\n        int n         // exponent\n    );\n\nor:\n\n    // better: base * pow(FLT_RADIX, exponent); FLT_RADIX is usually 2\n    double scalbn(double base, int exponent);\n\n##### Example\n\n    int a = 10, b = 11, c = 12, d, e = 14, f = 15;\n\nIn a long list of declarators it is easy to overlook an uninitialized variable.\n\n##### Enforcement\n\nFlag variable and constant declarations with multiple declarators (e.g., `int* p, q;`)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-auto\"></a>ES.11: Use `auto` to avoid redundant repetition of type names",
    "content": "### <a name=\"res-auto\"></a>ES.11: Use `auto` to avoid redundant repetition of type names\n\n##### Reason\n\n* Simple repetition is tedious and error-prone.\n* When you use `auto`, the name of the declared entity is in a fixed position in the declaration, increasing readability.\n* In a function template declaration the return type can be a member type.\n\n##### Example\n\nConsider:\n\n    auto p = v.begin();      // vector<DataRecord>::iterator\n    auto z1 = v[3];          // makes copy of DataRecord\n    auto& z2 = v[3];         // avoids copy\n    const auto& z3 = v[3];   // const and avoids copy\n    auto h = t.future();\n    auto q = make_unique<int[]>(s);\n    auto f = [](int x) { return x + 10; };\n\nIn each case, we save writing a longish, hard-to-remember type that the compiler already knows but a programmer could get wrong.\n\n##### Example\n\n    template<class T>\n    auto Container<T>::first() -> Iterator;   // Container<T>::Iterator\n\n##### Exception\n\nAvoid `auto` for initializer lists and in cases where you know exactly which type you want and where an initializer might require conversion.\n\n##### Example\n\n    auto lst = { 1, 2, 3 };   // lst is an initializer list\n    auto x{1};   // x is an int (in C++17; initializer_list in C++11)\n\n##### Note\n\nAs of C++20, we can (and should) use concepts to be more specific about the type we are deducing:\n\n    // ...\n    forward_iterator auto p = algo(x, y, z);\n\n##### Example (C++17)\n\n    std::set<int> values;\n    // ...\n    auto [ position, newly_inserted ] = values.insert(5);   // break out the members of the std::pair\n\n##### Enforcement\n\nFlag redundant repetition of type names in a declaration.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-reuse\"></a>ES.12: Do not reuse names in nested scopes",
    "content": "### <a name=\"res-reuse\"></a>ES.12: Do not reuse names in nested scopes\n\n##### Reason\n\nIt is easy to get confused about which variable is used.\nCan cause maintenance problems.\n\n##### Example, bad\n\n    int d = 0;\n    // ...\n    if (cond) {\n        // ...\n        d = 9;\n        // ...\n    }\n    else {\n        // ...\n        int d = 7;\n        // ...\n        d = value_to_be_returned;\n        // ...\n    }\n\n    return d;\n\nIf this is a large `if`-statement, it is easy to overlook that a new `d` has been introduced in the inner scope.\nThis is a known source of bugs.\nSometimes such reuse of a name in an inner scope is called \"shadowing\".\n\n##### Note\n\nShadowing is primarily a problem when functions are too large and too complex.\n\n##### Example\n\nShadowing of function arguments in the outermost block is disallowed by the language:\n\n    void f(int x)\n    {\n        int x = 4;  // error: reuse of function argument name\n\n        if (x) {\n            int x = 7;  // allowed, but bad\n            // ...\n        }\n    }\n\n##### Example, bad\n\nReuse of a member name as a local variable can also be a problem:\n\n    struct S {\n        int m;\n        void f(int x);\n    };\n\n    void S::f(int x)\n    {\n        m = 7;    // assign to member\n        if (x) {\n            int m = 9;\n            // ...\n            m = 99; // assign to local variable\n            // ...\n        }\n    }\n\n##### Exception\n\nWe often reuse function names from a base class in a derived class:\n\n    struct B {\n        void f(int);\n    };\n\n    struct D : B {\n        void f(double);\n        using B::f;\n    };\n\nThis is error-prone.\nFor example, had we forgotten the using declaration, a call `d.f(1)` would not have found the `int` version of `f`.\n\n??? Do we need a specific rule about shadowing/hiding in class hierarchies?\n\n##### Enforcement\n\n* Flag reuse of a name in nested local scopes\n* Flag reuse of a member name as a local variable in a member function\n* Flag reuse of a global name as a local variable or a member name\n* Flag reuse of a base class member name in a derived class (except for function names)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-always\"></a>ES.20: Always initialize an object",
    "content": "### <a name=\"res-always\"></a>ES.20: Always initialize an object\n\n##### Reason\n\nAvoid used-before-set errors and their associated undefined behavior.\nAvoid problems with comprehension of complex initialization.\nSimplify refactoring.\n\n##### Example\n\n    void use(int arg)\n    {\n        int i;   // bad: uninitialized variable\n        // ...\n        i = 7;   // initialize i\n    }\n\nNo, `i = 7` does not initialize `i`; it assigns to it. Also, `i` can be read in the `...` part. Better:\n\n    void use(int arg)   // OK\n    {\n        int i = 7;   // OK: initialized\n        string s;    // OK: default initialized\n        // ...\n    }\n\n##### Note\n\nThe *always initialize* rule is deliberately stronger than the *an object must be set before used* language rule.\nThe latter, more relaxed rule, catches the technical bugs, but:\n\n* It leads to less readable code\n* It encourages people to declare names in greater than necessary scopes\n* It leads to harder to read code\n* It leads to logic bugs by encouraging complex code\n* It hampers refactoring\n\nThe *always initialize* rule is a style rule aimed to improve maintainability as well as a rule protecting against used-before-set errors.\n\n##### Example\n\nHere is an example that is often considered to demonstrate the need for a more relaxed rule for initialization\n\n    widget i;    // \"widget\" a type that's expensive to initialize, possibly a large trivial type\n    widget j;\n\n    if (cond) {  // bad: i and j are initialized \"late\"\n        i = f1();\n        j = f2();\n    }\n    else {\n        i = f3();\n        j = f4();\n    }\n\nThis cannot trivially be rewritten to initialize `i` and `j` with initializers.\nNote that for types with a default constructor, attempting to postpone initialization simply leads to a default initialization followed by an assignment.\nA popular reason for such examples is \"efficiency\", but a compiler that can detect whether we made a used-before-set error can also eliminate any redundant double initialization.\n\nAssuming that there is a logical connection between `i` and `j`, that connection should probably be expressed in code:\n\n    pair<widget, widget> make_related_widgets(bool x)\n    {\n        return (x) ? {f1(), f2()} : {f3(), f4()};\n    }\n\n    auto [i, j] = make_related_widgets(cond);    // C++17\n\nIf the `make_related_widgets` function is otherwise redundant,\nwe can eliminate it by using a lambda [ES.28](#res-lambda-init):\n\n    auto [i, j] = [x] { return (x) ? pair{f1(), f2()} : pair{f3(), f4()} }();    // C++17\n\nUsing a value representing \"uninitialized\" is a symptom of a problem and not a solution:\n\n    widget i = uninit;  // bad\n    widget j = uninit;\n\n    // ...\n    use(i);         // possibly used before set\n    // ...\n\n    if (cond) {     // bad: i and j are initialized \"late\"\n        i = f1();\n        j = f2();\n    }\n    else {\n        i = f3();\n        j = f4();\n    }\n\nNow the compiler cannot even simply detect a used-before-set. Further, we've introduced complexity in the state space for widget: which operations are valid on an `uninit` widget and which are not?\n\n##### Note\n\nComplex initialization has been popular with clever programmers for decades.\nIt has also been a major source of errors and complexity.\nMany such errors are introduced during maintenance years after the initial implementation.\n\n##### Example\n\nThis rule covers data members.\n\n    class X {\n    public:\n        X(int i, int ci) : m2{i}, cm2{ci} {}\n        // ...\n\n    private:\n        int m1 = 7;\n        int m2;\n        int m3;\n\n        const int cm1 = 7;\n        const int cm2;\n        const int cm3;\n    };\n\nThe compiler will flag the uninitialized `cm3` because it is a `const`, but it will not catch the lack of initialization of `m3`.\nUsually, a rare spurious member initialization is worth the absence of errors from lack of initialization and often an optimizer\ncan eliminate a redundant initialization (e.g., an initialization that occurs immediately before an assignment).\n\n##### Exception\n\nIf you are declaring an object that is just about to be initialized from input, initializing it would cause a double initialization.\nHowever, beware that this might leave uninitialized data beyond the input -- and that has been a fertile source of errors and security breaches:\n\n    constexpr int max = 8 * 1024;\n    int buf[max];         // OK, but suspicious: uninitialized\n    f.read(buf, max);\n\nThe cost of initializing that array could be significant in some situations.\nHowever, such examples do tend to leave uninitialized variables accessible, so they should be treated with suspicion.\n\n    constexpr int max = 8 * 1024;\n    int buf[max] = {};   // zero all elements; better in some situations\n    f.read(buf, max);\n\nBecause of the restrictive initialization rules for arrays and `std::array`, they offer the most compelling examples of the need for this exception.\n\nWhen feasible use a library function that is known not to overflow. For example:\n\n    string s;   // s is default initialized to \"\"\n    cin >> s;   // s expands to hold the string\n\nDon't consider simple variables that are targets for input operations exceptions to this rule:\n\n    int i;   // bad\n    // ...\n    cin >> i;\n\nIn the not uncommon case where the input target and the input operation get separated (as they should not) the possibility of used-before-set opens up.\n\n    int i2 = 0;   // better, assuming that zero is an acceptable value for i2\n    // ...\n    cin >> i2;\n\nA good optimizer should know about input operations and eliminate the redundant operation.\n\n\n##### Note\n\nSometimes, a lambda can be used as an initializer to avoid an uninitialized variable:\n\n    error_code ec;\n    Value v = [&] {\n        auto p = get_value();   // get_value() returns a pair<error_code, Value>\n        ec = p.first;\n        return p.second;\n    }();\n\nor maybe:\n\n    Value v = [] {\n        auto p = get_value();   // get_value() returns a pair<error_code, Value>\n        if (p.first) throw Bad_value{p.first};\n        return p.second;\n    }();\n\n**See also**: [ES.28](#res-lambda-init)\n\n##### Enforcement\n\n* Flag every uninitialized variable.\n  Don't flag variables of user-defined types with default constructors.\n* Check that an uninitialized buffer is written into *immediately* after declaration.\n  Passing an uninitialized variable as a reference to non-`const` argument can be assumed to be a write into the variable.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-introduce\"></a>ES.21: Don't introduce a variable (or constant) before you need to use it",
    "content": "### <a name=\"res-introduce\"></a>ES.21: Don't introduce a variable (or constant) before you need to use it\n\n##### Reason\n\nReadability. To limit the scope in which the variable can be used.\n\n##### Example\n\n    int x = 7;\n    // ... no use of x here ...\n    ++x;\n\n##### Enforcement\n\nFlag declarations that are distant from their first use.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-init\"></a>ES.22: Don't declare a variable until you have a value to initialize it with",
    "content": "### <a name=\"res-init\"></a>ES.22: Don't declare a variable until you have a value to initialize it with\n\n##### Reason\n\nReadability. Limit the scope in which a variable can be used. Don't risk used-before-set. Initialization is often more efficient than assignment.\n\n##### Example, bad\n\n    string s;\n    // ... no use of s here ...\n    s = \"what a waste\";\n\n##### Example, bad\n\n    SomeLargeType var;  // Hard-to-read CaMeLcAsEvArIaBlE\n\n    if (cond)   // some non-trivial condition\n        Set(&var);\n    else if (cond2 || !cond3) {\n        var = Set2(3.14);\n    }\n    else {\n        var = 0;\n        for (auto& e : something)\n            var += e;\n    }\n\n    // use var; that this isn't done too early can be enforced statically with only control flow\n\nThis would be fine if there was a default initialization for `SomeLargeType` that wasn't too expensive.\nOtherwise, a programmer might very well wonder if every possible path through the maze of conditions has been covered.\nIf not, we have a \"use before set\" bug. This is a maintenance trap.\n\nFor initializers of moderate complexity, including for `const` variables, consider using a lambda to express the initializer; see [ES.28](#res-lambda-init).\n\n##### Enforcement\n\n* Flag declarations with default initialization that are assigned to before they are first read.\n* Flag any complicated computation after an uninitialized variable and before its use.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-list\"></a>ES.23: Prefer the `{}`-initializer syntax",
    "content": "### <a name=\"res-list\"></a>ES.23: Prefer the `{}`-initializer syntax\n\n##### Reason\n\nPrefer `{}`. The rules for `{}` initialization are simpler, more general, less ambiguous, and safer than for other forms of initialization.\n\nUse `=` only when you are sure that there can be no narrowing conversions. For built-in arithmetic types, use `=` only with `auto`.\n\nAvoid `()` initialization, which allows parsing ambiguities.\n\n##### Example\n\n    int x {f(99)};\n    int y = x;\n    vector<int> v = {1, 2, 3, 4, 5, 6};\n\n##### Exception\n\nFor containers, there is a tradition for using `{...}` for a list of elements and `(...)` for sizes:\n\n    vector<int> v1(10);    // vector of 10 elements with the default value 0\n    vector<int> v2{10};    // vector of 1 element with the value 10\n\n    vector<int> v3(1, 2);  // vector of 1 element with the value 2\n    vector<int> v4{1, 2};  // vector of 2 elements with the values 1 and 2\n\n##### Note\n\n`{}`-initializers do not allow narrowing conversions (and that is usually a good thing) and allow explicit constructors (which is fine, we're intentionally initializing a new variable).\n\n##### Example\n\n    int x {7.9};   // error: narrowing\n    int y = 7.9;   // OK: y becomes 7. Hope for a compiler warning\n    int z {gsl::narrow_cast<int>(7.9)};    // OK: you asked for it\n    auto zz = gsl::narrow_cast<int>(7.9);  // OK: you asked for it\n\n##### Note\n\n`{}` initialization can be used for nearly all initialization; other forms of initialization can't:\n\n    auto p = new vector<int> {1, 2, 3, 4, 5};   // initialized vector\n    D::D(int a, int b) :m{a, b} {   // member initializer (e.g., m might be a pair)\n        // ...\n    };\n    X var {};   // initialize var to be empty\n    struct S {\n        int m {7};   // default initializer for a member\n        // ...\n    };\n\nFor that reason, `{}`-initialization is often called \"uniform initialization\"\n(though there unfortunately are a few irregularities left).\n\n##### Note\n\nInitialization of a variable declared using `auto` with a single value, e.g., `{v}`, had surprising results until C++17.\nThe C++17 rules are somewhat less surprising:\n\n    auto x1 {7};        // x1 is an int with the value 7\n    auto x2 = {7};      // x2 is an initializer_list<int> with an element 7\n\n    auto x11 {7, 8};    // error: two initializers\n    auto x22 = {7, 8};  // x22 is an initializer_list<int> with elements 7 and 8\n\nUse `={...}` if you really want an `initializer_list<T>`\n\n    auto fib10 = {1, 1, 2, 3, 5, 8, 13, 21, 34, 55};   // fib10 is a list\n\n##### Note\n\n`={}` gives copy initialization whereas `{}` gives direct initialization.\nLike the distinction between copy-initialization and direct-initialization itself, this can lead to surprises.\n`{}` accepts `explicit` constructors; `={}` does not. For example:\n\n    struct Z { explicit Z() {} };\n\n    Z z1{};     // OK: direct initialization, so we use explicit constructor\n    Z z2 = {};  // error: copy initialization, so we cannot use the explicit constructor\n\nUse plain `{}`-initialization unless you specifically want to disable explicit constructors.\n\n##### Example\n\n    template<typename T>\n    void f()\n    {\n        T x1(1);    // T initialized with 1\n        T x0();     // bad: function declaration (often a mistake)\n\n        T y1 {1};   // T initialized with 1\n        T y0 {};    // default initialized T\n        // ...\n    }\n\n**See also**: [Discussion](#???)\n\n##### Enforcement\n\n* Flag uses of `=` to initialize arithmetic types where narrowing occurs.\n* Flag uses of `()` initialization syntax that are actually declarations. (Many compilers should warn on this already.)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-unique\"></a>ES.24: Use a `unique_ptr<T>` to hold pointers",
    "content": "### <a name=\"res-unique\"></a>ES.24: Use a `unique_ptr<T>` to hold pointers\n\n##### Reason\n\nUsing `std::unique_ptr` is the simplest way to avoid leaks. It is reliable, it\nmakes the type system do much of the work to validate ownership safety, it\nincreases readability, and it has zero or near zero run-time cost.\n\n##### Example\n\n    void use(bool leak)\n    {\n        auto p1 = make_unique<int>(7);   // OK\n        int* p2 = new int{7};            // bad: might leak\n        // ... no assignment to p2 ...\n        if (leak) return;\n        // ... no assignment to p2 ...\n        vector<int> v(7);\n        v.at(7) = 0;                    // exception thrown\n        delete p2;                      // too late to prevent leaks\n        // ...\n    }\n\nIf `leak == true` the object pointed to by `p2` is leaked and the object pointed to by `p1` is not.\nThe same is the case when `at()` throws. In both cases, the `delete p2` statement is not reached.\n\n##### Enforcement\n\nLook for raw pointers that are targets of `new`, `malloc()`, or functions that might return such pointers.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-const\"></a>ES.25: Declare an object `const` or `constexpr` unless you want to modify its value later on",
    "content": "### <a name=\"res-const\"></a>ES.25: Declare an object `const` or `constexpr` unless you want to modify its value later on\n\n##### Reason\n\nThat way you can't change the value by mistake. That way might offer the compiler optimization opportunities.\n\n##### Example\n\n    void f(int n)\n    {\n        const int bufmax = 2 * n + 2;  // good: we can't change bufmax by accident\n        int xmax = n;                  // suspicious: is xmax intended to change?\n        // ...\n    }\n\n##### Enforcement\n\nLook to see if a variable is actually mutated, and flag it if\nnot. Unfortunately, it might be impossible to detect when a non-`const` was not\n*intended* to vary (vs when it merely did not vary).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-recycle\"></a>ES.26: Don't use a variable for two unrelated purposes",
    "content": "### <a name=\"res-recycle\"></a>ES.26: Don't use a variable for two unrelated purposes\n\n##### Reason\n\nReadability and safety.\n\n##### Example, bad\n\n    void use()\n    {\n        int i;\n        for (i = 0; i < 20; ++i) { /* ... */ }\n        for (i = 0; i < 200; ++i) { /* ... */ } // bad: i recycled\n    }\n\n##### Note\n\nAs an optimization, you might want to reuse a buffer as a scratch pad, but even then prefer to limit the variable's scope as much as possible and be careful not to cause bugs from data left in a recycled buffer as this is a common source of security bugs.\n\n    void write_to_file()\n    {\n        std::string buffer;             // to avoid reallocations on every loop iteration\n        for (auto& o : objects) {\n            // First part of the work.\n            generate_first_string(buffer, o);\n            write_to_file(buffer);\n\n            // Second part of the work.\n            generate_second_string(buffer, o);\n            write_to_file(buffer);\n\n            // etc...\n        }\n    }\n\n##### Enforcement\n\nFlag recycled variables.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-stack\"></a>ES.27: Use `std::array` or `stack_array` for arrays on the stack",
    "content": "### <a name=\"res-stack\"></a>ES.27: Use `std::array` or `stack_array` for arrays on the stack\n\n##### Reason\n\nThey are readable and don't implicitly convert to pointers.\nThey are not confused with non-standard extensions of built-in arrays.\n\n##### Example, bad\n\n    const int n = 7;\n    int m = 9;\n\n    void f()\n    {\n        int a1[n];\n        int a2[m];   // error: not ISO C++\n        // ...\n    }\n\n##### Note\n\nThe definition of `a1` is legal C++ and has always been.\nThere is a lot of such code.\nIt is error-prone, though, especially when the bound is non-local.\nAlso, it is a \"popular\" source of errors (buffer overflow, pointers from array decay, etc.).\nThe definition of `a2` is C but not C++ and is considered a security risk.\n\n##### Example\n\n    const int n = 7;\n    int m = 9;\n\n    void f()\n    {\n        array<int, n> a1;\n        stack_array<int> a2(m);\n        // ...\n    }\n\n##### Enforcement\n\n* Flag arrays with non-constant bounds (C-style VLAs)\n* Flag arrays with non-local constant bounds\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-lambda-init\"></a>ES.28: Use lambdas for complex initialization, especially of `const` variables",
    "content": "### <a name=\"res-lambda-init\"></a>ES.28: Use lambdas for complex initialization, especially of `const` variables\n\n##### Reason\n\nIt nicely encapsulates local initialization, including cleaning up scratch variables needed only for the initialization, without needing to create a needless non-local yet non-reusable function. It also works for variables that should be `const` but only after some initialization work.\n\n##### Example, bad\n\n    widget x;   // should be const, but:\n    for (auto i = 2; i <= N; ++i) {          // this could be some\n        x += some_obj.do_something_with(i);  // arbitrarily long code\n    }                                        // needed to initialize x\n    // from here, x should be const, but we can't say so in code in this style\n\n##### Example, good\n\n    const widget x = [&] {\n        widget val;                                // assume that widget has a default constructor\n        for (auto i = 2; i <= N; ++i) {            // this could be some\n            val += some_obj.do_something_with(i);  // arbitrarily long code\n        }                                          // needed to initialize x\n        return val;\n    }();\n\nIf at all possible, reduce the conditions to a simple set of alternatives (e.g., an `enum`) and don't mix up selection and initialization.\n\n##### Enforcement\n\nHard. At best a heuristic. Look for an uninitialized variable followed by a loop assigning to it.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-macros\"></a>ES.30: Don't use macros for program text manipulation",
    "content": "### <a name=\"res-macros\"></a>ES.30: Don't use macros for program text manipulation\n\n##### Reason\n\nMacros are a major source of bugs.\nMacros don't obey the usual scope and type rules.\nMacros ensure that the human reader sees something different from what the compiler sees.\nMacros complicate tool building.\n\n##### Example, bad\n\n    #define Case break; case   /* BAD */\n\nThis innocuous-looking macro makes a single lower case `c` instead of a `C` into a bad flow-control bug.\n\n##### Note\n\nThis rule does not ban the use of macros for \"configuration control\" use in `#ifdef`s, etc.\n\nIn the future, modules are likely to eliminate the need for macros in configuration control.\n\n##### Note\n\nThis rule is meant to also discourage use of `#` for stringification and `##` for concatenation.\nAs usual for macros, there are uses that are \"mostly harmless\", but even these can create problems for tools,\nsuch as auto completers, static analyzers, and debuggers.\nOften the desire to use fancy macros is a sign of an overly complex design.\nAlso, `#` and `##` encourages the definition and use of macros:\n\n    #define CAT(a, b) a ## b\n    #define STRINGIFY(a) #a\n\n    void f(int x, int y)\n    {\n        string CAT(x, y) = \"asdf\";   // BAD: hard for tools to handle (and ugly)\n        string sx2 = STRINGIFY(x);\n        // ...\n    }\n\nThere are workarounds for low-level string manipulation using macros. For example:\n\n    enum E { a, b };\n\n    template<int x>\n    constexpr const char* stringify()\n    {\n        switch (x) {\n        case a: return \"a\";\n        case b: return \"b\";\n        }\n    }\n\n    void f()\n    {\n        string s1 = stringify<a>();\n        string s2 = stringify<b>();\n        // ...\n    }\n\nThis is not as convenient as a macro to define, but as easy to use, has zero overhead, and is typed and scoped.\n\nIn the future, static reflection is likely to eliminate the last needs for the preprocessor for program text manipulation.\n\n##### Enforcement\n\nScream when you see a macro that isn't just used for source control (e.g., `#ifdef`)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-macros2\"></a>ES.31: Don't use macros for constants or \"functions\"",
    "content": "### <a name=\"res-macros2\"></a>ES.31: Don't use macros for constants or \"functions\"\n\n##### Reason\n\nMacros are a major source of bugs.\nMacros don't obey the usual scope and type rules.\nMacros don't obey the usual rules for argument passing.\nMacros ensure that the human reader sees something different from what the compiler sees.\nMacros complicate tool building.\n\n##### Example, bad\n\n    #define PI 3.14\n    #define SQUARE(a, b) (a * b)\n\nEven if we hadn't left a well-known bug in `SQUARE` there are much better behaved alternatives; for example:\n\n    constexpr double pi = 3.14;\n    template<typename T> T square(T a, T b) { return a * b; }\n\n##### Enforcement\n\nScream when you see a macro that isn't just used for source control (e.g., `#ifdef`)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-all_caps\"></a>ES.32: Use `ALL_CAPS` for all macro names",
    "content": "### <a name=\"res-all_caps\"></a>ES.32: Use `ALL_CAPS` for all macro names\n\n##### Reason\n\nConvention. Readability. Distinguishing macros.\n\n##### Example\n\n    #define forever for (;;)   /* very BAD */\n\n    #define FOREVER for (;;)   /* Still evil, but at least visible to humans */\n\n##### Enforcement\n\nScream when you see a lower case macro.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-macros3\"></a>ES.33: If you must use macros, give them unique names",
    "content": "### <a name=\"res-macros3\"></a>ES.33: If you must use macros, give them unique names\n\n##### Reason\n\nMacros do not obey scope rules.\n\n##### Example\n\n    #define MYCHAR        /* BAD, will eventually clash with someone else's MYCHAR*/\n\n    #define ZCORP_CHAR    /* Still evil, but less likely to clash */\n\n##### Note\n\nAvoid macros if you can: [ES.30](#res-macros), [ES.31](#res-macros2), and [ES.32](#res-all_caps).\nHowever, there are billions of lines of code littered with macros and a long tradition for using and overusing macros.\nIf you are forced to use macros, use long names and supposedly unique prefixes (e.g., your organization's name) to lower the likelihood of a clash.\n\n##### Enforcement\n\nWarn against short macro names.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-ellipses\"></a> ES.34: Don't define a (C-style) variadic function",
    "content": "### <a name=\"res-ellipses\"></a> ES.34: Don't define a (C-style) variadic function\n\n##### Reason\n\nNot type safe.\nRequires messy cast-and-macro-laden code to get working right.\n\n##### Example\n\n    #include <cstdarg>\n\n    // \"severity\" followed by a zero-terminated list of char*s; write the C-style strings to cerr\n    void error(int severity ...)\n    {\n        va_list ap;             // a magic type for holding arguments\n        va_start(ap, severity); // arg startup: \"severity\" is the first argument of error()\n\n        for (;;) {\n            // treat the next var as a char*; no checking: a cast in disguise\n            char* p = va_arg(ap, char*);\n            if (!p) break;\n            cerr << p << ' ';\n        }\n\n        va_end(ap);             // arg cleanup (don't forget this)\n\n        cerr << '\\n';\n        if (severity) exit(severity);\n    }\n\n    void use()\n    {\n        error(7, \"this\", \"is\", \"an\", \"error\", nullptr);\n        error(7); // crash\n        error(7, \"this\", \"is\", \"an\", \"error\");  // crash\n        const char* is = \"is\";\n        string an = \"an\";\n        error(7, \"this\", is, an, \"error\"); // crash\n    }\n\n**Alternative**: Overloading. Templates. Variadic templates.\n\n    #include <iostream>\n\n    void error(int severity)\n    {\n        std::cerr << '\\n';\n        std::exit(severity);\n    }\n\n    template<typename T, typename... Ts>\n    constexpr void error(int severity, T head, Ts... tail)\n    {\n        std::cerr << head;\n        error(severity, tail...);\n    }\n\n    void use()\n    {\n        error(7); // No crash!\n        error(5, \"this\", \"is\", \"not\", \"an\", \"error\"); // No crash!\n\n        std::string an = \"an\";\n        error(7, \"this\", \"is\", \"not\", an, \"error\"); // No crash!\n\n        error(5, \"oh\", \"no\", nullptr); // Compile error! No need for nullptr.\n    }\n\n\n##### Note\n\nThis is basically the way `printf` is implemented.\n\n##### Enforcement\n\n* Flag definitions of C-style variadic functions.\n* Flag `#include <cstdarg>` and `#include <stdarg.h>`\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "ES.expr: Expressions",
    "content": "## ES.expr: Expressions\n\nExpressions manipulate values.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-complicated\"></a>ES.40: Avoid complicated expressions",
    "content": "### <a name=\"res-complicated\"></a>ES.40: Avoid complicated expressions\n\n##### Reason\n\nComplicated expressions are error-prone.\n\n##### Example\n\n    // bad: assignment hidden in subexpression\n    while ((c = getc()) != -1)\n\n    // bad: two non-local variables assigned in sub-expressions\n    while ((cin >> c1, cin >> c2), c1 == c2)\n\n    // better, but possibly still too complicated\n    for (char c1, c2; cin >> c1 >> c2 && c1 == c2;)\n\n    // OK: if i and j are not aliased\n    int x = ++i + ++j;\n\n    // OK: if i != j and i != k\n    v[i] = v[j] + v[k];\n\n    // bad: multiple assignments \"hidden\" in subexpressions\n    x = a + (b = f()) + (c = g()) * 7;\n\n    // bad: relies on commonly misunderstood precedence rules\n    x = a & b + c * d && e ^ f == 7;\n\n    // bad: undefined behavior\n    x = x++ + x++ + ++x;\n\nSome of these expressions are unconditionally bad (e.g., they rely on undefined behavior). Others are simply so complicated and/or unusual that even good programmers could misunderstand them or overlook a problem when in a hurry.\n\n##### Note\n\nC++17 tightens up the rules for the order of evaluation\n(left-to-right except right-to-left in assignments, and the order of evaluation of function arguments is unspecified; [see ES.43](#res-order)),\nbut that doesn't change the fact that complicated expressions are potentially confusing.\n\n##### Note\n\nA programmer should know and use the basic rules for expressions.\n\n##### Example\n\n    x = k * y + z;             // OK\n\n    auto t1 = k * y;           // bad: unnecessarily verbose\n    x = t1 + z;\n\n    if (0 <= x && x < max)   // OK\n\n    auto t1 = 0 <= x;        // bad: unnecessarily verbose\n    auto t2 = x < max;\n    if (t1 && t2)            // ...\n\n##### Enforcement\n\nTricky. How complicated must an expression be to be considered complicated? Writing computations as statements with one operation each is also confusing. Things to consider:\n\n* side effects: side effects on multiple non-local variables (for some definition of non-local) can be suspect, especially if the side effects are in separate subexpressions\n* writes to aliased variables\n* more than N operators (and what should N be?)\n* reliance of subtle precedence rules\n* uses undefined behavior (can we catch all undefined behavior?)\n* implementation defined behavior?\n* ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-parens\"></a>ES.41: If in doubt about operator precedence, parenthesize",
    "content": "### <a name=\"res-parens\"></a>ES.41: If in doubt about operator precedence, parenthesize\n\n##### Reason\n\nAvoid errors. Readability. Not everyone has the operator table memorized.\n\n##### Example\n\n    const unsigned int flag = 2;\n    unsigned int a = flag;\n\n    if (a & flag != 0)  // bad: means a&(flag != 0)\n\nNote: We recommend that programmers know their precedence table for the arithmetic operations, the logical operations, but consider mixing bitwise logical operations with other operators in need of parentheses.\n\n    if ((a & flag) != 0)  // OK: works as intended\n\n##### Note\n\nYou should know enough not to need parentheses for:\n\n    if (a < 0 || a <= max) {\n        // ...\n    }\n\n##### Enforcement\n\n* Flag combinations of bitwise-logical operators and other operators.\n* Flag assignment operators not as the leftmost operator.\n* ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-ptr\"></a>ES.42: Keep use of pointers simple and straightforward",
    "content": "### <a name=\"res-ptr\"></a>ES.42: Keep use of pointers simple and straightforward\n\n##### Reason\n\nComplicated pointer manipulation is a major source of errors.\n\n##### Note\n\nUse `gsl::span` instead.\nPointers should [only refer to single objects](#ri-array).\nPointer arithmetic is fragile and easy to get wrong, the source of many, many bad bugs and security violations.\n`span` is a bounds-checked, safe type for accessing arrays of data.\nAccess into an array with known bounds using a constant as a subscript can be validated by the compiler.\n\n##### Example, bad\n\n    void f(int* p, int count)\n    {\n        if (count < 2) return;\n\n        int* q = p + 1;    // BAD\n\n        ptrdiff_t d;\n        int n;\n        d = (p - &n);      // OK\n        d = (q - p);       // OK\n\n        int n = *p++;      // BAD\n\n        if (count < 6) return;\n\n        p[4] = 1;          // BAD\n\n        p[count - 1] = 2;  // BAD\n\n        use(&p[0], 3);     // BAD\n    }\n\n##### Example, good\n\n    void f(span<int> a) // BETTER: use span in the function declaration\n    {\n        if (a.size() < 2) return;\n\n        int n = a[0];      // OK\n\n        span<int> q = a.subspan(1); // OK\n\n        if (a.size() < 6) return;\n\n        a[4] = 1;          // OK\n\n        a[a.size() - 1] = 2;  // OK\n\n        use(a.data(), 3);  // OK\n    }\n\n##### Note\n\nSubscripting with a variable is difficult for both tools and humans to validate as safe.\n`span` is a run-time bounds-checked, safe type for accessing arrays of data.\n`at()` is another alternative that ensures single accesses are bounds-checked.\nIf iterators are needed to access an array, use the iterators from a `span` constructed over the array.\n\n##### Example, bad\n\n    void f(array<int, 10> a, int pos)\n    {\n        a[pos / 2] = 1; // BAD\n        a[pos - 1] = 2; // BAD\n        a[-1] = 3;    // BAD (but easily caught by tools) -- no replacement, just don't do this\n        a[10] = 4;    // BAD (but easily caught by tools) -- no replacement, just don't do this\n    }\n\n##### Example, good\n\nUse a `span`:\n\n    void f1(span<int, 10> a, int pos) // A1: Change parameter type to use span\n    {\n        a[pos / 2] = 1; // OK\n        a[pos - 1] = 2; // OK\n    }\n\n    void f2(array<int, 10> arr, int pos) // A2: Add local span and use that\n    {\n        span<int> a = {arr.data(), pos};\n        a[pos / 2] = 1; // OK\n        a[pos - 1] = 2; // OK\n    }\n\nUse `at()`:\n\n    void f3(array<int, 10> a, int pos) // ALTERNATIVE B: Use at() for access\n    {\n        at(a, pos / 2) = 1; // OK\n        at(a, pos - 1) = 2; // OK\n    }\n\n##### Example, bad\n\n    void f()\n    {\n        int arr[COUNT];\n        for (int i = 0; i < COUNT; ++i)\n            arr[i] = i; // BAD, cannot use non-constant indexer\n    }\n\n##### Example, good\n\nUse a `span`:\n\n    void f1()\n    {\n        int arr[COUNT];\n        span<int> av = arr;\n        for (int i = 0; i < COUNT; ++i)\n            av[i] = i;\n    }\n\nUse a `span` and range-`for`:\n\n    void f1a()\n    {\n         int arr[COUNT];\n         span<int, COUNT> av = arr;\n         int i = 0;\n         for (auto& e : av)\n             e = i++;\n    }\n\nUse `at()` for access:\n\n    void f2()\n    {\n        int arr[COUNT];\n        for (int i = 0; i < COUNT; ++i)\n            at(arr, i) = i;\n    }\n\nUse a range-`for`:\n\n    void f3()\n    {\n        int arr[COUNT];\n        int i = 0;\n        for (auto& e : arr)\n             e = i++;\n    }\n\n##### Note\n\nTooling can offer rewrites of array accesses that involve dynamic index expressions to use `at()` instead:\n\n    static int a[10];\n\n    void f(int i, int j)\n    {\n        a[i + j] = 12;      // BAD, could be rewritten as ...\n        at(a, i + j) = 12;  // OK -- bounds-checked\n    }\n\n##### Example\n\nTurning an array into a pointer (as the language does essentially always) removes opportunities for checking, so avoid it\n\n    void g(int* p);\n\n    void f()\n    {\n        int a[5];\n        g(a);        // BAD: are we trying to pass an array?\n        g(&a[0]);    // OK: passing one object\n    }\n\nIf you want to pass an array, say so:\n\n    void g(int* p, size_t length);  // old (dangerous) code\n\n    void g1(span<int> av); // BETTER: get g() changed.\n\n    void f2()\n    {\n        int a[5];\n        span<int> av = a;\n\n        g(av.data(), av.size());   // OK, if you have no choice\n        g1(a);                     // OK -- no decay here, instead use implicit span ctor\n    }\n\n##### Enforcement\n\n* Flag any arithmetic operation on an expression of pointer type that results in a value of pointer type.\n* Flag any indexing expression on an expression or variable of array type (either static array or `std::array`) where the indexer is not a compile-time constant expression with a value between `0` and the upper bound of the array.\n* Flag any expression that would rely on implicit conversion of an array type to a pointer type.\n\nThis rule is part of the [bounds-safety profile](#ss-bounds).\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-order\"></a>ES.43: Avoid expressions with undefined order of evaluation",
    "content": "### <a name=\"res-order\"></a>ES.43: Avoid expressions with undefined order of evaluation\n\n##### Reason\n\nYou have no idea what such code does. Portability.\nEven if it does something sensible for you, it might do something different on another compiler (e.g., the next release of your compiler) or with a different optimizer setting.\n\n##### Note\n\nC++17 tightens up the rules for the order of evaluation:\nleft-to-right except right-to-left in assignments, and the order of evaluation of function arguments is unspecified.\n\nHowever, remember that your code might be compiled with a pre-C++17 compiler (e.g., through cut-and-paste) so don't be too clever.\n\n##### Example\n\n    v[i] = ++i;   //  the result is undefined\n\nA good rule of thumb is that you should not read a value twice in an expression where you write to it.\n\n##### Enforcement\n\nCan be detected by a good analyzer.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-order-fct\"></a>ES.44: Don't depend on order of evaluation of function arguments",
    "content": "### <a name=\"res-order-fct\"></a>ES.44: Don't depend on order of evaluation of function arguments\n\n##### Reason\n\nBecause that order is unspecified.\n\n##### Note\n\nC++17 tightens up the rules for the order of evaluation, but the order of evaluation of function arguments is still unspecified.\n\n##### Example\n\n    int i = 0;\n    f(++i, ++i);\n\nBefore C++17, the behavior is undefined, so the behavior could be anything (e.g., `f(2, 2)`).\nSince C++17, this code does not have undefined behavior, but it is still not specified which argument is evaluated first. The call will be `f(1, 2)` or `f(2, 1)`, but you don't know which.\n\n##### Example\n\nOverloaded operators can lead to order of evaluation problems:\n\n    f1()->m(f2());          // m(f1(), f2())\n    cout << f1() << f2();   // operator<<(operator<<(cout, f1()), f2())\n\nIn C++17, these examples work as expected (left to right) and assignments are evaluated right to left (just as ='s binding is right-to-left)\n\n    f1() = f2();    // undefined behavior in C++14; in C++17, f2() is evaluated before f1()\n\n##### Enforcement\n\nCan be detected by a good analyzer.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-magic\"></a>ES.45: Avoid \"magic constants\"; use symbolic constants",
    "content": "### <a name=\"res-magic\"></a>ES.45: Avoid \"magic constants\"; use symbolic constants\n\n##### Reason\n\nUnnamed constants embedded in expressions are easily overlooked and often hard to understand:\n\n##### Example\n\n    for (int m = 1; m <= 12; ++m)   // don't: magic constant 12\n        cout << month[m] << '\\n';\n\nNo, we don't all know that there are 12 months, numbered 1..12, in a year. Better:\n\n    // months are indexed 1..12\n    constexpr int first_month = 1;\n    constexpr int last_month = 12;\n\n    for (int m = first_month; m <= last_month; ++m)   // better\n        cout << month[m] << '\\n';\n\nBetter still, don't expose constants:\n\n    for (auto m : month)\n        cout << m << '\\n';\n\n##### Enforcement\n\nFlag literals in code. Give a pass to `0`, `1`, `nullptr`, `\\n`, `\"\"`, and others on a positive list.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-narrowing\"></a>ES.46: Avoid lossy (narrowing, truncating) arithmetic conversions",
    "content": "### <a name=\"res-narrowing\"></a>ES.46: Avoid lossy (narrowing, truncating) arithmetic conversions\n\n##### Reason\n\nA narrowing conversion destroys information, often unexpectedly so.\n\n##### Example, bad\n\nA key example is basic narrowing:\n\n    double d = 7.9;\n    int i = d;    // bad: narrowing: i becomes 7\n    i = (int) d;  // bad: we're going to claim this is still not explicit enough\n\n    void f(int x, long y, double d)\n    {\n        char c1 = x;   // bad: narrowing\n        char c2 = y;   // bad: narrowing\n        char c3 = d;   // bad: narrowing\n    }\n\n##### Note\n\nThe guidelines support library offers a `narrow_cast` operation for specifying that narrowing is acceptable and a `narrow` (\"narrow if\") that throws an exception if a narrowing would throw away legal values:\n\n    i = gsl::narrow_cast<int>(d);   // OK (you asked for it): narrowing: i becomes 7\n    i = gsl::narrow<int>(d);        // OK: throws narrowing_error\n\nWe also include lossy arithmetic casts, such as from a negative floating point type to an unsigned integral type:\n\n    double d = -7.9;\n    unsigned u = 0;\n\n    u = d;                               // bad: narrowing\n    u = gsl::narrow_cast<unsigned>(d);   // OK (you asked for it): u becomes 4294967289\n    u = gsl::narrow<unsigned>(d);        // OK: throws narrowing_error\n\n##### Note\n\nThis rule does not apply to [contextual conversions to bool](https://en.cppreference.com/w/cpp/language/implicit_conversion#Contextual_conversions):\n\n    if (ptr) do_something(*ptr);   // OK: ptr is used as a condition\n    bool b = ptr;                  // bad: narrowing\n\n##### Enforcement\n\nA good analyzer can detect all narrowing conversions. However, flagging all narrowing conversions will lead to a lot of false positives. Suggestions:\n\n* Flag all floating-point to integer conversions. (Maybe only `float`->`char` and `double`->`int`. Here be dragons! We need data.)\n* Flag all `long`->`char`. (I suspect `int`->`char` is very common. Here be dragons! We need data.)\n* Consider narrowing conversions for function arguments especially suspect.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-nullptr\"></a>ES.47: Use `nullptr` rather than `0` or `NULL`",
    "content": "### <a name=\"res-nullptr\"></a>ES.47: Use `nullptr` rather than `0` or `NULL`\n\n##### Reason\n\nReadability. Minimize surprises: `nullptr` cannot be confused with an\n`int`. `nullptr` also has a well-specified (very restrictive) type, and thus\nworks in more scenarios where type deduction might do the wrong thing on `NULL`\nor `0`.\n\n##### Example\n\nConsider:\n\n    void f(int);\n    void f(char*);\n    f(0);         // call f(int)\n    f(nullptr);   // call f(char*)\n\n##### Enforcement\n\nFlag uses of `0` and `NULL` for pointers. The transformation might be helped by simple program transformation.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-casts\"></a>ES.48: Avoid casts",
    "content": "### <a name=\"res-casts\"></a>ES.48: Avoid casts\n\n##### Reason\n\nCasts are a well-known source of errors and make some optimizations unreliable.\n\n##### Example, bad\n\n    double d = 2;\n    auto p = (long*)&d;\n    auto q = (long long*)&d;\n    cout << d << ' ' << *p << ' ' << *q << '\\n';\n\nWhat would you think this fragment prints? The result is at best implementation defined. I got\n\n    2 0 4611686018427387904\n\nAdding\n\n    *q = 666;\n    cout << d << ' ' << *p << ' ' << *q << '\\n';\n\nI got\n\n    3.29048e-321 666 666\n\nSurprised? It is actually undefined behavior, and so could also have crashed the program.\n\n##### Note\n\nProgrammers who write casts typically assume that they know what they are doing,\nor that writing a cast makes the program \"easier to read\".\nIn fact, they often disable the general rules for using values.\nOverload resolution and template instantiation usually pick the right function if there is a right function to pick.\nIf there is not, maybe there ought to be, rather than applying a local fix (cast).\n\n##### Notes\n\nCasts are necessary in a systems programming language.  For example, how else\nwould we get the address of a device register into a pointer?  However, casts\nare seriously overused as well as a major source of errors.\n\nIf you feel the need for a lot of casts, there might be a fundamental design problem.\n\nThe [type profile](#pro-type-reinterpretcast) bans `reinterpret_cast` and C-style casts.\n\nNever cast to `(void)` to ignore a `[[nodiscard]]`return value.\nIf you deliberately want to discard such a result, first think hard about whether that is really a good idea (there is usually a good reason the author of the function or of the return type used `[[nodiscard]]` in the first place).\nIf you still think it's appropriate and your code reviewer agrees, use `std::ignore =` to turn off the warning which is simple, portable, and easy to grep.\n\n##### Alternatives\n\nCasts are widely (mis)used. Modern C++ has rules and constructs that eliminate the need for casts in many contexts, such as\n\n* Use templates\n* Use `std::variant`\n* Rely on the well-defined, safe, implicit conversions between pointer types\n* Use `std::ignore =` to ignore `[[nodiscard]]` values.\n\n##### Enforcement\n\n* Flag all C-style casts, including to `void`.\n* Flag functional style casts using `Type(value)`. Use `Type{value}` instead which is not narrowing. (See [ES.64](#res-construct).)\n* Flag [identity casts](#pro-type-identitycast) between pointer types, where the source and target types are the same (#pro-type-identitycast).\n* Flag an explicit pointer cast that could be [implicit](#pro-type-implicitpointercast).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-casts-named\"></a>ES.49: If you must use a cast, use a named cast",
    "content": "### <a name=\"res-casts-named\"></a>ES.49: If you must use a cast, use a named cast\n\n##### Reason\n\nReadability. Error avoidance.\nNamed casts are more specific than a C-style or functional cast, allowing the compiler to catch some errors.\n\nThe named casts are:\n\n* `static_cast`\n* `const_cast`\n* `reinterpret_cast`\n* `dynamic_cast`\n* `std::move`         // `move(x)` is an rvalue reference to `x`\n* `std::forward`      // `forward<T>(x)` is an rvalue or an lvalue reference to `x` depending on `T`\n* `gsl::narrow_cast`  // `narrow_cast<T>(x)` is `static_cast<T>(x)`\n* `gsl::narrow`       // `narrow<T>(x)` is `static_cast<T>(x)` if `static_cast<T>(x) == x` or it throws `narrowing_error`\n\n##### Example\n\n    class B { /* ... */ };\n    class D { /* ... */ };\n\n    template<typename D> D* upcast(B* pb)\n    {\n        D* pd0 = pb;                        // error: no implicit conversion from B* to D*\n        D* pd1 = (D*)pb;                    // legal, but what is done?\n        D* pd2 = static_cast<D*>(pb);       // error: D is not derived from B\n        D* pd3 = reinterpret_cast<D*>(pb);  // OK: on your head be it!\n        D* pd4 = dynamic_cast<D*>(pb);      // OK: return nullptr\n        // ...\n    }\n\nThe example was synthesized from real-world bugs where `D` used to be derived from `B`, but someone refactored the hierarchy.\nThe C-style cast is dangerous because it can do any kind of conversion, depriving us of any protection from mistakes (now or in the future).\n\n##### Note\n\nWhen converting between types with no information loss (e.g. from `float` to\n`double` or from `int32` to `int64`), brace initialization might be used instead.\n\n    double d {some_float};\n    int64_t i {some_int32};\n\nThis makes it clear that the type conversion was intended and also prevents\nconversions between types that might result in loss of precision. (It is a\ncompilation error to try to initialize a `float` from a `double` in this fashion,\nfor example.)\n\n##### Note\n\n`reinterpret_cast` can be essential, but the essential uses (e.g., turning a machine address into pointer) are not type safe:\n\n    auto p = reinterpret_cast<Device_register>(0x800);  // inherently dangerous\n\n\n##### Enforcement\n\n* Flag all C-style casts, including to `void`.\n* Flag functional style casts using `Type(value)`. Use `Type{value}` instead which is not narrowing. (See [ES.64](#res-construct).)\n* The [type profile](#pro-type-reinterpretcast) bans `reinterpret_cast`.\n* The [type profile](#pro-type-arithmeticcast) warns when using `static_cast` between arithmetic types.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-casts-const\"></a>ES.50: Don't cast away `const`",
    "content": "### <a name=\"res-casts-const\"></a>ES.50: Don't cast away `const`\n\n##### Reason\n\nIt makes a lie out of `const`.\nIf the variable is actually declared `const`, modifying it results in undefined behavior.\n\n##### Example, bad\n\n    void f(const int& x)\n    {\n        const_cast<int&>(x) = 42;   // BAD\n    }\n\n    static int i = 0;\n    static const int j = 0;\n\n    f(i); // silent side effect\n    f(j); // undefined behavior\n\n##### Example\n\nSometimes, you might be tempted to resort to `const_cast` to avoid code duplication, such as when two accessor functions that differ only in `const`-ness have similar implementations. For example:\n\n    class Bar;\n\n    class Foo {\n    public:\n        // BAD, duplicates logic\n        Bar& get_bar()\n        {\n            /* complex logic around getting a non-const reference to my_bar */\n        }\n\n        const Bar& get_bar() const\n        {\n            /* same complex logic around getting a const reference to my_bar */\n        }\n    private:\n        Bar my_bar;\n    };\n\nInstead, prefer to share implementations. Normally, you can just have the non-`const` function call the `const` function. However, when there is complex logic this can lead to the following pattern that still resorts to a `const_cast`:\n\n    class Foo {\n    public:\n        // not great, non-const calls const version but resorts to const_cast\n        Bar& get_bar()\n        {\n            return const_cast<Bar&>(static_cast<const Foo&>(*this).get_bar());\n        }\n        const Bar& get_bar() const\n        {\n            /* the complex logic around getting a const reference to my_bar */\n        }\n    private:\n        Bar my_bar;\n    };\n\nAlthough this pattern is safe when applied correctly, because the caller must have had a non-`const` object to begin with, it's not ideal because the safety is hard to enforce automatically as a checker rule.\n\nInstead, prefer to put the common code in a common helper function -- and make it a template so that it deduces `const`. This doesn't use any `const_cast` at all:\n\n    class Foo {\n    public:                         // good\n              Bar& get_bar()       { return get_bar_impl(*this); }\n        const Bar& get_bar() const { return get_bar_impl(*this); }\n    private:\n        Bar my_bar;\n\n        template<class T>           // good, deduces whether T is const or non-const\n        static auto& get_bar_impl(T& t)\n            { /* the complex logic around getting a possibly-const reference to my_bar */ }\n    };\n\nNote: Don't do large non-dependent work inside a template, which leads to code bloat. For example, a further improvement would be if all or part of `get_bar_impl` can be non-dependent and factored out into a common non-template function, for a potentially big reduction in code size.\n\n##### Exception\n\nYou might need to cast away `const` when calling `const`-incorrect functions.\nPrefer to wrap such functions in inline `const`-correct wrappers to encapsulate the cast in one place.\n\n##### Example\n\nSometimes, \"cast away `const`\" is to allow the updating of some transient information of an otherwise immutable object.\nExamples are caching, memoization, and precomputation.\nSuch examples are often handled as well or better using `mutable` or an indirection than with a `const_cast`.\n\nConsider keeping previously computed results around for a costly operation:\n\n    int compute(int x); // compute a value for x; assume this to be costly\n\n    class Cache {   // some type implementing a cache for an int->int operation\n    public:\n        pair<bool, int> find(int x) const;   // is there a value for x?\n        void set(int x, int v);             // make y the value for x\n        // ...\n    private:\n        // ...\n    };\n\n    class X {\n    public:\n        int get_val(int x)\n        {\n            auto p = cache.find(x);\n            if (p.first) return p.second;\n            int val = compute(x);\n            cache.set(x, val); // insert value for x\n            return val;\n        }\n        // ...\n    private:\n        Cache cache;\n    };\n\nHere, `get_val()` is logically constant, so we would like to make it a `const` member.\nTo do this we still need to mutate `cache`, so people sometimes resort to a `const_cast`:\n\n    class X {   // Suspicious solution based on casting\n    public:\n        int get_val(int x) const\n        {\n            auto p = cache.find(x);\n            if (p.first) return p.second;\n            int val = compute(x);\n            const_cast<Cache&>(cache).set(x, val);   // ugly\n            return val;\n        }\n        // ...\n    private:\n        Cache cache;\n    };\n\nFortunately, there is a better solution:\nState that `cache` is mutable even for a `const` object:\n\n    class X {   // better solution\n    public:\n        int get_val(int x) const\n        {\n            auto p = cache.find(x);\n            if (p.first) return p.second;\n            int val = compute(x);\n            cache.set(x, val);\n            return val;\n        }\n        // ...\n    private:\n        mutable Cache cache;\n    };\n\nAn alternative solution would be to store a pointer to the `cache`:\n\n    class X {   // OK, but slightly messier solution\n    public:\n        int get_val(int x) const\n        {\n            auto p = cache->find(x);\n            if (p.first) return p.second;\n            int val = compute(x);\n            cache->set(x, val);\n            return val;\n        }\n        // ...\n    private:\n        unique_ptr<Cache> cache;\n    };\n\nThat solution is the most flexible, but requires explicit construction and destruction of `*cache`\n(most likely in the constructor and destructor of `X`).\n\nIn any variant, we must guard against data races on the `cache` in multi-threaded code, possibly using a `std::mutex`.\n\n##### Enforcement\n\n* Flag `const_cast`s.\n* This rule is part of the [type-safety profile](#pro-type-constcast) for the related Profile.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-range-checking\"></a>ES.55: Avoid the need for range checking",
    "content": "### <a name=\"res-range-checking\"></a>ES.55: Avoid the need for range checking\n\n##### Reason\n\nConstructs that cannot overflow do not overflow (and usually run faster):\n\n##### Example\n\n    for (auto& x : v)      // print all elements of v\n        cout << x << '\\n';\n\n    auto p = find(v, x);   // find x in v\n\n##### Enforcement\n\nLook for explicit range checks and heuristically suggest alternatives.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-move\"></a>ES.56: Write `std::move()` only when you need to explicitly move an object to another scope",
    "content": "### <a name=\"res-move\"></a>ES.56: Write `std::move()` only when you need to explicitly move an object to another scope\n\n##### Reason\n\nWe move, rather than copy, to avoid duplication and for improved performance.\n\nA move typically leaves behind an empty object ([C.64](#rc-move-semantic)), which can be surprising or even dangerous, so we try to avoid moving from lvalues (they might be accessed later).\n\n##### Notes\n\nMoving is done implicitly when the source is an rvalue (e.g., value in a `return` treatment or a function result), so don't pointlessly complicate code in those cases by writing `move` explicitly. Instead, write short functions that return values, and both the function's return and the caller's accepting of the return will be optimized naturally.\n\nIn general, following the guidelines in this document (including not making variables' scopes needlessly large, writing short functions that return values, returning local variables) help eliminate most need for explicit `std::move`.\n\nExplicit `move` is needed to explicitly move an object to another scope, notably to pass it to a \"sink\" function and in the implementations of the move operations themselves (move constructor, move assignment operator) and swap operations.\n\n##### Example, bad\n\n    void sink(X&& x);   // sink takes ownership of x\n\n    void user()\n    {\n        X x;\n        // error: cannot bind an lvalue to a rvalue reference\n        sink(x);\n        // OK: sink takes the contents of x, x must now be assumed to be empty\n        sink(std::move(x));\n\n        // ...\n\n        // probably a mistake\n        use(x);\n    }\n\nUsually, a `std::move()` is used as an argument to an `&&` parameter.\nAnd after you do that, assume the object has been moved from (see [C.64](#rc-move-semantic)) and don't read its state again until you first set it to a new value.\n\n    void f()\n    {\n        string s1 = \"supercalifragilisticexpialidocious\";\n\n        string s2 = s1;             // ok, takes a copy\n        assert(s1 == \"supercalifragilisticexpialidocious\");  // ok\n\n        // bad, if you want to keep using s1's value\n        string s3 = move(s1);\n\n        // bad, assert will likely fail, s1 likely changed\n        assert(s1 == \"supercalifragilisticexpialidocious\");\n    }\n\n##### Example\n\n    void sink(unique_ptr<widget> p);  // pass ownership of p to sink()\n\n    void f()\n    {\n        auto w = make_unique<widget>();\n        // ...\n        sink(std::move(w));               // ok, give to sink()\n        // ...\n        sink(w);    // Error: unique_ptr is carefully designed so that you cannot copy it\n    }\n\n##### Notes\n\n`std::move()` is a cast to `&&` in disguise; it doesn't itself move anything, but marks a named object as a candidate that can be moved from.\nThe language already knows the common cases where objects can be moved from, especially when returning values from functions, so don't complicate code with redundant `std::move()`s.\n\nNever write `std::move()` just because you've heard \"it's more efficient.\"\nIn general, don't believe claims of \"efficiency\" without data (???).\nIn general, don't complicate your code without reason (??).\nNever write `std::move()` on a const object, it is silently transformed into a copy (see Item 23 in [Meyers15](#Meyers15))\n\n##### Example, bad\n\n    vector<int> make_vector()\n    {\n        vector<int> result;\n        // ... load result with data\n        return std::move(result);       // bad; just write \"return result;\"\n    }\n\nNever write `return move(local_variable);`, because the language already knows the variable is a move candidate.\nWriting `move` in this code won't help, and can actually be detrimental because on some compilers it interferes with RVO (the return value optimization) by creating an additional reference alias to the local variable.\n\n\n##### Example, bad\n\n    vector<int> v = std::move(make_vector());   // bad; the std::move is entirely redundant\n\nNever write `move` on a returned value such as `x = move(f());` where `f` returns by value.\nThe language already knows that a returned value is a temporary object that can be moved from.\n\n##### Example\n\n    void mover(X&& x)\n    {\n        call_something(std::move(x));         // ok\n        call_something(std::forward<X>(x));   // bad, don't std::forward an rvalue reference\n        call_something(x);                    // suspicious, why not std::move?\n    }\n\n    template<class T>\n    void forwarder(T&& t)\n    {\n        call_something(std::move(t));         // bad, don't std::move a forwarding reference\n        call_something(std::forward<T>(t));   // ok\n        call_something(t);                    // suspicious, why not std::forward?\n    }\n\n##### Enforcement\n\n* Flag use of `std::move(x)` where `x` is an rvalue or the language will already treat it as an rvalue, including `return std::move(local_variable);` and `std::move(f())` on a function that returns by value.\n* Flag functions taking an `S&&` parameter if there is no `const S&` overload to take care of lvalues.\n* Flag a `std::move`d argument passed to a parameter, except when the parameter type is an `X&&` rvalue reference or the type is move-only and the parameter is passed by value.\n* Flag when `std::move` is applied to a forwarding reference (`T&&` where `T` is a template parameter type). Use `std::forward` instead.\n* Flag when `std::move` is applied to other than an rvalue reference to non-const. (More general case of the previous rule to cover the non-forwarding cases.)\n* Flag when `std::forward` is applied to an rvalue reference (`X&&` where `X` is a non-template parameter type). Use `std::move` instead.\n* Flag when `std::forward` is applied to other than a forwarding reference. (More general case of the previous rule to cover the non-moving cases.)\n* Flag when an object is potentially moved from and the next operation is a `const` operation; there should first be an intervening non-`const` operation, ideally assignment, to first reset the object's value.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-new\"></a>ES.60: Avoid `new` and `delete` outside resource management functions",
    "content": "### <a name=\"res-new\"></a>ES.60: Avoid `new` and `delete` outside resource management functions\n\n##### Reason\n\nDirect resource management in application code is error-prone and tedious.\n\n##### Note\n\nThis is also known as the rule of \"No naked `new`!\"\n\n##### Example, bad\n\n    void f(int n)\n    {\n        auto p = new X[n];   // n default constructed Xs\n        // ...\n        delete[] p;\n    }\n\nThere can be code in the `...` part that causes the `delete` never to happen.\n\n**See also**: [R: Resource management](#s-resource)\n\n##### Enforcement\n\nFlag naked `new`s and naked `delete`s.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-del\"></a>ES.61: Delete arrays using `delete[]` and non-arrays using `delete`",
    "content": "### <a name=\"res-del\"></a>ES.61: Delete arrays using `delete[]` and non-arrays using `delete`\n\n##### Reason\n\nThat's what the language requires, and mismatches can lead to resource release errors and/or memory corruption.\n\n##### Example, bad\n\n    void f(int n)\n    {\n        auto p = new X[n];   // n default constructed Xs\n        // ...\n        delete p;   // error: just delete the object p, rather than delete the array p[]\n    }\n\n##### Note\n\nThis example not only violates the [no naked `new` rule](#res-new) as in the previous example, it has many more problems.\n\n##### Enforcement\n\n* Flag mismatched `new` and `delete` if they are in the same scope.\n* Flag mismatched `new` and `delete` if they are in a constructor/destructor pair.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-arr2\"></a>ES.62: Don't compare pointers into different arrays",
    "content": "### <a name=\"res-arr2\"></a>ES.62: Don't compare pointers into different arrays\n\n##### Reason\n\nThe result of doing so is undefined.\n\n##### Example, bad\n\n    void f()\n    {\n        int a1[7];\n        int a2[9];\n        if (&a1[5] < &a2[7]) {}       // bad: undefined\n        if (0 < &a1[5] - &a2[7]) {}   // bad: undefined\n    }\n\n##### Note\n\nThis example has many more problems.\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-slice\"></a>ES.63: Don't slice",
    "content": "### <a name=\"res-slice\"></a>ES.63: Don't slice\n\n##### Reason\n\nSlicing -- that is, copying only part of an object using assignment or initialization -- most often leads to errors because\nthe object was meant to be considered as a whole.\nIn the rare cases where the slicing was deliberate the code can be surprising.\n\n##### Example\n\n    class Shape { /* ... */ };\n    class Circle : public Shape { /* ... */ Point c; int r; };\n\n    Circle c { {0, 0}, 42 };\n    Shape s {c};    // copy construct only the Shape part of Circle\n    s = c;          // or copy assign only the Shape part of Circle\n\n    void assign(const Shape& src, Shape& dest)\n    {\n        dest = src;\n    }\n    Circle c2 { {1, 1}, 43 };\n    assign(c, c2);   // oops, not the whole state is transferred\n    assert(c == c2); // if we supply copying, we should also provide comparison,\n                     // but this will likely return false\n\nThe result will be meaningless because the center and radius will not be copied from `c` into `s`.\nThe first defense against this is to [define the base class `Shape` not to allow this](#rc-copy-virtual).\n\n##### Alternative\n\nIf you mean to slice, define an explicit operation to do so.\nThis saves readers from confusion.\nFor example:\n\n    class Smiley : public Circle {\n        public:\n        Circle copy_circle();\n        // ...\n    };\n\n    Smiley sm { /* ... */ };\n    Circle c1 {sm};  // ideally prevented by the definition of Circle\n    Circle c2 {sm.copy_circle()};\n\n##### Enforcement\n\nWarn against slicing.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-construct\"></a>ES.64: Use the `T{e}`notation for construction",
    "content": "### <a name=\"res-construct\"></a>ES.64: Use the `T{e}`notation for construction\n\n##### Reason\n\nThe `T{e}` construction syntax makes it explicit that construction is desired.\nThe `T{e}` construction syntax doesn't allow narrowing.\n`T{e}` is the only safe and general expression for constructing a value of type `T` from an expression `e`.\nThe casts notations `T(e)` and `(T)e` are neither safe nor general.\n\n##### Example\n\nFor built-in types, the construction notation protects against narrowing and reinterpretation\n\n    void use(char ch, int i, double d, char* p, long long lng)\n    {\n        int x1 = int{ch};     // OK, but redundant\n        int x2 = int{d};      // error: double->int narrowing; use a cast if you need to\n        int x3 = int{p};      // error: pointer to->int; use a reinterpret_cast if you really need to\n        int x4 = int{lng};    // error: long long->int narrowing; use a cast if you need to\n\n        int y1 = int(ch);     // OK, but redundant\n        int y2 = int(d);      // bad: double->int narrowing; use a cast if you need to\n        int y3 = int(p);      // bad: pointer to->int; use a reinterpret_cast if you really need to\n        int y4 = int(lng);    // bad: long long->int narrowing; use a cast if you need to\n\n        int z1 = (int)ch;     // OK, but redundant\n        int z2 = (int)d;      // bad: double->int narrowing; use a cast if you need to\n        int z3 = (int)p;      // bad: pointer to->int; use a reinterpret_cast if you really need to\n        int z4 = (int)lng;    // bad: long long->int narrowing; use a cast if you need to\n    }\n\nThe integer to/from pointer conversions are implementation defined when using the `T(e)` or `(T)e` notations, and non-portable\nbetween platforms with different integer and pointer sizes.\n\n##### Note\n\n[Avoid casts](#res-casts) (explicit type conversion) and if you must [prefer named casts](#res-casts-named).\n\n##### Note\n\nWhen unambiguous, the `T` can be left out of `T{e}`.\n\n    complex<double> f(complex<double>);\n\n    auto z = f({2*pi, 1});\n\n##### Note\n\nThe construction notation is the most general [initializer notation](#res-list).\n\n##### Exception\n\n`std::vector` and other containers were defined before we had `{}` as a notation for construction.\nConsider:\n\n    vector<string> vs {10};                           // ten empty strings\n    vector<int> vi1 {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};  // ten elements 1..10\n    vector<int> vi2 {10};                             // one element with the value 10\n\nHow do we get a `vector` of 10 default initialized `int`s?\n\n    vector<int> v3(10); // ten elements with value 0\n\nThe use of `()` rather than `{}` for number of elements is conventional (going back to the early 1980s), hard to change, but still\na design error: for a container where the element type can be confused with the number of elements, we have an ambiguity that\nmust be resolved.\nThe conventional resolution is to interpret `{10}` as a list of one element and use `(10)` to distinguish a size.\n\nThis mistake need not be repeated in new code.\nWe can define a type to represent the number of elements:\n\n    struct Count { int n; };\n\n    template<typename T>\n    class Vector {\n    public:\n        Vector(Count n);                     // n default-initialized elements\n        Vector(initializer_list<T> init);    // init.size() elements\n        // ...\n    };\n\n    Vector<int> v1{10};\n    Vector<int> v2{Count{10}};\n    Vector<Count> v3{Count{10}};    // yes, there is still a very minor problem\n\nThe main problem left is to find a suitable name for `Count`.\n\n##### Enforcement\n\nFlag the C-style `(T)e` and functional-style `T(e)` casts.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-deref\"></a>ES.65: Don't dereference an invalid pointer",
    "content": "### <a name=\"res-deref\"></a>ES.65: Don't dereference an invalid pointer\n\n##### Reason\n\nDereferencing an invalid pointer, such as `nullptr`, is undefined behavior, typically leading to immediate crashes,\nwrong results, or memory corruption.\n\n##### Note\n\nBy pointer here we mean any indirection to an object, including equivalently an iterator or view.\n\n##### Note\n\nThis rule is an obvious and well-known language rule, but can be hard to follow.\nIt takes good coding style, library support, and static analysis to eliminate violations without major overhead.\nThis is a major part of the discussion of [C++'s model for type- and resource-safety](#Stroustrup15).\n\n**See also**:\n\n* Use [RAII](#rr-raii) to avoid lifetime problems.\n* Use [unique_ptr](#rf-unique_ptr) to avoid lifetime problems.\n* Use [shared_ptr](#rf-shared_ptr) to avoid lifetime problems.\n* Use [references](#rf-ptr-ref) when `nullptr` isn't a possibility.\n* Use [not_null](#rf-nullptr) to catch unexpected `nullptr` early.\n* Use the [bounds profile](#ss-bounds) to avoid range errors.\n\n\n##### Example\n\n    void f()\n    {\n        int x = 0;\n        int* p = &x;\n\n        if (condition()) {\n            int y = 0;\n            p = &y;\n        } // invalidates p\n\n        *p = 42;            // BAD, p might be invalid if the branch was taken\n    }\n\nTo resolve the problem, either extend the lifetime of the object the pointer is intended to refer to, or shorten the lifetime of the pointer (move the dereference to before the pointed-to object's lifetime ends).\n\n    void f1()\n    {\n        int x = 0;\n        int* p = &x;\n\n        int y = 0;\n        if (condition()) {\n            p = &y;\n        }\n\n        *p = 42;            // OK, p points to x or y and both are still in scope\n    }\n\nUnfortunately, most invalid pointer problems are harder to spot and harder to fix.\n\n##### Example\n\n    void f(int* p)\n    {\n        int x = *p; // BAD: how do we know that p is valid?\n    }\n\nThere is a huge amount of such code.\nMost works -- after lots of testing -- but in isolation it is impossible to tell whether `p` could be the `nullptr`.\nConsequently, this is also a major source of errors.\nThere are many approaches to dealing with this potential problem:\n\n    void f1(int* p) // deal with nullptr\n    {\n        if (!p) {\n            // deal with nullptr (allocate, return, throw, make p point to something, whatever)\n        }\n        int x = *p;\n    }\n\nThere are two potential problems with testing for `nullptr`:\n\n* it is not always obvious what to do if we find `nullptr`\n* the test can be redundant and/or relatively expensive\n* it is not obvious if the test is to protect against a violation or part of the required logic.\n\n<!-- comment needed for code block after list -->\n    void f2(int* p) // state that p is not supposed to be nullptr\n    {\n        assert(p);\n        int x = *p;\n    }\n\nThis would carry a cost only when the assertion checking was enabled and would give a compiler/analyzer useful information.\nThis would work even better if/when C++ gets direct support for contracts:\n\n    void f3(int* p) // state that p is not supposed to be nullptr\n        [[expects: p]]\n    {\n        int x = *p;\n    }\n\nAlternatively, we could use `gsl::not_null` to ensure that `p` is not the `nullptr`.\n\n    void f(not_null<int*> p)\n    {\n        int x = *p;\n    }\n\nThese remedies take care of `nullptr` only.\nRemember that there are other ways of getting an invalid pointer.\n\n##### Example\n\n    void f(int* p)  // old code, doesn't use owner\n    {\n        delete p;\n    }\n\n    void g()        // old code: uses naked new\n    {\n        auto q = new int{7};\n        f(q);\n        int x = *q; // BAD: dereferences invalid pointer\n    }\n\n##### Example\n\n    void f()\n    {\n        vector<int> v(10);\n        int* p = &v[5];\n        v.push_back(99); // could reallocate v's elements\n        int x = *p; // BAD: dereferences potentially invalid pointer\n    }\n\n##### Enforcement\n\nThis rule is part of the [lifetime safety profile](#ss-lifetime)\n\n* Flag a dereference of a pointer that points to an object that has gone out of scope\n* Flag a dereference of a pointer that might have been invalidated by assigning a `nullptr`\n* Flag a dereference of a pointer that might have been invalidated by a `delete`\n* Flag a dereference to a pointer to a container element that might have been invalidated by dereference\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "ES.stmt: Statements",
    "content": "## ES.stmt: Statements\n\nStatements control the flow of control (except for function calls and exception throws, which are expressions).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-switch-if\"></a>ES.70: Prefer a `switch`-statement to an `if`-statement when there is a choice",
    "content": "### <a name=\"res-switch-if\"></a>ES.70: Prefer a `switch`-statement to an `if`-statement when there is a choice\n\n##### Reason\n\n* Readability.\n* Efficiency: A `switch` compares against constants and is usually better optimized than a series of tests in an `if`-`then`-`else` chain.\n* A `switch` enables some heuristic consistency checking. For example, have all values of an `enum` been covered? If not, is there a `default`?\n\n##### Example\n\n    void use(int n)\n    {\n        switch (n) {   // good\n        case 0:\n            // ...\n            break;\n        case 7:\n            // ...\n            break;\n        default:\n            // ...\n            break;\n        }\n    }\n\nrather than:\n\n    void use2(int n)\n    {\n        if (n == 0)   // bad: if-then-else chain comparing against a set of constants\n            // ...\n        else if (n == 7)\n            // ...\n    }\n\n##### Enforcement\n\nFlag `if`-`then`-`else` chains that check against constants (only).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-for-range\"></a>ES.71: Prefer a range-`for`-statement to a `for`-statement when there is a choice",
    "content": "### <a name=\"res-for-range\"></a>ES.71: Prefer a range-`for`-statement to a `for`-statement when there is a choice\n\n##### Reason\n\nReadability. Error prevention. Efficiency.\n\n##### Example\n\n    for (gsl::index i = 0; i < v.size(); ++i)   // bad\n        cout << v[i] << '\\n';\n\n    for (auto p = v.begin(); p != v.end(); ++p)   // bad\n        cout << *p << '\\n';\n\n    for (auto& x : v)    // OK\n        cout << x << '\\n';\n\n    for (gsl::index i = 1; i < v.size(); ++i) // touches two elements: can't be a range-for\n        cout << v[i] + v[i - 1] << '\\n';\n\n    for (gsl::index i = 0; i < v.size(); ++i) // possible side effect: can't be a range-for\n        cout << f(v, &v[i]) << '\\n';\n\n    for (gsl::index i = 0; i < v.size(); ++i) { // body messes with loop variable: can't be a range-for\n        if (i % 2 != 0)\n            cout << v[i] << '\\n'; // output odd elements\n    }\n\nA human or a good static analyzer might determine that there really isn't a side effect on `v` in `f(v, &v[i])` so that the loop can be rewritten.\n\n\"Messing with the loop variable\" in the body of a loop is typically best avoided.\n\n##### Note\n\nDon't use expensive copies of the loop variable of a range-`for` loop:\n\n    for (string s : vs) // ...\n\nThis will copy each element of `vs` into `s`. Better:\n\n    for (string& s : vs) // ...\n\nBetter still, if the loop variable isn't modified or copied:\n\n    for (const string& s : vs) // ...\n\n##### Enforcement\n\nLook at loops, if a traditional loop just looks at each element of a sequence, and there are no side effects on what it does with the elements, rewrite the loop to a ranged-`for` loop.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-for-while\"></a>ES.72: Prefer a `for`-statement to a `while`-statement when there is an obvious loop variable",
    "content": "### <a name=\"res-for-while\"></a>ES.72: Prefer a `for`-statement to a `while`-statement when there is an obvious loop variable\n\n##### Reason\n\nReadability: the complete logic of the loop is visible \"up front\". The scope of the loop variable can be limited.\n\n##### Example\n\n    for (gsl::index i = 0; i < vec.size(); i++) {\n        // do work\n    }\n\n##### Example, bad\n\n    int i = 0;\n    while (i < vec.size()) {\n        // do work\n        i++;\n    }\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-while-for\"></a>ES.73: Prefer a `while`-statement to a `for`-statement when there is no obvious loop variable",
    "content": "### <a name=\"res-while-for\"></a>ES.73: Prefer a `while`-statement to a `for`-statement when there is no obvious loop variable\n\n##### Reason\n\nReadability.\n\n##### Example\n\n    int events = 0;\n    for (; wait_for_event(); ++events) {  // bad, confusing\n        // ...\n    }\n\nThe \"event loop\" is misleading because the `events` counter has nothing to do with the loop condition (`wait_for_event()`).\nBetter\n\n    int events = 0;\n    while (wait_for_event()) {      // better\n        ++events;\n        // ...\n    }\n\n##### Enforcement\n\nFlag actions in `for`-initializers and `for`-increments that do not relate to the `for`-condition.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-for-init\"></a>ES.74: Prefer to declare a loop variable in the initializer part of a `for`-statement",
    "content": "### <a name=\"res-for-init\"></a>ES.74: Prefer to declare a loop variable in the initializer part of a `for`-statement\n\nSee [ES.6](#res-cond)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-do\"></a>ES.75: Avoid `do`-statements",
    "content": "### <a name=\"res-do\"></a>ES.75: Avoid `do`-statements\n\n##### Reason\n\nReadability, avoidance of errors.\nThe termination condition is at the end (where it can be overlooked) and the condition is not checked the first time through.\n\n##### Example\n\n    int x;\n    do {\n        cin >> x;\n        // ...\n    } while (x < 0);\n\n##### Note\n\nYes, there are genuine examples where a `do`-statement is a clear statement of a solution, but also many bugs.\n\n##### Enforcement\n\nFlag `do`-statements.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-goto\"></a>ES.76: Avoid `goto`",
    "content": "### <a name=\"res-goto\"></a>ES.76: Avoid `goto`\n\n##### Reason\n\nReadability, avoidance of errors. There are better control structures for humans; `goto` is for machine generated code.\n\n##### Exception\n\nBreaking out of a nested loop.\nIn that case, always jump forwards.\n\n    for (int i = 0; i < imax; ++i)\n        for (int j = 0; j < jmax; ++j) {\n            if (a[i][j] > elem_max) goto finished;\n            // ...\n        }\n    finished:\n    // ...\n\n##### Example, bad\n\nThere is a fair amount of use of the C goto-exit idiom:\n\n    void f()\n    {\n        // ...\n            goto exit;\n        // ...\n            goto exit;\n        // ...\n    exit:\n        // ... common cleanup code ...\n    }\n\nThis is an ad-hoc simulation of destructors.\nDeclare your resources with handles with destructors that clean up.\nIf for some reason you cannot handle all cleanup with destructors for the variables used,\nconsider `gsl::finally()` as a cleaner and more reliable alternative to `goto exit`\n\n##### Enforcement\n\n* Flag `goto`. Better still flag all `goto`s that do not jump from a nested loop to the statement immediately after a nest of loops.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-continue\"></a>ES.77: Minimize the use of `break` and `continue` in loops",
    "content": "### <a name=\"res-continue\"></a>ES.77: Minimize the use of `break` and `continue` in loops\n\n##### Reason\n\n In a non-trivial loop body, it is easy to overlook a `break` or a `continue`.\n\n A `break` in a loop has a dramatically different meaning than a `break` in a `switch`-statement\n (and you can have `switch`-statement in a loop and a loop in a `switch`-case).\n\n##### Example\n\n    switch(x) {\n    case 1 :\n        while (/* some condition */) {\n            // ...\n        break;\n        } // Oops! break switch or break while intended?\n    case 2 :\n        // ...\n        break;\n    }\n\n##### Alternative\n\nOften, a loop that requires a `break` is a good candidate for a function (algorithm), in which case the `break` becomes a `return`.\n\n    //Original code: break inside loop\n    void use1()\n    {\n        std::vector<T> vec = {/* initialized with some values */};\n        T value;\n        for (const T item : vec) {\n            if (/* some condition*/) {\n                value = item;\n                break;\n            }\n        }\n        /* then do something with value */\n    }\n\n    //BETTER: create a function and return inside loop\n    T search(const std::vector<T> &vec)\n    {\n        for (const T &item : vec) {\n            if (/* some condition*/) return item;\n        }\n        return T(); //default value\n    }\n\n    void use2()\n    {\n        std::vector<T> vec = {/* initialized with some values */};\n        T value = search(vec);\n        /* then do something with value */\n    }\n\nOften, a loop that uses `continue` can equivalently and as clearly be expressed by an `if`-statement.\n\n    for (int item : vec) {  // BAD\n        if (item%2 == 0) continue;\n        if (item == 5) continue;\n        if (item > 10) continue;\n        /* do something with item */\n    }\n\n    for (int item : vec) {  // GOOD\n        if (item%2 != 0 && item != 5 && item <= 10) {\n            /* do something with item */\n        }\n    }\n\n##### Note\n\nIf you really need to break out a loop, a `break` is typically better than alternatives such as [modifying the loop variable](#res-loop-counter) or a [`goto`](#res-goto):\n\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-break\"></a>ES.78: Don't rely on implicit fallthrough in `switch` statements",
    "content": "### <a name=\"res-break\"></a>ES.78: Don't rely on implicit fallthrough in `switch` statements\n\n##### Reason\n\nAlways end a non-empty `case` with a `break`. Accidentally leaving out a `break` is a fairly common bug.\nA deliberate fallthrough can be a maintenance hazard and should be rare and explicit.\n\n##### Example\n\n    switch (eventType) {\n    case Information:\n        update_status_bar();\n        break;\n    case Warning:\n        write_event_log();\n        // Bad - implicit fallthrough\n    case Error:\n        display_error_window();\n        break;\n    }\n\nMultiple case labels of a single statement is OK:\n\n    switch (x) {\n    case 'a':\n    case 'b':\n    case 'f':\n        do_something(x);\n        break;\n    }\n\nReturn statements in a case label are also OK:\n\n    switch (x) {\n    case 'a':\n        return 1;\n    case 'b':\n        return 2;\n    case 'c':\n        return 3;\n    }\n\n##### Exceptions\n\nIn rare cases if fallthrough is deemed appropriate, be explicit and use the `[[fallthrough]]` annotation:\n\n    switch (eventType) {\n    case Information:\n        update_status_bar();\n        break;\n    case Warning:\n        write_event_log();\n        [[fallthrough]];\n    case Error:\n        display_error_window();\n        break;\n    }\n\n##### Note\n\n##### Enforcement\n\nFlag all implicit fallthroughs from non-empty `case`s.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-default\"></a>ES.79: Use `default` to handle common cases (only)",
    "content": "### <a name=\"res-default\"></a>ES.79: Use `default` to handle common cases (only)\n\n##### Reason\n\n Code clarity.\n Improved opportunities for error detection.\n\n##### Example\n\n    enum E { a, b, c, d };\n\n    void f1(E x)\n    {\n        switch (x) {\n        case a:\n            do_something();\n            break;\n        case b:\n            do_something_else();\n            break;\n        default:\n            take_the_default_action();\n            break;\n        }\n    }\n\nHere it is clear that there is a default action and that cases `a` and `b` are special.\n\n##### Example\n\nBut what if there is no default action and you mean to handle only specific cases?\nIn that case, have an empty default or else it is impossible to know if you meant to handle all cases:\n\n    void f2(E x)\n    {\n        switch (x) {\n        case a:\n            do_something();\n            break;\n        case b:\n            do_something_else();\n            break;\n        default:\n            // do nothing for the rest of the cases\n            break;\n        }\n    }\n\nIf you leave out the `default`, a maintainer and/or a compiler might reasonably assume that you intended to handle all cases:\n\n    void f2(E x)\n    {\n        switch (x) {\n        case a:\n            do_something();\n            break;\n        case b:\n        case c:\n            do_something_else();\n            break;\n        }\n    }\n\nDid you forget case `d` or deliberately leave it out?\nForgetting a case typically happens when a case is added to an enumeration and the person doing so fails to add it to every\nswitch over the enumerators.\n\n##### Enforcement\n\nFlag `switch`-statements over an enumeration that don't handle all enumerators and do not have a `default`.\nThis might yield too many false positives in some code bases; if so, flag only `switch`es that handle most but not all cases\n(that was the strategy of the very first C++ compiler).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-noname\"></a>ES.84: Don't try to declare a local variable with no name",
    "content": "### <a name=\"res-noname\"></a>ES.84: Don't try to declare a local variable with no name\n\n##### Reason\n\nThere is no such thing.\nWhat looks to a human like a variable without a name is to the compiler a statement consisting of a temporary that immediately goes out of scope.\n\n##### Example, bad\n\n    void f()\n    {\n        lock_guard<mutex>{mx};   // Bad\n        // ...\n    }\n\nThis declares an unnamed `lock_guard` object that immediately goes out of scope at the point of the semicolon.\nThis is not an uncommon mistake.\nIn particular, this particular example can lead to hard-to-find race conditions.\n\n##### Note\n\nUnnamed function arguments are fine.\n\n##### Enforcement\n\nFlag statements that are just a temporary.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-empty\"></a>ES.85: Make empty statements visible",
    "content": "### <a name=\"res-empty\"></a>ES.85: Make empty statements visible\n\n##### Reason\n\nReadability.\n\n##### Example\n\n    for (i = 0; i < max; ++i);   // BAD: the empty statement is easily overlooked\n    v[i] = f(v[i]);\n\n    for (auto x : v) {           // better\n        // nothing\n    }\n    v[i] = f(v[i]);\n\n##### Enforcement\n\nFlag empty statements that are not blocks and don't contain comments.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-loop-counter\"></a>ES.86: Avoid modifying loop control variables inside the body of raw for-loops",
    "content": "### <a name=\"res-loop-counter\"></a>ES.86: Avoid modifying loop control variables inside the body of raw for-loops\n\n##### Reason\n\nThe loop control up front should enable correct reasoning about what is happening inside the loop. Modifying loop counters in both the iteration-expression and inside the body of the loop is a perennial source of surprises and bugs.\n\n##### Example\n\n    for (int i = 0; i < 10; ++i) {\n        // no updates to i -- ok\n    }\n\n    for (int i = 0; i < 10; ++i) {\n        //\n        if (/* something */) ++i; // BAD\n        //\n    }\n\n    bool skip = false;\n    for (int i = 0; i < 10; ++i) {\n        if (skip) { skip = false; continue; }\n        //\n        if (/* something */) skip = true;  // Better: using two variables for two concepts.\n        //\n    }\n\n##### Enforcement\n\nFlag variables that are potentially updated (have a non-`const` use) in both the loop control iteration-expression and the loop body.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-if\"></a>ES.87: Don't add redundant `==` or `!=` to conditions",
    "content": "### <a name=\"res-if\"></a>ES.87: Don't add redundant `==` or `!=` to conditions\n\n##### Reason\n\nDoing so avoids verbosity and eliminates some opportunities for mistakes.\nHelps make style consistent and conventional.\n\n##### Example\n\nBy definition, a condition in an `if`-statement, `while`-statement, or a `for`-statement selects between `true` and `false`.\nA numeric value is compared to `0` and a pointer value to `nullptr`.\n\n    // These all mean \"if p is not nullptr\"\n    if (p) { ... }            // good\n    if (p != 0) { ... }       // redundant !=0, bad: don't use 0 for pointers\n    if (p != nullptr) { ... } // redundant !=nullptr, not recommended\n\nOften, `if (p)` is read as \"if `p` is valid\" which is a direct expression of the programmers intent,\nwhereas `if (p != nullptr)` would be a long-winded workaround.\n\n##### Example\n\nThis rule is especially useful when a declaration is used as a condition\n\n    if (auto pc = dynamic_cast<Circle*>(ps)) { ... } // execute if ps points to a kind of Circle, good\n\n    if (auto pc = dynamic_cast<Circle*>(ps); pc != nullptr) { ... } // not recommended\n\n##### Example\n\nNote that implicit conversions to bool are applied in conditions.\nFor example:\n\n    for (string s; cin >> s; ) v.push_back(s);\n\nThis invokes `istream`'s `operator bool()`.\n\n##### Note\n\nExplicit comparison of an integer to `0` is in general not redundant.\nThe reason is that (as opposed to pointers and Booleans) an integer often has more than two reasonable values.\nFurthermore `0` (zero) is often used to indicate success.\nConsequently, it is best to be specific about the comparison.\n\n    void f(int i)\n    {\n        if (i)            // suspect\n        // ...\n        if (i == success) // possibly better\n        // ...\n    }\n\nAlways remember that an integer can have more than two values.\n\n##### Example, bad\n\nIt has been noted that\n\n    if(strcmp(p1, p2)) { ... }   // are the two C-style strings equal? (mistake!)\n\nis a common beginners error.\nIf you use C-style strings, you must know the `<cstring>` functions well.\nBeing verbose and writing\n\n    if(strcmp(p1, p2) != 0) { ... }   // are the two C-style strings equal? (mistake!)\n\nwould not in itself save you.\n\n##### Note\n\nThe opposite condition is most easily expressed using a negation:\n\n    // These all mean \"if p is nullptr\"\n    if (!p) { ... }           // good\n    if (p == 0) { ... }       // redundant == 0, bad: don't use 0 for pointers\n    if (p == nullptr) { ... } // redundant == nullptr, not recommended\n\n##### Enforcement\n\nEasy, just check for redundant use of `!=` and `==` in conditions.\n\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-numbers\"></a>Arithmetic",
    "content": "## <a name=\"ss-numbers\"></a>Arithmetic\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-mix\"></a>ES.100: Don't mix signed and unsigned arithmetic",
    "content": "### <a name=\"res-mix\"></a>ES.100: Don't mix signed and unsigned arithmetic\n\n##### Reason\n\nAvoid wrong results.\n\n##### Example\n\n    int x = -3;\n    unsigned int y = 7;\n\n    cout << x - y << '\\n';  // unsigned result, possibly 4294967286\n    cout << x + y << '\\n';  // unsigned result: 4\n    cout << x * y << '\\n';  // unsigned result, possibly 4294967275\n\nIt is harder to spot the problem in more realistic examples.\n\n##### Note\n\nUnfortunately, C++ uses signed integers for array subscripts and the standard library uses unsigned integers for container subscripts.\nThis precludes consistency. Use `gsl::index` for subscripts; [see ES.107](#res-subscripts).\n\n##### Enforcement\n\n* Compilers already know and sometimes warn.\n* (To avoid noise) Do not flag on a mixed signed/unsigned comparison where one of the arguments is `sizeof` or a call to container `.size()` and the other is `ptrdiff_t`.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-unsigned\"></a>ES.101: Use unsigned types for bit manipulation",
    "content": "### <a name=\"res-unsigned\"></a>ES.101: Use unsigned types for bit manipulation\n\n##### Reason\n\nUnsigned types support bit manipulation without surprises from sign bits.\n\n##### Example\n\n    unsigned char x = 0b1010'1010;\n    unsigned char y = ~x;   // y == 0b0101'0101;\n\n##### Note\n\nUnsigned types can also be useful for modular arithmetic.\nHowever, if you want modular arithmetic add\ncomments as necessary noting the reliance on wraparound behavior, as such code\ncan be surprising for many programmers.\n\n##### Enforcement\n\n* Just about impossible in general because of the use of unsigned subscripts in the standard library\n* ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-signed\"></a>ES.102: Use signed types for arithmetic",
    "content": "### <a name=\"res-signed\"></a>ES.102: Use signed types for arithmetic\n\n##### Reason\n\nBecause most arithmetic is assumed to be signed;\n`x - y` yields a negative number when `y > x` except in the rare cases where you really want modular arithmetic.\n\n##### Example\n\nUnsigned arithmetic can yield surprising results if you are not expecting it.\nThis is even more true for mixed signed and unsigned arithmetic.\n\n    template<typename T, typename T2>\n    T subtract(T x, T2 y)\n    {\n        return x - y;\n    }\n\n    void test()\n    {\n        int s = 5;\n        unsigned int us = 5;\n        cout << subtract(s, 7) << '\\n';       // -2\n        cout << subtract(us, 7u) << '\\n';     // 4294967294\n        cout << subtract(s, 7u) << '\\n';      // -2\n        cout << subtract(us, 7) << '\\n';      // 4294967294\n        cout << subtract(s, us + 2) << '\\n';  // -2\n        cout << subtract(us, s + 2) << '\\n';  // 4294967294\n    }\n\nHere we have been very explicit about what's happening,\nbut if you had seen `us - (s + 2)` or `s += 2; ...; us - s`, would you reliably have suspected that the result would print as `4294967294`?\n\n##### Exception\n\nUse unsigned types if you really want modular arithmetic - add\ncomments as necessary noting the reliance on overflow behavior, as such code\nis going to be surprising for many programmers.\n\n##### Example\n\nThe standard library uses unsigned types for subscripts.\nThe built-in array uses signed types for subscripts.\nThis makes surprises (and bugs) inevitable.\n\n    int a[10];\n    for (int i = 0; i < 10; ++i) a[i] = i;\n    vector<int> v(10);\n    // compares signed to unsigned; some compilers warn, but we should not\n    for (gsl::index i = 0; i < v.size(); ++i) v[i] = i;\n\n    int a2[-2];         // error: negative size\n\n    // OK, but the number of ints (4294967294) is so large that we should get an exception\n    vector<int> v2(-2);\n\n Use `gsl::index` for subscripts; [see ES.107](#res-subscripts).\n\n##### Enforcement\n\n* Flag mixed signed and unsigned arithmetic\n* Flag results of unsigned arithmetic assigned to or printed as signed.\n* Flag negative literals (e.g. `-2`) used as container subscripts.\n* (To avoid noise) Do not flag on a mixed signed/unsigned comparison where one of the arguments is `sizeof` or a call to container `.size()` and the other is `ptrdiff_t`.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-overflow\"></a>ES.103: Don't overflow",
    "content": "### <a name=\"res-overflow\"></a>ES.103: Don't overflow\n\n##### Reason\n\nOverflow usually makes your numeric algorithm meaningless.\nIncrementing a value beyond a maximum value can lead to memory corruption and undefined behavior.\n\n##### Example, bad\n\n    int a[10];\n    a[10] = 7;   // bad, array bounds overflow\n\n    for (int n = 0; n <= 10; ++n)\n        a[n] = 9;   // bad, array bounds overflow\n\n##### Example, bad\n\n    int n = numeric_limits<int>::max();\n    int m = n + 1;   // bad, numeric overflow\n\n##### Example, bad\n\n    int area(int h, int w) { return h * w; }\n\n    auto a = area(10'000'000, 100'000'000);   // bad, numeric overflow\n\n##### Exception\n\nUse unsigned types if you really want modular arithmetic.\n\n**Alternative**: For critical applications that can afford some overhead, use a range-checked integer and/or floating-point type.\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-underflow\"></a>ES.104: Don't underflow",
    "content": "### <a name=\"res-underflow\"></a>ES.104: Don't underflow\n\n##### Reason\n\nDecrementing a value beyond a minimum value can lead to memory corruption and undefined behavior.\n\n##### Example, bad\n\n    int a[10];\n    a[-2] = 7;   // bad\n\n    int n = 101;\n    while (n--)\n        a[n - 1] = 9;   // bad (twice)\n\n##### Exception\n\nUse unsigned types if you really want modular arithmetic.\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-zero\"></a>ES.105: Don't divide by integer zero",
    "content": "### <a name=\"res-zero\"></a>ES.105: Don't divide by integer zero\n\n##### Reason\n\nThe result is undefined and probably a crash.\n\n##### Note\n\nThis also applies to `%`.\n\n##### Example, bad\n\n    int divide(int a, int b)\n    {\n        // BAD, should be checked (e.g., in a precondition)\n        return a / b;\n    }\n\n##### Example, good\n\n    int divide(int a, int b)\n    {\n        // good, address via precondition (and replace with contracts once C++ gets them)\n        Expects(b != 0);\n        return a / b;\n    }\n\n    double divide(double a, double b)\n    {\n        // good, address via using double instead\n        return a / b;\n    }\n\n**Alternative**: For critical applications that can afford some overhead, use a range-checked integer and/or floating-point type.\n\n##### Enforcement\n\n* Flag division by an integral value that could be zero\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-nonnegative\"></a>ES.106: Don't try to avoid negative values by using `unsigned`",
    "content": "### <a name=\"res-nonnegative\"></a>ES.106: Don't try to avoid negative values by using `unsigned`\n\n##### Reason\n\nChoosing `unsigned` implies many changes to the usual behavior of integers, including modular arithmetic,\ncan suppress warnings related to overflow,\nand opens the door for errors related to signed/unsigned mixes.\nUsing `unsigned` doesn't actually eliminate the possibility of negative values.\n\n##### Example\n\n    unsigned int u1 = -2;   // Valid: the value of u1 is 4294967294\n    int i1 = -2;\n    unsigned int u2 = i1;   // Valid: the value of u2 is 4294967294\n    int i2 = u2;            // Valid: the value of i2 is -2\n\nThese problems with such (perfectly legal) constructs are hard to spot in real code and are the source of many real-world errors.\nConsider:\n\n    unsigned area(unsigned height, unsigned width) { return height*width; } // [see also](#ri-expects)\n    // ...\n    int height;\n    cin >> height;\n    auto a = area(height, 2);   // if the input is -2 a becomes 4294967292\n\nRemember that `-1` when assigned to an `unsigned int` becomes the largest `unsigned int`.\nAlso, since unsigned arithmetic is modular arithmetic the multiplication didn't overflow, it wrapped around.\n\n##### Example\n\n    unsigned max = 100000;    // \"accidental typo\", I mean to say 10'000\n    unsigned short x = 100;\n    while (x < max) x += 100; // infinite loop\n\nHad `x` been a signed `short`, we could have warned about the undefined behavior upon overflow.\n\n##### Alternatives\n\n* use signed integers and check for `x >= 0`\n* use a positive integer type\n* use an integer subrange type\n* `Assert(-1 < x)`\n\nFor example\n\n    struct Positive {\n        int val;\n        Positive(int x) :val{x} { Assert(0 < x); }\n        operator int() { return val; }\n    };\n\n    int f(Positive arg) { return arg; }\n\n    int r1 = f(2);\n    int r2 = f(-2);  // throws\n\n##### Note\n\n???\n\n##### Enforcement\n\nSee ES.100 Enforcements.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"res-subscripts\"></a>ES.107: Don't use `unsigned` for subscripts, prefer `gsl::index`",
    "content": "### <a name=\"res-subscripts\"></a>ES.107: Don't use `unsigned` for subscripts, prefer `gsl::index`\n\n##### Reason\n\nTo avoid signed/unsigned confusion.\nTo enable better optimization.\nTo enable better error detection.\nTo avoid the pitfalls with `auto` and `int`.\n\n##### Example, bad\n\n    vector<int> vec = /*...*/;\n\n    for (int i = 0; i < vec.size(); i += 2)                    // might not be big enough\n        cout << vec[i] << '\\n';\n    for (unsigned i = 0; i < vec.size(); i += 2)               // risk wraparound\n        cout << vec[i] << '\\n';\n    for (auto i = 0; i < vec.size(); i += 2)                   // might not be big enough\n        cout << vec[i] << '\\n';\n    for (vector<int>::size_type i = 0; i < vec.size(); i += 2) // verbose\n        cout << vec[i] << '\\n';\n    for (auto i = vec.size()-1; i >= 0; i -= 2)                // bug\n        cout << vec[i] << '\\n';\n    for (int i = vec.size()-1; i >= 0; i -= 2)                 // might not be big enough\n        cout << vec[i] << '\\n';\n\n##### Example, good\n\n    vector<int> vec = /*...*/;\n\n    for (gsl::index i = 0; i < vec.size(); i += 2)             // ok\n        cout << vec[i] << '\\n';\n    for (gsl::index i = vec.size()-1; i >= 0; i -= 2)          // ok\n        cout << vec[i] << '\\n';\n\n##### Note\n\nThe built-in array allows signed subscripts.\nThe standard-library containers use unsigned subscripts.\nThus, no perfect and fully compatible solution is possible (unless and until the standard-library containers change to use signed subscripts someday in the future).\nGiven the known problems with unsigned and signed/unsigned mixtures, better stick to (signed) integers of a sufficient size, which is guaranteed by `gsl::index`.\n\n##### Example\n\n    template<typename T>\n    struct My_container {\n    public:\n        // ...\n        T& operator[](gsl::index i);    // not unsigned\n        // ...\n    };\n\n##### Example\n\n    ??? demonstrate improved code generation and potential for error detection ???\n\n##### Alternatives\n\nAlternatives for users\n\n* use algorithms\n* use range-for\n* use iterators/pointers\n\n##### Enforcement\n\n* Very tricky as long as the standard-library containers get it wrong.\n* (To avoid noise) Do not flag on a mixed signed/unsigned comparison where one of the arguments is `sizeof` or a call to container `.size()` and the other is `ptrdiff_t`.\n\n\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-performance\"></a>Per: Performance",
    "content": "# <a name=\"s-performance\"></a>Per: Performance\n\n??? should this section be in the main guide???\n\nThis section contains rules for people who need high performance or low-latency.\nThat is, these are rules that relate to how to use as little time and as few resources as possible to achieve a task in a predictably short time.\nThe rules in this section are more restrictive and intrusive than what is needed for many (most) applications.\nDo not navely try to follow them in general code: achieving the goals of low latency requires extra work.\n\nPerformance rule summary:\n\n* [Per.1: Don't optimize without reason](#rper-reason)\n* [Per.2: Don't optimize prematurely](#rper-knuth)\n* [Per.3: Don't optimize something that's not performance critical](#rper-critical)\n* [Per.4: Don't assume that complicated code is necessarily faster than simple code](#rper-simple)\n* [Per.5: Don't assume that low-level code is necessarily faster than high-level code](#rper-low)\n* [Per.6: Don't make claims about performance without measurements](#rper-measure)\n* [Per.7: Design to enable optimization](#rper-efficiency)\n* [Per.10: Rely on the static type system](#rper-type)\n* [Per.11: Move computation from run time to compile time](#rper-comp)\n* [Per.12: Eliminate redundant aliases](#rper-alias)\n* [Per.13: Eliminate redundant indirections](#rper-indirect)\n* [Per.14: Minimize the number of allocations and deallocations](#rper-alloc)\n* [Per.15: Do not allocate on a critical branch](#rper-alloc0)\n* [Per.16: Use compact data structures](#rper-compact)\n* [Per.17: Declare the most used member of a time-critical struct first](#rper-struct)\n* [Per.18: Space is time](#rper-space)\n* [Per.19: Access memory predictably](#rper-access)\n* [Per.30: Avoid context switches on the critical path](#rper-context)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rper-reason\"></a>Per.1: Don't optimize without reason",
    "content": "### <a name=\"rper-reason\"></a>Per.1: Don't optimize without reason\n\n##### Reason\n\nIf there is no need for optimization, the main result of the effort will be more errors and higher maintenance costs.\n\n##### Note\n\nSome people optimize out of habit or because it's fun.\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rper-knuth\"></a>Per.2: Don't optimize prematurely",
    "content": "### <a name=\"rper-knuth\"></a>Per.2: Don't optimize prematurely\n\n##### Reason\n\nElaborately optimized code is usually larger and harder to change than unoptimized code.\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rper-critical\"></a>Per.3: Don't optimize something that's not performance critical",
    "content": "### <a name=\"rper-critical\"></a>Per.3: Don't optimize something that's not performance critical\n\n##### Reason\n\nOptimizing a non-performance-critical part of a program has no effect on system performance.\n\n##### Note\n\nIf your program spends most of its time waiting for the web or for a human, optimization of in-memory computation is probably useless.\n\nPut another way: If your program spends 4% of its processing time doing\ncomputation A and 40% of its time doing computation B, a 50% improvement on A is\nonly as impactful as a 5% improvement on B. (If you don't even know how much\ntime is spent on A or B, see <a href=\"#rper-reason\">Per.1</a> and <a\nhref=\"#rper-knuth\">Per.2</a>.)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rper-simple\"></a>Per.4: Don't assume that complicated code is necessarily faster than simple code",
    "content": "### <a name=\"rper-simple\"></a>Per.4: Don't assume that complicated code is necessarily faster than simple code\n\n##### Reason\n\nSimple code can be very fast. Optimizers sometimes do marvels with simple code\n\n##### Example, good\n\n    // clear expression of intent, fast execution\n\n    vector<uint8_t> v(100000);\n\n    for (auto& c : v)\n        c = ~c;\n\n##### Example, bad\n\n    // intended to be faster, but is often slower\n\n    vector<uint8_t> v(100000);\n\n    for (size_t i = 0; i < v.size(); i += sizeof(uint64_t)) {\n        uint64_t& quad_word = *reinterpret_cast<uint64_t*>(&v[i]);\n        quad_word = ~quad_word;\n    }\n\n##### Note\n\n???\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rper-low\"></a>Per.5: Don't assume that low-level code is necessarily faster than high-level code",
    "content": "### <a name=\"rper-low\"></a>Per.5: Don't assume that low-level code is necessarily faster than high-level code\n\n##### Reason\n\nLow-level code sometimes inhibits optimizations. Optimizers sometimes do marvels with high-level code.\n\n##### Note\n\n???\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rper-measure\"></a>Per.6: Don't make claims about performance without measurements",
    "content": "### <a name=\"rper-measure\"></a>Per.6: Don't make claims about performance without measurements\n\n##### Reason\n\nThe field of performance is littered with myth and bogus folklore.\nModern hardware and optimizers defy naive assumptions; even experts are regularly surprised.\n\n##### Note\n\nGetting good performance measurements can be hard and require specialized tools.\n\n##### Note\n\nA few simple microbenchmarks using Unix `time` or the standard-library `<chrono>` can help dispel the most obvious myths.\nIf you can't measure your complete system accurately, at least try to measure a few of your key operations and algorithms.\nA profiler can help tell you which parts of your system are performance critical.\nOften, you will be surprised.\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rper-efficiency\"></a>Per.7: Design to enable optimization",
    "content": "### <a name=\"rper-efficiency\"></a>Per.7: Design to enable optimization\n\n##### Reason\n\nBecause we often need to optimize the initial design.\nBecause a design that ignores the possibility of later improvement is hard to change.\n\n##### Example\n\nFrom the C (and C++) standard:\n\n    void qsort (void* base, size_t num, size_t size, int (*compar)(const void*, const void*));\n\nWhen did you even want to sort memory?\nReally, we sort sequences of elements, typically stored in containers.\nA call to `qsort` throws away much useful information (e.g., the element type), forces the user to repeat information\nalready known (e.g., the element size), and forces the user to write extra code (e.g., a function to compare `double`s).\nThis implies added work for the programmer, is error-prone, and deprives the compiler of information needed for optimization.\n\n    double data[100];\n    // ... fill a ...\n\n    // 100 chunks of memory of sizeof(double) starting at\n    // address data using the order defined by compare_doubles\n    qsort(data, 100, sizeof(double), compare_doubles);\n\nFrom the point of view of interface design, `qsort` throws away useful information.\n\nWe can do better (in C++98)\n\n    template<typename Iter>\n        void sort(Iter b, Iter e);  // sort [b:e)\n\n    sort(data, data + 100);\n\nHere, we use the compiler's knowledge about the size of the array, the type of elements, and how to compare `double`s.\n\nWith C++20, we can do better still\n\n    // sortable specifies that c must be a\n    // random-access sequence of elements comparable with <\n    void sort(sortable auto& c);\n\n    sort(c);\n\nThe key is to pass sufficient information for a good implementation to be chosen.\nIn this, the `sort` interfaces shown here still have a weakness:\nThey implicitly rely on the element type having less-than (`<`) defined.\nTo complete the interface, we need a second version that accepts a comparison criterion:\n\n    // compare elements of c using r\n    template<random_access_range R, class C> requires sortable<R, C>\n    void sort(R&& r, C c);\n\nThe standard-library specification of `sort` offers those two versions, and more.\n\n##### Note\n\nPremature optimization is said to be [the root of all evil](#rper-knuth), but that's not a reason to despise performance.\nIt is never premature to consider what makes a design amenable to improvement, and improved performance is a commonly desired improvement.\nAim to build a set of habits that by default results in efficient, maintainable, and optimizable code.\nIn particular, when you write a function that is not a one-off implementation detail, consider\n\n* Information passing:\nPrefer clean [interfaces](#s-interfaces) carrying sufficient information for later improvement of implementation.\nNote that information flows into and out of an implementation through the interfaces we provide.\n* Compact data: By default, [use compact data](#rper-compact), such as `std::vector` and [access it in a systematic fashion](#rper-access).\nIf you think you need a linked structure, try to craft the interface so that this structure isn't seen by users.\n* Function argument passing and return:\nDistinguish between mutable and non-mutable data.\nDon't impose a resource management burden on your users.\nDon't impose spurious run-time indirections on your users.\nUse [conventional ways](#rf-conventional) of passing information through an interface;\nunconventional and/or \"optimized\" ways of passing data can seriously complicate later reimplementation.\n* Abstraction:\nDon't overgeneralize; a design that tries to cater for every possible use (and misuse) and defers every design decision for later\n(using compile-time or run-time indirections) is usually a complicated, bloated, hard-to-understand mess.\nGeneralize from concrete examples, preserving performance as we generalize.\nDo not generalize based on mere speculation about future needs.\nThe ideal is zero-overhead generalization.\n* Libraries:\nUse libraries with good interfaces.\nIf no library is available build one yourself and imitate the interface style from a good library.\nThe [standard library](#sl-the-standard-library) is a good first place to look for inspiration.\n* Isolation:\nIsolate your code from messy and/or old-style code by providing an interface of your choosing to it.\nThis is sometimes called \"providing a wrapper\" for the useful/necessary but messy code.\nDon't let bad designs \"bleed into\" your code.\n\n##### Example\n\nConsider:\n\n    template<class ForwardIterator, class T>\n    bool binary_search(ForwardIterator first, ForwardIterator last, const T& val);\n\n`binary_search(begin(c), end(c), 7)` will tell you whether `7` is in `c` or not.\nHowever, it will not tell you where that `7` is or whether there are more than one `7`.\n\nSometimes, just passing the minimal amount of information back (here, `true` or `false`) is sufficient, but a good interface passes\nneeded information back to the caller. Therefore, the standard library also offers\n\n    template<class ForwardIterator, class T>\n    ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T& val);\n\n`lower_bound` returns an iterator to the first match if any, otherwise to the first element greater than `val`, or `last` if no such element is found.\n\nHowever, `lower_bound` still doesn't return enough information for all uses, so the standard library also offers\n\n    template<class ForwardIterator, class T>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& val);\n\n`equal_range` returns a `pair` of iterators specifying the first and one beyond last match.\n\n    auto r = equal_range(begin(c), end(c), 7);\n    for (auto p = r.first; p != r.second; ++p)\n        cout << *p << '\\n';\n\nObviously, these three interfaces are implemented by the same basic code.\nThey are simply three ways of presenting the basic binary search algorithm to users,\nranging from the simplest (\"make simple things simple!\")\nto returning complete, but not always needed, information (\"don't hide useful information\").\nNaturally, crafting such a set of interfaces requires experience and domain knowledge.\n\n##### Note\n\nDo not simply craft the interface to match the first implementation and the first use case you think of.\nOnce your first initial implementation is complete, review it; once you deploy it, mistakes will be hard to remedy.\n\n##### Note\n\nA need for efficiency does not imply a need for [low-level code](#rper-low).\nHigh-level code isn't necessarily slow or bloated.\n\n##### Note\n\nThings have costs.\nDon't be paranoid about costs (modern computers really are very fast),\nbut have a rough idea of the order of magnitude of cost of what you use.\nFor example, have a rough idea of the cost of\na memory access,\na function call,\na string comparison,\na system call,\na disk access,\nand a message through a network.\n\n##### Note\n\nIf you can only think of one implementation, you probably don't have something for which you can devise a stable interface.\nMaybe, it is just an implementation detail - not every piece of code needs a stable interface - but pause and consider.\nOne question that can be useful is\n\"what interface would be needed if this operation should be implemented using multiple threads? be vectorized?\"\n\n##### Note\n\nThis rule does not contradict the [Don't optimize prematurely](#rper-knuth) rule.\nIt complements it, encouraging developers to enable later - appropriate and non-premature - optimization, if and where needed.\n\n##### Enforcement\n\nTricky.\nMaybe looking for `void*` function arguments will find examples of interfaces that hinder later optimization.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rper-type\"></a>Per.10: Rely on the static type system",
    "content": "### <a name=\"rper-type\"></a>Per.10: Rely on the static type system\n\n##### Reason\n\nType violations, weak types (e.g. `void*`s), and low-level code (e.g., manipulation of sequences as individual bytes) make the job of the optimizer much harder. Simple code often optimizes better than hand-crafted complex code.\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rper-comp\"></a>Per.11: Move computation from run time to compile time",
    "content": "### <a name=\"rper-comp\"></a>Per.11: Move computation from run time to compile time\n\n##### Reason\n\nTo decrease code size and run time.\nTo avoid data races by using constants.\nTo catch errors at compile time (and thus eliminate the need for error-handling code).\n\n##### Example\n\n    double square(double d) { return d*d; }\n    static double s2 = square(2);    // old-style: dynamic initialization\n\n    constexpr double ntimes(double d, int n)   // assume 0 <= n\n    {\n            double m = 1;\n            while (n--) m *= d;\n            return m;\n    }\n    constexpr double s3 {ntimes(2, 3)};  // modern-style: compile-time initialization\n\nCode like the initialization of `s2` isn't uncommon, especially for initialization that's a bit more complicated than `square()`.\nHowever, compared to the initialization of `s3` there are two problems:\n\n* we suffer the overhead of a function call at run time\n* `s2` just might be accessed by another thread before the initialization happens.\n\nNote: you can't have a data race on a constant.\n\n##### Example\n\nConsider a popular technique for providing a handle for storing small objects in the handle itself and larger ones on the heap.\n\n    constexpr int on_stack_max = 20;\n\n    template<typename T>\n    struct Scoped {     // store a T in Scoped\n            // ...\n        T obj;\n    };\n\n    template<typename T>\n    struct On_heap {    // store a T on the free store\n            // ...\n            T* objp;\n    };\n\n    template<typename T>\n    using Handle = typename std::conditional<(sizeof(T) <= on_stack_max),\n                        Scoped<T>,      // first alternative\n                        On_heap<T>      // second alternative\n                   >::type;\n\n    void f()\n    {\n        Handle<double> v1;                   // the double goes on the stack\n        Handle<std::array<double, 200>> v2;  // the array goes on the free store\n        // ...\n    }\n\nAssume that `Scoped` and `On_heap` provide compatible user interfaces.\nHere we compute the optimal type to use at compile time.\nThere are similar techniques for selecting the optimal function to call.\n\n##### Note\n\nThe ideal is *not* to try to execute everything at compile time.\nObviously, most computations depend on inputs, so they can't be moved to compile time,\nbut beyond that logical constraint is the fact that complex compile-time computation can seriously increase compile times\nand complicate debugging.\nIt is even possible to slow down code by compile-time computation.\nThis is admittedly rare, but by factoring out a general computation into separate optimal sub-calculations, it is possible to render the instruction cache less effective.\n\n##### Enforcement\n\n* Look for simple functions that might be constexpr (but are not).\n* Look for functions called with all constant-expression arguments.\n* Look for macros that could be constexpr.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rper-alias\"></a>Per.12: Eliminate redundant aliases",
    "content": "### <a name=\"rper-alias\"></a>Per.12: Eliminate redundant aliases\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rper-indirect\"></a>Per.13: Eliminate redundant indirections",
    "content": "### <a name=\"rper-indirect\"></a>Per.13: Eliminate redundant indirections\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rper-alloc\"></a>Per.14: Minimize the number of allocations and deallocations",
    "content": "### <a name=\"rper-alloc\"></a>Per.14: Minimize the number of allocations and deallocations\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rper-alloc0\"></a>Per.15: Do not allocate on a critical branch",
    "content": "### <a name=\"rper-alloc0\"></a>Per.15: Do not allocate on a critical branch\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rper-compact\"></a>Per.16: Use compact data structures",
    "content": "### <a name=\"rper-compact\"></a>Per.16: Use compact data structures\n\n##### Reason\n\nPerformance is typically dominated by memory access times.\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rper-struct\"></a>Per.17: Declare the most used member of a time-critical struct first",
    "content": "### <a name=\"rper-struct\"></a>Per.17: Declare the most used member of a time-critical struct first\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rper-space\"></a>Per.18: Space is time",
    "content": "### <a name=\"rper-space\"></a>Per.18: Space is time\n\n##### Reason\n\nPerformance is typically dominated by memory access times.\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rper-access\"></a>Per.19: Access memory predictably",
    "content": "### <a name=\"rper-access\"></a>Per.19: Access memory predictably\n\n##### Reason\n\nPerformance is very sensitive to cache performance, and cache algorithms favor simple (usually linear) access to adjacent data.\n\n##### Example\n\n    int matrix[rows][cols];\n\n    // bad\n    for (int c = 0; c < cols; ++c)\n        for (int r = 0; r < rows; ++r)\n            sum += matrix[r][c];\n\n    // good\n    for (int r = 0; r < rows; ++r)\n        for (int c = 0; c < cols; ++c)\n            sum += matrix[r][c];\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rper-context\"></a>Per.30: Avoid context switches on the critical path",
    "content": "### <a name=\"rper-context\"></a>Per.30: Avoid context switches on the critical path\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-concurrency\"></a>CP: Concurrency and parallelism",
    "content": "# <a name=\"s-concurrency\"></a>CP: Concurrency and parallelism\n\nWe often want our computers to do many tasks at the same time (or at least appear to do them at the same time).\nThe reasons for doing so vary (e.g., waiting for many events using only a single processor, processing many data streams simultaneously, or utilizing many hardware facilities)\nand so do the basic facilities for expressing concurrency and parallelism.\nHere, we articulate principles and rules for using the ISO standard C++ facilities for expressing basic concurrency and parallelism.\n\nThreads are the machine-level foundation for concurrent and parallel programming.\nThreads allow running multiple sections of a program independently, while sharing\nthe same memory. Concurrent programming is tricky,\nbecause protecting shared data between threads is easier said than done.\nMaking existing single-threaded code execute concurrently can be\nas trivial as adding `std::async` or `std::thread` strategically, or it can\nnecessitate a full rewrite, depending on whether the original code was written\nin a thread-friendly way.\n\nThe concurrency/parallelism rules in this document are designed with three goals\nin mind:\n\n* To help in writing code that is amenable to being used in a threaded\n  environment\n* To show clean, safe ways to use the threading primitives offered by the\n  standard library\n* To offer guidance on what to do when concurrency and parallelism aren't giving\n  the performance gains needed\n\nIt is also important to note that concurrency in C++ is an unfinished\nstory. C++11 introduced many core concurrency primitives, C++14 and C++17 improved on\nthem, and there is much interest in making the writing of\nconcurrent programs in C++ even easier. We expect some of the library-related\nguidance here to change significantly over time.\n\nThis section needs a lot of work (obviously).\nPlease note that we start with rules for relative non-experts.\nReal experts must wait a bit;\ncontributions are welcome,\nbut please think about the majority of programmers who are struggling to get their concurrent programs correct and performant.\n\nConcurrency and parallelism rule summary:\n\n* [CP.1: Assume that your code will run as part of a multi-threaded program](#rconc-multi)\n* [CP.2: Avoid data races](#rconc-races)\n* [CP.3: Minimize explicit sharing of writable data](#rconc-data)\n* [CP.4: Think in terms of tasks, rather than threads](#rconc-task)\n* [CP.8: Don't try to use `volatile` for synchronization](#rconc-volatile)\n* [CP.9: Whenever feasible use tools to validate your concurrent code](#rconc-tools)\n\n**See also**:\n\n* [CP.con: Concurrency](#sscp-con)\n* [CP.coro: Coroutines](#sscp-coro)\n* [CP.par: Parallelism](#sscp-par)\n* [CP.mess: Message passing](#sscp-mess)\n* [CP.vec: Vectorization](#sscp-vec)\n* [CP.free: Lock-free programming](#sscp-free)\n* [CP.etc: Etc. concurrency rules](#sscp-etc)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-multi\"></a>CP.1: Assume that your code will run as part of a multi-threaded program",
    "content": "### <a name=\"rconc-multi\"></a>CP.1: Assume that your code will run as part of a multi-threaded program\n\n##### Reason\n\nIt's hard to be certain that concurrency isn't used now or won't be used sometime in the future.\nCode gets reused.\nLibraries not using threads might be used from some other part of a program that does use threads.\nNote that this rule applies most urgently to library code and least urgently to stand-alone applications.\nHowever, over time, code fragments can turn up in unexpected places.\n\n##### Example, bad\n\n    double cached_computation(int x)\n    {\n        // bad: these statics cause data races in multi-threaded usage\n        static int cached_x = 0.0;\n        static double cached_result = COMPUTATION_OF_ZERO;\n\n        if (cached_x != x) {\n            cached_x = x;\n            cached_result = computation(x);\n        }\n        return cached_result;\n    }\n\nAlthough `cached_computation` works perfectly in a single-threaded environment, in a multi-threaded environment the two `static` variables result in data races and thus undefined behavior.\n\n##### Example, good\n\n    struct ComputationCache {\n        int cached_x = 0;\n        double cached_result = COMPUTATION_OF_ZERO;\n\n        double compute(int x) {\n            if (cached_x != x) {\n                cached_x = x;\n                cached_result = computation(x);\n            }\n            return cached_result;\n        }\n    };\n\nHere the cache is stored as member data of a `ComputationCache` object, rather than as shared static state.\nThis refactoring essentially delegates the concern upward to the caller: a single-threaded program\nmight still choose to have one global `ComputationCache`, while a multi-threaded program might\nhave one `ComputationCache` instance per thread, or one per \"context\" for any definition of \"context.\"\nThe refactored function no longer attempts to manage the allocation of `cached_x`. In that sense,\nthis is an application of the Single Responsibility Principle.\n\nIn this specific example, refactoring for thread-safety also improved reusability in single-threaded\nprograms. It's not hard to imagine that a single-threaded program might want two `ComputationCache` instances\nfor use in different parts of the program, without having them overwrite each other's cached data.\n\nThere are several other ways one might add thread-safety to code written for a standard multi-threaded environment\n(that is, one where the only form of concurrency is `std::thread`):\n\n* Mark the state variables as `thread_local` instead of `static`.\n* Implement concurrency control, for example, protecting access to the two `static` variables with a `static std::mutex`.\n* Refuse to build and/or run in a multi-threaded environment.\n* Provide two implementations: one for single-threaded environments and another for multi-threaded environments.\n\n##### Exception\n\nCode that is never run in a multi-threaded environment.\n\nBe careful: there are many examples where code that was \"known\" to never run in a multi-threaded program\nwas run as part of a multi-threaded program, often years later.\nTypically, such programs lead to a painful effort to remove data races.\nTherefore, code that is never intended to run in a multi-threaded environment should be clearly labeled as such and ideally come with compile or run-time enforcement mechanisms to catch those usage bugs early.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-races\"></a>CP.2: Avoid data races",
    "content": "### <a name=\"rconc-races\"></a>CP.2: Avoid data races\n\n##### Reason\n\nUnless you do, nothing is guaranteed to work and subtle errors will persist.\n\n##### Note\n\nIn a nutshell, if two threads can access the same object concurrently (without synchronization), and at least one is a writer (performing a non-`const` operation), you have a data race.\nFor further information of how to use synchronization well to eliminate data races, please consult a good book about concurrency (see [Carefully study the literature](#rconc-literature)).\n\n##### Example, bad\n\nThere are many examples of data races that exist, some of which are running in\nproduction software at this very moment. One very simple example:\n\n    int get_id()\n    {\n      static int id = 1;\n      return id++;\n    }\n\nThe increment here is an example of a data race. This can go wrong in many ways,\nincluding:\n\n* Thread A loads the value of `id`, the OS context switches A out for some\n  period, during which other threads create hundreds of IDs. Thread A is then\n  allowed to run again, and `id` is written back to that location as A's read of\n  `id` plus one.\n* Thread A and B load `id` and increment it simultaneously.  They both get the\n  same ID.\n\nLocal static variables are a common source of data races.\n\n##### Example, bad:\n\n    void f(fstream& fs, regex pattern)\n    {\n        array<double, max> buf;\n        int sz = read_vec(fs, buf, max);            // read from fs into buf\n        gsl::span<double> s {buf};\n        // ...\n        auto h1 = async([&] { sort(std::execution::par, s); });     // spawn a task to sort\n        // ...\n        auto h2 = async([&] { return find_all(buf, sz, pattern); });   // spawn a task to find matches\n        // ...\n    }\n\nHere, we have a (nasty) data race on the elements of `buf` (`sort` will both read and write).\nAll data races are nasty.\nHere, we managed to get a data race on data on the stack.\nNot all data races are as easy to spot as this one.\n\n##### Example, bad:\n\n    // code not controlled by a lock\n\n    unsigned val;\n\n    if (val < 5) {\n        // ... other thread can change val here ...\n        switch (val) {\n        case 0: // ...\n        case 1: // ...\n        case 2: // ...\n        case 3: // ...\n        case 4: // ...\n        }\n    }\n\nNow, a compiler that does not know that `val` can change will  most likely implement that `switch` using a jump table with five entries.\nThen, a `val` outside the `[0..4]` range will cause a jump to an address that could be anywhere in the program, and execution would proceed there.\nReally, \"all bets are off\" if you get a data race.\nActually, it can be worse still: by looking at the generated code you might be able to determine where the stray jump will go for a given value;\nthis can be a security risk.\n\n##### Enforcement\n\nSome is possible, do at least something.\nThere are commercial and open-source tools that try to address this problem,\nbut be aware that solutions have costs and blind spots.\nStatic tools often have many false positives and run-time tools often have a significant cost.\nWe hope for better tools.\nUsing multiple tools can catch more problems than a single one.\n\nThere are other ways you can mitigate the chance of data races:\n\n* Avoid global data\n* Avoid `static` variables\n* More use of concrete types on the stack (and don't pass pointers around too much)\n* More use of immutable data (literals, `constexpr`, and `const`)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-data\"></a>CP.3: Minimize explicit sharing of writable data",
    "content": "### <a name=\"rconc-data\"></a>CP.3: Minimize explicit sharing of writable data\n\n##### Reason\n\nIf you don't share writable data, you can't have a data race.\nThe less sharing you do, the less chance you have to forget to synchronize access (and get data races).\nThe less sharing you do, the less chance you have to wait on a lock (so performance can improve).\n\n##### Example\n\n    bool validate(const vector<Reading>&);\n    Graph<Temp_node> temperature_gradients(const vector<Reading>&);\n    Image altitude_map(const vector<Reading>&);\n    // ...\n\n    void process_readings(const vector<Reading>& surface_readings)\n    {\n        auto h1 = async([&] { if (!validate(surface_readings)) throw Invalid_data{}; });\n        auto h2 = async([&] { return temperature_gradients(surface_readings); });\n        auto h3 = async([&] { return altitude_map(surface_readings); });\n        // ...\n        h1.get();\n        auto v2 = h2.get();\n        auto v3 = h3.get();\n        // ...\n    }\n\nWithout those `const`s, we would have to review every asynchronously invoked function for potential data races on `surface_readings`.\nMaking `surface_readings` be `const` (with respect to this function) allows reasoning using only the function body.\n\n##### Note\n\nImmutable data can be safely and efficiently shared.\nNo locking is needed: You can't have a data race on a constant.\nSee also [CP.mess: Message Passing](#sscp-mess) and [CP.31: prefer pass by value](#rconc-data-by-value).\n\n##### Enforcement\n\n???\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-task\"></a>CP.4: Think in terms of tasks, rather than threads",
    "content": "### <a name=\"rconc-task\"></a>CP.4: Think in terms of tasks, rather than threads\n\n##### Reason\n\nA `thread` is an implementation concept, a way of thinking about the machine.\nA task is an application notion, something you'd like to do, preferably concurrently with other tasks.\nApplication concepts are easier to reason about.\n\n##### Example\n\n    void some_fun(const std::string& msg)\n    {\n        std::thread publisher([=] { std::cout << msg; });      // bad: less expressive\n                                                               //      and more error-prone\n        auto pubtask = std::async([=] { std::cout << msg; });  // OK\n        // ...\n        publisher.join();\n    }\n\n##### Note\n\nWith the exception of `async()`, the standard-library facilities are low-level, machine-oriented, threads-and-lock level.\nThis is a necessary foundation, but we have to try to raise the level of abstraction: for productivity, for reliability, and for performance.\nThis is a potent argument for using higher level, more applications-oriented libraries (if possible, built on top of standard-library facilities).\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-volatile\"></a>CP.8: Don't try to use `volatile` for synchronization",
    "content": "### <a name=\"rconc-volatile\"></a>CP.8: Don't try to use `volatile` for synchronization\n\n##### Reason\n\nIn C++, unlike some other languages, `volatile` does not provide atomicity, does not synchronize between threads,\nand does not prevent instruction reordering (neither compiler nor hardware).\nIt simply has nothing to do with concurrency.\n\n##### Example, bad:\n\n    int free_slots = max_slots; // current source of memory for objects\n\n    Pool* use()\n    {\n        if (int n = free_slots--) return &pool[n];\n    }\n\nHere we have a problem:\nThis is perfectly good code in a single-threaded program, but have two threads execute this and\nthere is a race condition on `free_slots` so that two threads might get the same value and `free_slots`.\nThat's (obviously) a bad data race, so people trained in other languages might try to fix it like this:\n\n    volatile int free_slots = max_slots; // current source of memory for objects\n\n    Pool* use()\n    {\n        if (int n = free_slots--) return &pool[n];\n    }\n\nThis has no effect on synchronization: The data race is still there!\n\nThe C++ mechanism for this is `atomic` types:\n\n    atomic<int> free_slots = max_slots; // current source of memory for objects\n\n    Pool* use()\n    {\n        if (int n = free_slots--) return &pool[n];\n    }\n\nNow the `--` operation is atomic,\nrather than a read-increment-write sequence where another thread might get in-between the individual operations.\n\n##### Alternative\n\nUse `atomic` types where you might have used `volatile` in some other language.\nUse a `mutex` for more complicated examples.\n\n##### See also\n\n[(rare) proper uses of `volatile`](#rconc-volatile2)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-tools\"></a>CP.9: Whenever feasible use tools to validate your concurrent code",
    "content": "### <a name=\"rconc-tools\"></a>CP.9: Whenever feasible use tools to validate your concurrent code\n\nExperience shows that concurrent code is exceptionally hard to get right\nand that compile-time checking, run-time checks, and testing are less effective at finding concurrency errors\nthan they are at finding errors in sequential code.\nSubtle concurrency errors can have dramatically bad effects, including memory corruption, deadlocks, and security vulnerabilities.\n\n##### Example\n\n    ???\n\n##### Note\n\nThread safety is challenging, often getting the better of experienced programmers: tooling is an important strategy to mitigate those risks.\nThere are many tools \"out there\", both commercial and open-source tools, both research and production tools.\nUnfortunately people's needs and constraints differ so dramatically that we cannot make specific recommendations,\nbut we can mention:\n\n* Static enforcement tools: both [clang](https://clang.llvm.org/docs/ThreadSafetyAnalysis.html)\nand some older versions of [GCC](https://gcc.gnu.org/wiki/ThreadSafetyAnnotation)\nhave some support for static annotation of thread safety properties.\nConsistent use of this technique turns many classes of thread-safety errors into compile-time errors.\nThe annotations are generally local (marking a particular data member as guarded by a particular mutex),\nand are usually easy to learn. However, as with many static tools, it can often present false negatives;\ncases that should have been caught but were allowed.\n\n* dynamic enforcement tools: Clang's [Thread Sanitizer](https://clang.llvm.org/docs/ThreadSanitizer.html) (aka TSAN)\nis a powerful example of dynamic tools: it changes the build and execution of your program to add bookkeeping on memory access,\nabsolutely identifying data races in a given execution of your binary.\nThe cost for this is both memory (5-10x in most cases) and CPU slowdown (2-20x).\nDynamic tools like this are best when applied to integration tests, canary pushes, or unit tests that operate on multiple threads.\nWorkload matters: When TSAN identifies a problem, it is effectively always an actual data race,\nbut it can only identify races seen in a given execution.\n\n##### Enforcement\n\nIt is up to an application builder to choose which support tools are valuable for a particular application.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"sscp-con\"></a>CP.con: Concurrency",
    "content": "## <a name=\"sscp-con\"></a>CP.con: Concurrency\n\nThis section focuses on relatively ad-hoc uses of multiple threads communicating through shared data.\n\n* For parallel algorithms, see [parallelism](#sscp-par)\n* For inter-task communication without explicit sharing, see [messaging](#sscp-mess)\n* For vector parallel code, see [vectorization](#sscp-vec)\n* For lock-free programming, see [lock free](#sscp-free)\n\nConcurrency rule summary:\n\n* [CP.20: Use RAII, never plain `lock()`/`unlock()`](#rconc-raii)\n* [CP.21: Use `std::lock()` or `std::scoped_lock` to acquire multiple `mutex`es](#rconc-lock)\n* [CP.22: Never call unknown code while holding a lock (e.g., a callback)](#rconc-unknown)\n* [CP.23: Think of a joining `thread` as a scoped container](#rconc-join)\n* [CP.24: Think of a `thread` as a global container](#rconc-detach)\n* [CP.25: Prefer `gsl::joining_thread` over `std::thread`](#rconc-joining_thread)\n* [CP.26: Don't `detach()` a thread](#rconc-detached_thread)\n* [CP.31: Pass small amounts of data between threads by value, rather than by reference or pointer](#rconc-data-by-value)\n* [CP.32: To share ownership between unrelated `thread`s use `shared_ptr`](#rconc-shared)\n* [CP.40: Minimize context switching](#rconc-switch)\n* [CP.41: Minimize thread creation and destruction](#rconc-create)\n* [CP.42: Don't `wait` without a condition](#rconc-wait)\n* [CP.43: Minimize time spent in a critical section](#rconc-time)\n* [CP.44: Remember to name your `lock_guard`s and `unique_lock`s](#rconc-name)\n* [CP.50: Define a `mutex` together with the data it guards. Use `synchronized_value<T>` where possible](#rconc-mutex)\n* ??? when to use a spinlock\n* ??? when to use `try_lock()`\n* ??? when to prefer `lock_guard` over `unique_lock`\n* ??? Time multiplexing\n* ??? when/how to use `new thread`\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-raii\"></a>CP.20: Use RAII, never plain `lock()`/`unlock()`",
    "content": "### <a name=\"rconc-raii\"></a>CP.20: Use RAII, never plain `lock()`/`unlock()`\n\n##### Reason\n\nAvoids nasty errors from unreleased locks.\n\n##### Example, bad\n\n    mutex mtx;\n\n    void do_stuff()\n    {\n        mtx.lock();\n        // ... do stuff ...\n        mtx.unlock();\n    }\n\nSooner or later, someone will forget the `mtx.unlock()`, place a `return` in the `... do stuff ...`, throw an exception, or something.\n\n    mutex mtx;\n\n    void do_stuff()\n    {\n        unique_lock<mutex> lck {mtx};\n        // ... do stuff ...\n    }\n\n##### Enforcement\n\nFlag calls of member `lock()` and `unlock()`.  ???\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-lock\"></a>CP.21: Use `std::lock()` or `std::scoped_lock` to acquire multiple `mutex`es",
    "content": "### <a name=\"rconc-lock\"></a>CP.21: Use `std::lock()` or `std::scoped_lock` to acquire multiple `mutex`es\n\n##### Reason\n\nTo avoid deadlocks on multiple `mutex`es.\n\n##### Example\n\nThis is asking for deadlock:\n\n    // thread 1\n    lock_guard<mutex> lck1(m1);\n    lock_guard<mutex> lck2(m2);\n\n    // thread 2\n    lock_guard<mutex> lck2(m2);\n    lock_guard<mutex> lck1(m1);\n\nInstead, use `lock()`:\n\n    // thread 1\n    lock(m1, m2);\n    lock_guard<mutex> lck1(m1, adopt_lock);\n    lock_guard<mutex> lck2(m2, adopt_lock);\n\n    // thread 2\n    lock(m2, m1);\n    lock_guard<mutex> lck2(m2, adopt_lock);\n    lock_guard<mutex> lck1(m1, adopt_lock);\n\nor (better, but C++17 only):\n\n    // thread 1\n    scoped_lock<mutex, mutex> lck1(m1, m2);\n\n    // thread 2\n    scoped_lock<mutex, mutex> lck2(m2, m1);\n\nHere, the writers of `thread1` and `thread2` are still not agreeing on the order of the `mutex`es, but order no longer matters.\n\n##### Note\n\nIn real code, `mutex`es are rarely named to conveniently remind the programmer of an intended relation and intended order of acquisition.\nIn real code, `mutex`es are not always conveniently acquired on consecutive lines.\n\n##### Note\n\nIn C++17 it's possible to write plain\n\n    lock_guard lck1(m1, adopt_lock);\n\nand have the `mutex` type deduced.\n\n##### Enforcement\n\nDetect the acquisition of multiple `mutex`es.\nThis is undecidable in general, but catching common simple examples (like the one above) is easy.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-unknown\"></a>CP.22: Never call unknown code while holding a lock (e.g., a callback)",
    "content": "### <a name=\"rconc-unknown\"></a>CP.22: Never call unknown code while holding a lock (e.g., a callback)\n\n##### Reason\n\nIf you don't know what a piece of code does, you are risking deadlock.\n\n##### Example\n\n    void do_this(Foo* p)\n    {\n        lock_guard<mutex> lck {my_mutex};\n        // ... do something ...\n        p->act(my_data);\n        // ...\n    }\n\nIf you don't know what `Foo::act` does (maybe it is a virtual function invoking a derived class member of a class not yet written),\nit might call `do_this` (recursively) and cause a deadlock on `my_mutex`.\nMaybe it will lock on a different mutex and not return in a reasonable time, causing delays to any code calling `do_this`.\n\n##### Example\n\nA common example of the \"calling unknown code\" problem is a call to a function that tries to gain locked access to the same object.\nSuch problem can often be solved by using a `recursive_mutex`. For example:\n\n    recursive_mutex my_mutex;\n\n    template<typename Action>\n    void do_something(Action f)\n    {\n        unique_lock<recursive_mutex> lck {my_mutex};\n        // ... do something ...\n        f(this);    // f will do something to *this\n        // ...\n    }\n\nIf, as it is likely, `f()` invokes operations on `*this`, we must make sure that the object's invariant holds before the call.\n\n##### Enforcement\n\n* Flag calling a virtual function with a non-recursive `mutex` held\n* Flag calling a callback with a non-recursive `mutex` held\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-join\"></a>CP.23: Think of a joining `thread` as a scoped container",
    "content": "### <a name=\"rconc-join\"></a>CP.23: Think of a joining `thread` as a scoped container\n\n##### Reason\n\nTo maintain pointer safety and avoid leaks, we need to consider what pointers are used by a `thread`.\nIf a `thread` joins, we can safely pass pointers to objects in the scope of the `thread` and its enclosing scopes.\n\n##### Example\n\n    void f(int* p)\n    {\n        // ...\n        *p = 99;\n        // ...\n    }\n    int glob = 33;\n\n    void some_fct(int* p)\n    {\n        int x = 77;\n        joining_thread t0(f, &x);           // OK\n        joining_thread t1(f, p);            // OK\n        joining_thread t2(f, &glob);        // OK\n        auto q = make_unique<int>(99);\n        joining_thread t3(f, q.get());      // OK\n        // ...\n    }\n\nA `gsl::joining_thread` is a `std::thread` with a destructor that joins and that cannot be `detached()`.\nBy \"OK\" we mean that the object will be in scope (\"live\") for as long as a `thread` can use the pointer to it.\nThe fact that `thread`s run concurrently doesn't affect the lifetime or ownership issues here;\nthese `thread`s can be seen as just a function object called from `some_fct`.\n\n##### Enforcement\n\nEnsure that `joining_thread`s don't `detach()`.\nAfter that, the usual lifetime and ownership (for local objects) enforcement applies.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-detach\"></a>CP.24: Think of a `thread` as a global container",
    "content": "### <a name=\"rconc-detach\"></a>CP.24: Think of a `thread` as a global container\n\n##### Reason\n\nTo maintain pointer safety and avoid leaks, we need to consider what pointers are used by a `thread`.\nIf a `thread` is detached, we can safely pass pointers to static and free store objects (only).\n\n##### Example\n\n    void f(int* p)\n    {\n        // ...\n        *p = 99;\n        // ...\n    }\n\n    int glob = 33;\n\n    void some_fct(int* p)\n    {\n        int x = 77;\n        std::thread t0(f, &x);           // bad\n        std::thread t1(f, p);            // bad\n        std::thread t2(f, &glob);        // OK\n        auto q = make_unique<int>(99);\n        std::thread t3(f, q.get());      // bad\n        // ...\n        t0.detach();\n        t1.detach();\n        t2.detach();\n        t3.detach();\n        // ...\n    }\n\nBy \"OK\" we mean that the object will be in scope (\"live\") for as long as a `thread` can use the pointers to it.\nBy \"bad\" we mean that a `thread` might use a pointer after the pointed-to object is destroyed.\nThe fact that `thread`s run concurrently doesn't affect the lifetime or ownership issues here;\nthese `thread`s can be seen as just a function object called from `some_fct`.\n\n##### Note\n\nEven objects with static storage duration can be problematic if used from detached threads: if the\nthread continues until the end of the program, it might be running concurrently with the destruction\nof objects with static storage duration, and thus accesses to such objects might race.\n\n##### Note\n\nThis rule is redundant if you [don't `detach()`](#rconc-detached_thread) and [use `gsl::joining_thread`](#rconc-joining_thread).\nHowever, converting code to follow those guidelines could be difficult and even impossible for third-party libraries.\nIn such cases, the rule becomes essential for lifetime safety and type safety.\n\n\nIn general, it is undecidable whether a `detach()` is executed for a `thread`, but simple common cases are easily detected.\nIf we cannot prove that a `thread` does not `detach()`, we must assume that it does and that it outlives the scope in which it was constructed;\nafter that, the usual lifetime and ownership (for global objects) enforcement applies.\n\n##### Enforcement\n\nFlag attempts to pass local variables to a thread that might `detach()`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-joining_thread\"></a>CP.25: Prefer `gsl::joining_thread` over `std::thread`",
    "content": "### <a name=\"rconc-joining_thread\"></a>CP.25: Prefer `gsl::joining_thread` over `std::thread`\n\n##### Reason\n\nA `joining_thread` is a thread that joins at the end of its scope.\nDetached threads are hard to monitor.\nIt is harder to ensure absence of errors in detached threads (and potentially detached threads).\n\n##### Example, bad\n\n    void f() { std::cout << \"Hello \"; }\n\n    struct F {\n        void operator()() const { std::cout << \"parallel world \"; }\n    };\n\n    int main()\n    {\n        std::thread t1{f};      // f() executes in separate thread\n        std::thread t2{F()};    // F()() executes in separate thread\n    }  // spot the bugs\n\n##### Example\n\n    void f() { std::cout << \"Hello \"; }\n\n    struct F {\n        void operator()() const { std::cout << \"parallel world \"; }\n    };\n\n    int main()\n    {\n        std::thread t1{f};      // f() executes in separate thread\n        std::thread t2{F()};    // F()() executes in separate thread\n\n        t1.join();\n        t2.join();\n    }  // one bad bug left\n\n##### Note\n\nMake \"immortal threads\" globals, put them in an enclosing scope, or put them on the free store rather than `detach()`.\n[Don't `detach`](#rconc-detached_thread).\n\n##### Note\n\nBecause of old code and third party libraries using `std::thread`, this rule can be hard to introduce.\n\n##### Enforcement\n\nFlag uses of `std::thread`:\n\n* Suggest use of `gsl::joining_thread` or C++20 `std::jthread`.\n* Suggest [\"exporting ownership\"](#rconc-detached_thread) to an enclosing scope if it detaches.\n* Warn if it is not obvious whether a thread joins or detaches.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-detached_thread\"></a>CP.26: Don't `detach()` a thread",
    "content": "### <a name=\"rconc-detached_thread\"></a>CP.26: Don't `detach()` a thread\n\n##### Reason\n\nOften, the need to outlive the scope of its creation is inherent in the `thread`s task,\nbut implementing that idea by `detach` makes it harder to monitor and communicate with the detached thread.\nIn particular, it is harder (though not impossible) to ensure that the thread completed as expected or lives for as long as expected.\n\n##### Example\n\n    void heartbeat();\n\n    void use()\n    {\n        std::thread t(heartbeat);             // don't join; heartbeat is meant to run forever\n        t.detach();\n        // ...\n    }\n\nThis is a reasonable use of a thread, for which `detach()` is commonly used.\nThere are problems, though.\nHow do we monitor the detached thread to see if it is alive?\nSomething might go wrong with the heartbeat, and losing a heartbeat can be very serious in a system for which it is needed.\nSo, we need to communicate with the heartbeat thread\n(e.g., through a stream of messages or notification events using a `condition_variable`).\n\nAn alternative, and usually superior solution is to control its lifetime by placing it in a scope outside its point of creation (or activation).\nFor example:\n\n    void heartbeat();\n\n    gsl::joining_thread t(heartbeat);             // heartbeat is meant to run \"forever\"\n\nThis heartbeat will (barring error, hardware problems, etc.) run for as long as the program does.\n\nSometimes, we need to separate the point of creation from the point of ownership:\n\n    void heartbeat();\n\n    unique_ptr<gsl::joining_thread> tick_tock {nullptr};\n\n    void use()\n    {\n        // heartbeat is meant to run as long as tick_tock lives\n        tick_tock = make_unique<gsl::joining_thread>(heartbeat);\n        // ...\n    }\n\n#### Enforcement\n\nFlag `detach()`.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-data-by-value\"></a>CP.31: Pass small amounts of data between threads by value, rather than by reference or pointer",
    "content": "### <a name=\"rconc-data-by-value\"></a>CP.31: Pass small amounts of data between threads by value, rather than by reference or pointer\n\n##### Reason\n\nA small amount of data is cheaper to copy and access than to share it using some locking mechanism.\nCopying naturally gives unique ownership (simplifies code) and eliminates the possibility of data races.\n\n##### Note\n\nDefining \"small amount\" precisely is impossible.\n\n##### Example\n\n    string modify1(string);\n    void modify2(string&);\n\n    void fct(string& s)\n    {\n        auto res = async(modify1, s);\n        async(modify2, s);\n    }\n\nThe call of `modify1` involves copying two `string` values; the call of `modify2` does not.\nOn the other hand, the implementation of `modify1` is exactly as we would have written it for single-threaded code,\nwhereas the implementation of `modify2` will need some form of locking to avoid data races.\nIf the string is short (say 10 characters), the call of `modify1` can be surprisingly fast;\nessentially all the cost is in the `thread` switch. If the string is long (say 1,000,000 characters), copying it twice\nis probably not a good idea.\n\nNote that this argument has nothing to do with `async` as such. It applies equally to considerations about whether to use\nmessage passing or shared memory.\n\n##### Enforcement\n\n???\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-shared\"></a>CP.32: To share ownership between unrelated `thread`s use `shared_ptr`",
    "content": "### <a name=\"rconc-shared\"></a>CP.32: To share ownership between unrelated `thread`s use `shared_ptr`\n\n##### Reason\n\nIf threads are unrelated (that is, not known to be in the same scope or one within the lifetime of the other)\nand they need to share free store memory that needs to be deleted, a `shared_ptr` (or equivalent) is the only\nsafe way to ensure proper deletion.\n\n##### Example\n\n    ???\n\n##### Note\n\n* A static object (e.g. a global) can be shared because it is not owned in the sense that some thread is responsible for its deletion.\n* An object on free store that is never to be deleted can be shared.\n* An object owned by one thread can be safely shared with another as long as that second thread doesn't outlive the owner.\n\n##### Enforcement\n\n???\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-switch\"></a>CP.40: Minimize context switching",
    "content": "### <a name=\"rconc-switch\"></a>CP.40: Minimize context switching\n\n##### Reason\n\nContext switches are expensive.\n\n##### Example\n\n    ???\n\n##### Enforcement\n\n???\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-create\"></a>CP.41: Minimize thread creation and destruction",
    "content": "### <a name=\"rconc-create\"></a>CP.41: Minimize thread creation and destruction\n\n##### Reason\n\nThread creation is expensive.\n\n##### Example\n\n    void worker(Message m)\n    {\n        // process\n    }\n\n    void dispatcher(istream& is)\n    {\n        for (Message m; is >> m; )\n            run_list.push_back(new thread(worker, m));\n    }\n\nThis spawns a `thread` per message, and the `run_list` is presumably managed to destroy those tasks once they are finished.\n\nInstead, we could have a set of pre-created worker threads processing the messages\n\n    Sync_queue<Message> work;\n\n    void dispatcher(istream& is)\n    {\n        for (Message m; is >> m; )\n            work.put(m);\n    }\n\n    void worker()\n    {\n        for (Message m; m = work.get(); ) {\n            // process\n        }\n    }\n\n    void workers()  // set up worker threads (specifically 4 worker threads)\n    {\n        joining_thread w1 {worker};\n        joining_thread w2 {worker};\n        joining_thread w3 {worker};\n        joining_thread w4 {worker};\n    }\n\n##### Note\n\nIf your system has a good thread pool, use it.\nIf your system has a good message queue, use it.\n\n##### Enforcement\n\n???\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-wait\"></a>CP.42: Don't `wait` without a condition",
    "content": "### <a name=\"rconc-wait\"></a>CP.42: Don't `wait` without a condition\n\n##### Reason\n\nA `wait` without a condition can miss a wakeup or wake up simply to find that there is no work to do.\n\n##### Example, bad\n\n    std::condition_variable cv;\n    std::mutex mx;\n\n    void thread1()\n    {\n        while (true) {\n            // do some work ...\n            std::unique_lock<std::mutex> lock(mx);\n            cv.notify_one();    // wake other thread\n        }\n    }\n\n    void thread2()\n    {\n        while (true) {\n            std::unique_lock<std::mutex> lock(mx);\n            cv.wait(lock);    // might block forever\n            // do work ...\n        }\n    }\n\nHere, if some other `thread` consumes `thread1`'s notification, `thread2` can wait forever.\n\n##### Example\n\n    template<typename T>\n    class Sync_queue {\n    public:\n        void put(const T& val);\n        void put(T&& val);\n        void get(T& val);\n    private:\n        mutex mtx;\n        condition_variable cond;    // this controls access\n        list<T> q;\n    };\n\n    template<typename T>\n    void Sync_queue<T>::put(const T& val)\n    {\n        lock_guard<mutex> lck(mtx);\n        q.push_back(val);\n        cond.notify_one();\n    }\n\n    template<typename T>\n    void Sync_queue<T>::get(T& val)\n    {\n        unique_lock<mutex> lck(mtx);\n        cond.wait(lck, [this] { return !q.empty(); });    // prevent spurious wakeup\n        val = q.front();\n        q.pop_front();\n    }\n\nNow if the queue is empty when a thread executing `get()` wakes up (e.g., because another thread has gotten to `get()` before it),\nit will immediately go back to sleep, waiting.\n\n##### Enforcement\n\nFlag all `wait`s without conditions.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-time\"></a>CP.43: Minimize time spent in a critical section",
    "content": "### <a name=\"rconc-time\"></a>CP.43: Minimize time spent in a critical section\n\n##### Reason\n\nThe less time is spent with a `mutex` taken, the less chance that another `thread` has to wait,\nand `thread` suspension and resumption are expensive.\n\n##### Example\n\n    void do_something() // bad\n    {\n        unique_lock<mutex> lck(my_lock);\n        do0();  // preparation: does not need lock\n        do1();  // transaction: needs locking\n        do2();  // cleanup: does not need locking\n    }\n\nHere, we are holding the lock for longer than necessary:\nWe should not have taken the lock before we needed it and should have released it again before starting the cleanup.\nWe could rewrite this to\n\n    void do_something() // bad\n    {\n        do0();  // preparation: does not need lock\n        my_lock.lock();\n        do1();  // transaction: needs locking\n        my_lock.unlock();\n        do2();  // cleanup: does not need locking\n    }\n\nBut that compromises safety and violates the [use RAII](#rconc-raii) rule.\nInstead, add a block for the critical section:\n\n    void do_something() // OK\n    {\n        do0();  // preparation: does not need lock\n        {\n            unique_lock<mutex> lck(my_lock);\n            do1();  // transaction: needs locking\n        }\n        do2();  // cleanup: does not need locking\n    }\n\n##### Enforcement\n\nImpossible in general.\nFlag \"naked\" `lock()` and `unlock()`.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-name\"></a>CP.44: Remember to name your `lock_guard`s and `unique_lock`s",
    "content": "### <a name=\"rconc-name\"></a>CP.44: Remember to name your `lock_guard`s and `unique_lock`s\n\n##### Reason\n\nAn unnamed local object is a temporary that immediately goes out of scope.\n\n##### Example\n\n    // global mutexes\n    mutex m1;\n    mutex m2;\n\n    void f()\n    {\n        unique_lock<mutex>(m1); // (A)\n        lock_guard<mutex> {m2}; // (B)\n        // do work in critical section ...\n    }\n\nThis looks innocent enough, but it isn't. At (A), `m1` is a default-constructed\nlocal `unique_lock`, which shadows the global `::m1` (and does not lock it).\nAt (B) an unnamed temporary `lock_guard` is constructed and locks `::m2`,\nbut immediately goes out of scope and unlocks `::m2` again.\nFor the rest of the function `f()` neither mutex is locked.\n\n##### Enforcement\n\nFlag all unnamed `lock_guard`s and `unique_lock`s.\n\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-mutex\"></a>CP.50: Define a `mutex` together with the data it guards. Use `synchronized_value<T>` where possible",
    "content": "### <a name=\"rconc-mutex\"></a>CP.50: Define a `mutex` together with the data it guards. Use `synchronized_value<T>` where possible\n\n##### Reason\n\nIt should be obvious to a reader that the data is to be guarded and how. This decreases the chance of the wrong mutex being locked, or the mutex not being locked.\n\nUsing a `synchronized_value<T>` ensures that the data has a mutex, and the right mutex is locked when the data is accessed.\nSee the [WG21 proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0290r4.html) to add `synchronized_value` to a future TS or revision of the C++ standard.\n\n##### Example\n\n    struct Record {\n        std::mutex m;   // take this mutex before accessing other members\n        // ...\n    };\n\n    class MyClass {\n        struct DataRecord {\n           // ...\n        };\n        synchronized_value<DataRecord> data; // Protect the data with a mutex\n    };\n\n##### Enforcement\n\n??? Possible?\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"sscp-coro\"></a>CP.coro: Coroutines",
    "content": "## <a name=\"sscp-coro\"></a>CP.coro: Coroutines\n\nThis section focuses on uses of coroutines.\n\nCoroutine rule summary:\n\n* [CP.51: Do not use capturing lambdas that are coroutines](#rcoro-capture)\n* [CP.52: Do not hold locks or other synchronization primitives across suspension points](#rcoro-locks)\n* [CP.53: Parameters to coroutines should not be passed by reference](#rcoro-reference-parameters)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rcoro-capture\"></a>CP.51: Do not use capturing lambdas that are coroutines",
    "content": "### <a name=\"rcoro-capture\"></a>CP.51: Do not use capturing lambdas that are coroutines\n\n##### Reason\n\nUsage patterns that are correct with normal lambdas are hazardous with coroutine lambdas. The obvious pattern of capturing variables will result in accessing freed memory after the first suspension point, even for refcounted smart pointers and copyable types.\n\nA lambda results in a closure object with storage, often on the stack, that will go out of scope at some point.  When the closure object goes out of scope the captures will also go out of scope.  Normal lambdas will have finished executing by this time so it is not a problem.  Coroutine lambdas may resume from suspension after the closure object has destructed and at that point all captures will be use-after-free memory access.\n\n##### Example, Bad\n\n    int value = get_value();\n    std::shared_ptr<Foo> sharedFoo = get_foo();\n    {\n      const auto lambda = [value, sharedFoo]() -> std::future<void>\n      {\n        co_await something();\n        // \"sharedFoo\" and \"value\" have already been destroyed\n        // the \"shared\" pointer didn't accomplish anything\n      };\n      lambda();\n    } // the lambda closure object has now gone out of scope\n\n##### Example, Better\n\n    int value = get_value();\n    std::shared_ptr<Foo> sharedFoo = get_foo();\n    {\n      // take as by-value parameter instead of as a capture\n      const auto lambda = [](auto sharedFoo, auto value) -> std::future<void>\n      {\n        co_await something();\n        // sharedFoo and value are still valid at this point\n      };\n      lambda(sharedFoo, value);\n    } // the lambda closure object has now gone out of scope\n\n##### Example, Best\n\nUse a function for coroutines.\n\n    std::future<void> Class::do_something(int value, std::shared_ptr<Foo> sharedFoo)\n    {\n      co_await something();\n      // sharedFoo and value are still valid at this point\n    }\n\n    void SomeOtherFunction()\n    {\n      int value = get_value();\n      std::shared_ptr<Foo> sharedFoo = get_foo();\n      do_something(value, sharedFoo);\n    }\n\n##### Enforcement\n\nFlag a lambda that is a coroutine and has a non-empty capture list.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rcoro-locks\"></a>CP.52: Do not hold locks or other synchronization primitives across suspension points",
    "content": "### <a name=\"rcoro-locks\"></a>CP.52: Do not hold locks or other synchronization primitives across suspension points\n\n##### Reason\n\nThis pattern creates a significant risk of deadlocks.  Some types of waits will allow the current thread to perform additional work until the asynchronous operation has completed. If the thread holding the lock performs work that requires the same lock then it will deadlock because it is trying to acquire a lock that it is already holding.\n\nIf the coroutine completes on a different thread from the thread that acquired the lock then that is undefined behavior.  Even with an explicit return to the original thread an exception might be thrown before coroutine resumes and the result will be that the lock guard is not destructed.\n\n##### Example, Bad\n\n    std::mutex g_lock;\n\n    std::future<void> Class::do_something()\n    {\n        std::lock_guard<std::mutex> guard(g_lock);\n        co_await something(); // DANGER: coroutine has suspended execution while holding a lock\n        co_await somethingElse();\n    }\n\n##### Example, Good\n\n    std::mutex g_lock;\n\n    std::future<void> Class::do_something()\n    {\n        {\n            std::lock_guard<std::mutex> guard(g_lock);\n            // modify data protected by lock\n        }\n        co_await something(); // OK: lock has been released before coroutine suspends\n        co_await somethingElse();\n    }\n\n\n##### Note\n\nThis pattern is also bad for performance. When a suspension point is reached, such as co_await, execution of the current function stops and other code begins to run. It may be a long period of time before the coroutine resumes. For that entire duration the lock will be held and cannot be acquired by other threads to perform work.\n\n##### Enforcement\n\nFlag all lock guards that are not destructed before a coroutine suspends.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rcoro-reference-parameters\"></a>CP.53: Parameters to coroutines should not be passed by reference",
    "content": "### <a name=\"rcoro-reference-parameters\"></a>CP.53: Parameters to coroutines should not be passed by reference\n\n##### Reason\n\nOnce a coroutine reaches the first suspension point, such as a co_await, the synchronous portion returns. After that point any parameters passed by reference are dangling. Any usage beyond that is undefined behavior which may include writing to freed memory.\n\n##### Example, Bad\n\n    std::future<int> Class::do_something(const std::shared_ptr<int>& input)\n    {\n        co_await something();\n\n        // DANGER: the reference to input may no longer be valid and may be freed memory\n        co_return *input + 1;\n    }\n\n##### Example, Good\n\n    std::future<int> Class::do_something(std::shared_ptr<int> input)\n    {\n        co_await something();\n        co_return *input + 1; // input is a copy that is still valid here\n    }\n\n##### Note\n\nThis problem does not apply to reference parameters that are only accessed before the first suspension point. Subsequent changes to the function may add or move suspension points which would reintroduce this class of bug. Some types of coroutines have the suspension point before the first line of code in the coroutine executes, in which case reference parameters are always unsafe.  It is safer to always pass by value because the copied parameter will live in the coroutine frame that is safe to access throughout the coroutine.\n\n##### Note\n\nThe same danger applies to output parameters.  [F.20: For \"out\" output values, prefer return values to output parameters](#rf-out) discourages output parameters.  Coroutines should avoid them entirely.\n\n##### Enforcement\n\nFlag all reference parameters to a coroutine.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"sscp-par\"></a>CP.par: Parallelism",
    "content": "## <a name=\"sscp-par\"></a>CP.par: Parallelism\n\nBy \"parallelism\" we refer to performing a task (more or less) simultaneously (\"in parallel with\") on many data items.\n\nParallelism rule summary:\n\n* ???\n* ???\n* Where appropriate, prefer the standard-library parallel algorithms\n* Use algorithms that are designed for parallelism, not algorithms with unnecessary dependency on linear evaluation\n\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"sscp-mess\"></a>CP.mess: Message passing",
    "content": "## <a name=\"sscp-mess\"></a>CP.mess: Message passing\n\nThe standard-library facilities are quite low-level, focused on the needs of close-to-the-hardware critical programming using `thread`s, `mutex`es, `atomic` types, etc.\nMost people shouldn't work at this level: it's error-prone and development is slow.\nIf possible, use a higher level facility: messaging libraries, parallel algorithms, and vectorization.\nThis section looks at passing messages so that a programmer doesn't have to do explicit synchronization.\n\nMessage passing rules summary:\n\n* [CP.60: Use a `future` to return a value from a concurrent task](#rconc-future)\n* [CP.61: Use `async()` to spawn concurrent tasks](#rconc-async)\n* message queues\n* messaging libraries\n\n???? should there be a \"use X rather than `std::async`\" where X is something that would use a better specified thread pool?\n\n??? Is `std::async` worth using in light of future (and even existing, as libraries) parallelism facilities? What should the guidelines recommend if someone wants to parallelize, e.g., `std::accumulate` (with the additional precondition of commutativity), or merge sort?\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-future\"></a>CP.60: Use a `future` to return a value from a concurrent task",
    "content": "### <a name=\"rconc-future\"></a>CP.60: Use a `future` to return a value from a concurrent task\n\n##### Reason\n\nA `future` preserves the usual function call return semantics for asynchronous tasks.\nThere is no explicit locking and both correct (value) return and error (exception) return are handled simply.\n\n##### Example\n\n    ???\n\n##### Note\n\n???\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-async\"></a>CP.61: Use `async()` to spawn concurrent tasks",
    "content": "### <a name=\"rconc-async\"></a>CP.61: Use `async()` to spawn concurrent tasks\n\n##### Reason\n\nSimilar to [R.12](#rr-immediate-alloc), which tells you to avoid raw owning pointers, you should\nalso avoid raw threads and raw promises where possible. Use a factory function such as `std::async`,\nwhich handles spawning or reusing a thread without exposing raw threads to your own code.\n\n##### Example\n\n    int read_value(const std::string& filename)\n    {\n        std::ifstream in(filename);\n        in.exceptions(std::ifstream::failbit);\n        int value;\n        in >> value;\n        return value;\n    }\n\n    void async_example()\n    {\n        try {\n            std::future<int> f1 = std::async(read_value, \"v1.txt\");\n            std::future<int> f2 = std::async(read_value, \"v2.txt\");\n            std::cout << f1.get() + f2.get() << '\\n';\n        } catch (const std::ios_base::failure& fail) {\n            // handle exception here\n        }\n    }\n\n##### Note\n\nUnfortunately, `std::async` is not perfect. For example, it doesn't use a thread pool,\nwhich means that it might fail due to resource exhaustion, rather than queuing up your tasks\nto be executed later. However, even if you cannot use `std::async`, you should prefer to\nwrite your own `future`-returning factory function, rather than using raw promises.\n\n##### Example (bad)\n\nThis example shows two different ways to succeed at using `std::future`, but to fail\nat avoiding raw `std::thread` management.\n\n    void async_example()\n    {\n        std::promise<int> p1;\n        std::future<int> f1 = p1.get_future();\n        std::thread t1([p1 = std::move(p1)]() mutable {\n            p1.set_value(read_value(\"v1.txt\"));\n        });\n        t1.detach(); // evil\n\n        std::packaged_task<int()> pt2(read_value, \"v2.txt\");\n        std::future<int> f2 = pt2.get_future();\n        std::thread(std::move(pt2)).detach();\n\n        std::cout << f1.get() + f2.get() << '\\n';\n    }\n\n##### Example (good)\n\nThis example shows one way you could follow the general pattern set by\n`std::async`, in a context where `std::async` itself was unacceptable for\nuse in production.\n\n    void async_example(WorkQueue& wq)\n    {\n        std::future<int> f1 = wq.enqueue([]() {\n            return read_value(\"v1.txt\");\n        });\n        std::future<int> f2 = wq.enqueue([]() {\n            return read_value(\"v2.txt\");\n        });\n        std::cout << f1.get() + f2.get() << '\\n';\n    }\n\nAny threads spawned to execute the code of `read_value` are hidden behind\nthe call to `WorkQueue::enqueue`. The user code deals only with `future`\nobjects, never with raw `thread`, `promise`, or `packaged_task` objects.\n\n##### Enforcement\n\n???\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"sscp-vec\"></a>CP.vec: Vectorization",
    "content": "## <a name=\"sscp-vec\"></a>CP.vec: Vectorization\n\nVectorization is a technique for executing a number of tasks concurrently without introducing explicit synchronization.\nAn operation is simply applied to elements of a data structure (a vector, an array, etc.) in parallel.\nVectorization has the interesting property of often requiring no non-local changes to a program.\nHowever, vectorization works best with simple data structures and with algorithms specifically crafted to enable it.\n\nVectorization rule summary:\n\n* ???\n* ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"sscp-free\"></a>CP.free: Lock-free programming",
    "content": "## <a name=\"sscp-free\"></a>CP.free: Lock-free programming\n\nSynchronization using `mutex`es and `condition_variable`s can be relatively expensive.\nFurthermore, it can lead to deadlock.\nFor performance and to eliminate the possibility of deadlock, we sometimes have to use the tricky low-level \"lock-free\" facilities\nthat rely on briefly gaining exclusive (\"atomic\") access to memory.\nLock-free programming is also used to implement higher-level concurrency mechanisms, such as `thread`s and `mutex`es.\n\nLock-free programming rule summary:\n\n* [CP.100: Don't use lock-free programming unless you absolutely have to](#rconc-lockfree)\n* [CP.101: Distrust your hardware/compiler combination](#rconc-distrust)\n* [CP.102: Carefully study the literature](#rconc-literature)\n* how/when to use atomics\n* avoid starvation\n* use a lock-free data structure rather than hand-crafting specific lock-free access\n* [CP.110: Do not write your own double-checked locking for initialization](#rconc-double)\n* [CP.111: Use a conventional pattern if you really need double-checked locking](#rconc-double-pattern)\n* how/when to compare and swap\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-lockfree\"></a>CP.100: Don't use lock-free programming unless you absolutely have to",
    "content": "### <a name=\"rconc-lockfree\"></a>CP.100: Don't use lock-free programming unless you absolutely have to\n\n##### Reason\n\nIt's error-prone and requires expert level knowledge of language features, machine architecture, and data structures.\n\n##### Example, bad\n\n    extern atomic<Link*> head;        // the shared head of a linked list\n\n    Link* nh = new Link(data, nullptr);    // make a link ready for insertion\n    Link* h = head.load();                 // read the shared head of the list\n\n    do {\n        if (h->data <= data) break;        // if so, insert elsewhere\n        nh->next = h;                      // next element is the previous head\n    } while (!head.compare_exchange_weak(h, nh));    // write nh to head or to h\n\nSpot the bug.\nIt would be really hard to find through testing.\nRead up on the ABA problem.\n\n##### Exception\n\n[Atomic variables](#???) can be used simply and safely, as long as you are using the sequentially consistent memory model (memory_order_seq_cst), which is the default.\n\n##### Note\n\nHigher-level concurrency mechanisms, such as `thread`s and `mutex`es are implemented using lock-free programming.\n\n**Alternative**: Use lock-free data structures implemented by others as part of some library.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-distrust\"></a>CP.101: Distrust your hardware/compiler combination",
    "content": "### <a name=\"rconc-distrust\"></a>CP.101: Distrust your hardware/compiler combination\n\n##### Reason\n\nThe low-level hardware interfaces used by lock-free programming are among the hardest to implement well and among\nthe areas where the most subtle portability problems occur.\nIf you are doing lock-free programming for performance, you need to check for regressions.\n\n##### Note\n\nInstruction reordering (static and dynamic) makes it hard for us to think effectively at this level (especially if you use relaxed memory models).\nExperience, (semi)formal models and model checking can be useful.\nTesting - often to an extreme extent - is essential.\n\"Don't fly too close to the sun.\"\n\n##### Enforcement\n\nHave strong rules for re-testing in place that covers any change in hardware, operating system, compiler, and libraries.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-literature\"></a>CP.102: Carefully study the literature",
    "content": "### <a name=\"rconc-literature\"></a>CP.102: Carefully study the literature\n\n##### Reason\n\nWith the exception of atomics and a few other standard patterns, lock-free programming is really an expert-only topic.\nBecome an expert before shipping lock-free code for others to use.\n\n##### References\n\n* Anthony Williams: C++ concurrency in action. Manning Publications.\n* Boehm, Adve, You Don't Know Jack About Shared Variables or Memory Models, Communications of the ACM, Feb 2012.\n* Boehm, \"Threads Basics\", HPL TR 2009-259.\n* Adve, Boehm, \"Memory Models: A Case for Rethinking Parallel Languages and Hardware\", Communications of the ACM, August 2010.\n* Boehm, Adve, \"Foundations of the C++ Concurrency Memory Model\", PLDI 08.\n* Mark Batty, Scott Owens, Susmit Sarkar, Peter Sewell, and Tjark Weber, \"Mathematizing C++ Concurrency\", POPL 2011.\n* Damian Dechev, Peter Pirkelbauer, and Bjarne Stroustrup: Understanding and Effectively Preventing the ABA Problem in Descriptor-based Lock-free Designs. 13th IEEE Computer Society ISORC 2010 Symposium. May 2010.\n* Damian Dechev and Bjarne Stroustrup: Scalable Non-blocking Concurrent Objects for Mission Critical Code. ACM OOPSLA'09. October 2009\n* Damian Dechev, Peter Pirkelbauer, Nicolas Rouquette, and Bjarne Stroustrup: Semantically Enhanced Containers for Concurrent Real-Time Systems. Proc. 16th Annual IEEE International Conference and Workshop on the Engineering of Computer Based Systems (IEEE ECBS). April 2009.\n* Maurice Herlihy, Nir Shavit, Victor Luchangco, Michael Spear, \"The Art of Multiprocessor Programming\", 2nd ed. September 2020\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-double\"></a>CP.110: Do not write your own double-checked locking for initialization",
    "content": "### <a name=\"rconc-double\"></a>CP.110: Do not write your own double-checked locking for initialization\n\n##### Reason\n\nSince C++11, static local variables are now initialized in a thread-safe way. When combined with the RAII pattern, static local variables can replace the need for writing your own double-checked locking for initialization. std::call_once can also achieve the same purpose. Use either static local variables of C++11 or std::call_once instead of writing your own double-checked locking for initialization.\n\n##### Example\n\nExample with std::call_once.\n\n    void f()\n    {\n        static std::once_flag my_once_flag;\n        std::call_once(my_once_flag, []()\n        {\n            // do this only once\n        });\n        // ...\n    }\n\nExample with thread-safe static local variables of C++11.\n\n    void f()\n    {\n        // Assuming the compiler is compliant with C++11\n        static My_class my_object; // Constructor called only once\n        // ...\n    }\n\n    class My_class\n    {\n    public:\n        My_class()\n        {\n            // do this only once\n        }\n    };\n\n##### Enforcement\n\n??? Is it possible to detect the idiom?\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-double-pattern\"></a>CP.111: Use a conventional pattern if you really need double-checked locking",
    "content": "### <a name=\"rconc-double-pattern\"></a>CP.111: Use a conventional pattern if you really need double-checked locking\n\n##### Reason\n\nDouble-checked locking is easy to mess up. If you really need to write your own double-checked locking, in spite of the rules [CP.110: Do not write your own double-checked locking for initialization](#rconc-double) and [CP.100: Don't use lock-free programming unless you absolutely have to](#rconc-lockfree), then do it in a conventional pattern.\n\nThe uses of the double-checked locking pattern that are not in violation of [CP.110: Do not write your own double-checked locking for initialization](#rconc-double) arise when a non-thread-safe action is both hard and rare, and there exists a fast thread-safe test that can be used to guarantee that the action is not needed, but cannot be used to guarantee the converse.\n\n##### Example, bad\n\nThe use of volatile does not make the first check thread-safe, see also [CP.200: Use `volatile` only to talk to non-C++ memory](#rconc-volatile2)\n\n    mutex action_mutex;\n    volatile bool action_needed;\n\n    if (action_needed) {\n        std::lock_guard<std::mutex> lock(action_mutex);\n        if (action_needed) {\n            take_action();\n            action_needed = false;\n        }\n    }\n\n##### Example, good\n\n    mutex action_mutex;\n    atomic<bool> action_needed;\n\n    if (action_needed) {\n        std::lock_guard<std::mutex> lock(action_mutex);\n        if (action_needed) {\n            take_action();\n            action_needed = false;\n        }\n    }\n\nFine-tuned memory order might be beneficial where acquire load is more efficient than sequentially-consistent load\n\n    mutex action_mutex;\n    atomic<bool> action_needed;\n\n    if (action_needed.load(memory_order_acquire)) {\n        lock_guard<std::mutex> lock(action_mutex);\n        if (action_needed.load(memory_order_relaxed)) {\n            take_action();\n            action_needed.store(false, memory_order_release);\n        }\n    }\n\n##### Enforcement\n\n??? Is it possible to detect the idiom?\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"sscp-etc\"></a>CP.etc: Etc. concurrency rules",
    "content": "## <a name=\"sscp-etc\"></a>CP.etc: Etc. concurrency rules\n\nThese rules defy simple categorization:\n\n* [CP.200: Use `volatile` only to talk to non-C++ memory](#rconc-volatile2)\n* [CP.201: ??? Signals](#rconc-signal)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-volatile2\"></a>CP.200: Use `volatile` only to talk to non-C++ memory",
    "content": "### <a name=\"rconc-volatile2\"></a>CP.200: Use `volatile` only to talk to non-C++ memory\n\n##### Reason\n\n`volatile` is used to refer to objects that are shared with \"non-C++\" code or hardware that does not follow the C++ memory model.\n\n##### Example\n\n    const volatile long clock;\n\nThis describes a register constantly updated by a clock circuit.\n`clock` is `volatile` because its value will change without any action from the C++ program that uses it.\nFor example, reading `clock` twice will often yield two different values, so the optimizer had better not optimize away the second read in this code:\n\n    long t1 = clock;\n    // ... no use of clock here ...\n    long t2 = clock;\n\n`clock` is `const` because the program should not try to write to `clock`.\n\n##### Note\n\nUnless you are writing the lowest level code manipulating hardware directly, consider `volatile` an esoteric feature that is best avoided.\n\n##### Example\n\nUsually C++ code receives `volatile` memory that is owned elsewhere (hardware or another language):\n\n    int volatile* vi = get_hardware_memory_location();\n        // note: we get a pointer to someone else's memory here\n        // volatile says \"treat this with extra respect\"\n\nSometimes C++ code allocates the `volatile` memory and shares it with \"elsewhere\" (hardware or another language) by deliberately escaping a pointer:\n\n    static volatile long vl;\n    please_use_this(&vl);   // escape a reference to this to \"elsewhere\" (not C++)\n\n##### Example, bad\n\n`volatile` local variables are nearly always wrong -- how can they be shared with other languages or hardware if they're ephemeral?\nThe same applies almost as strongly to data members, for the same reason.\n\n    void f()\n    {\n        volatile int i = 0; // bad, volatile local variable\n        // etc.\n    }\n\n    class My_type {\n        volatile int i = 0; // suspicious, volatile data member\n        // etc.\n    };\n\n##### Note\n\nIn C++, unlike in some other languages, `volatile` has [nothing to do with synchronization](#rconc-volatile).\n\n##### Enforcement\n\n* Flag `volatile T` local and data members; almost certainly you intended to use `atomic<T>` instead.\n* ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconc-signal\"></a>CP.201: ??? Signals",
    "content": "### <a name=\"rconc-signal\"></a>CP.201: ??? Signals\n\n???UNIX signal handling???. Might be worth reminding how little is async-signal-safe, and how to communicate with a signal handler (best is probably \"not at all\")\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-errors\"></a>E: Error handling",
    "content": "# <a name=\"s-errors\"></a>E: Error handling\n\nError handling involves:\n\n* Detecting an error\n* Transmitting information about an error to some handler code\n* Preserving a valid state of the program\n* Avoiding resource leaks\n\nIt is not possible to recover from all errors. If recovery from an error is not possible, it is important to quickly \"get out\" in a well-defined way. A strategy for error handling must be simple, or it becomes a source of even worse errors.  Untested and rarely executed error-handling code is itself the source of many bugs.\n\nThe rules are designed to help avoid several kinds of errors:\n\n* Type violations (e.g., misuse of `union`s and casts)\n* Resource leaks (including memory leaks)\n* Bounds errors\n* Lifetime errors (e.g., accessing an object after it has been `delete`d)\n* Complexity errors (logical errors made likely by overly complex expression of ideas)\n* Interface errors (e.g., an unexpected value is passed through an interface)\n\nError-handling rule summary:\n\n* [E.1: Develop an error-handling strategy early in a design](#re-design)\n* [E.2: Throw an exception to signal that a function can't perform its assigned task](#re-throw)\n* [E.3: Use exceptions for error handling only](#re-errors)\n* [E.4: Design your error-handling strategy around invariants](#re-design-invariants)\n* [E.5: Let a constructor establish an invariant, and throw if it cannot](#re-invariant)\n* [E.6: Use RAII to prevent leaks](#re-raii)\n* [E.7: State your preconditions](#re-precondition)\n* [E.8: State your postconditions](#re-postcondition)\n\n* [E.12: Use `noexcept` when exiting a function because of a `throw` is impossible or unacceptable](#re-noexcept)\n* [E.13: Never throw while being the direct owner of an object](#re-never-throw)\n* [E.14: Use purpose-designed user-defined types as exceptions (not built-in types)](#re-exception-types)\n* [E.15: Throw by value, catch exceptions from a hierarchy by reference](#re-exception-ref)\n* [E.16: Destructors, deallocation, `swap`, and exception type copy/move construction must never fail](#re-never-fail)\n* [E.17: Don't try to catch every exception in every function](#re-not-always)\n* [E.18: Minimize the use of explicit `try`/`catch`](#re-catch)\n* [E.19: Use a `final_action` object to express cleanup if no suitable resource handle is available](#re-finally)\n\n* [E.25: If you can't throw exceptions, simulate RAII for resource management](#re-no-throw-raii)\n* [E.26: If you can't throw exceptions, consider failing fast](#re-no-throw-crash)\n* [E.27: If you can't throw exceptions, use error codes systematically](#re-no-throw-codes)\n* [E.28: Avoid error handling based on global state (e.g. `errno`)](#re-no-throw)\n\n* [E.30: Don't use exception specifications](#re-specifications)\n* [E.31: Properly order your `catch`-clauses](#re_catch)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"re-design\"></a>E.1: Develop an error-handling strategy early in a design",
    "content": "### <a name=\"re-design\"></a>E.1: Develop an error-handling strategy early in a design\n\n##### Reason\n\nA consistent and complete strategy for handling errors and resource leaks is hard to retrofit into a system.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"re-throw\"></a>E.2: Throw an exception to signal that a function can't perform its assigned task",
    "content": "### <a name=\"re-throw\"></a>E.2: Throw an exception to signal that a function can't perform its assigned task\n\n##### Reason\n\nTo make error handling systematic, robust, and non-repetitive.\n\n##### Example\n\n    struct Foo {\n        vector<Thing> v;\n        File_handle f;\n        string s;\n    };\n\n    void use()\n    {\n        Foo bar { {Thing{1}, Thing{2}, Thing{monkey} }, {\"my_file\", \"r\"}, \"Here we go!\"};\n        // ...\n    }\n\nHere, `vector` and `string`s constructors might not be able to allocate sufficient memory for their elements, `vector`s constructor might not be able to copy the `Thing`s in its initializer list, and `File_handle` might not be able to open the required file.\nIn each case, they throw an exception for `use()`'s caller to handle.\nIf `use()` could handle the failure to construct `bar` it can take control using `try`/`catch`.\nIn either case, `Foo`'s constructor correctly destroys constructed members before passing control to whatever tried to create a `Foo`.\nNote that there is no return value that could contain an error code.\n\nThe `File_handle` constructor might be defined like this:\n\n    File_handle::File_handle(const string& name, const string& mode)\n        : f{fopen(name.c_str(), mode.c_str())}\n    {\n        if (!f)\n            throw runtime_error{\"File_handle: could not open \" + name + \" as \" + mode};\n    }\n\n##### Note\n\nIt is often said that exceptions are meant to signal exceptional events and failures.\nHowever, that's a bit circular because \"what is exceptional?\"\nExamples:\n\n* A precondition that cannot be met\n* A constructor that cannot construct an object (failure to establish its class's [invariant](#rc-struct))\n* An out-of-range error (e.g., `v[v.size()] = 7`)\n* Inability to acquire a resource (e.g., the network is down)\n\nIn contrast, termination of an ordinary loop is not exceptional.\nUnless the loop was meant to be infinite, termination is normal and expected.\n\n##### Note\n\nDon't use a `throw` as simply an alternative way of returning a value from a function.\n\n##### Exception\n\nSome systems, such as hard-real-time systems require a guarantee that an action is taken in a (typically short) constant maximum time known before execution starts. Such systems can use exceptions only if there is tool support for accurately predicting the maximum time to recover from a `throw`.\n\n**See also**: [RAII](#re-raii)\n\n**See also**: [discussion](#sd-noexcept)\n\n##### Note\n\nBefore deciding that you cannot afford or don't like exception-based error handling, have a look at the [alternatives](#re-no-throw-raii);\nthey have their own complexities and problems.\nAlso, as far as possible, measure before making claims about efficiency.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"re-errors\"></a>E.3: Use exceptions for error handling only",
    "content": "### <a name=\"re-errors\"></a>E.3: Use exceptions for error handling only\n\n##### Reason\n\nTo keep error handling separated from \"ordinary code.\"\nC++ implementations tend to be optimized based on the assumption that exceptions are rare.\n\n##### Example, don't\n\n    // don't: exception not used for error handling\n    int find_index(vector<string>& vec, const string& x)\n    {\n        try {\n            for (gsl::index i = 0; i < vec.size(); ++i)\n                if (vec[i] == x) throw i;  // found x\n        }\n        catch (int i) {\n            return i;\n        }\n        return -1;   // not found\n    }\n\nThis is more complicated and most likely runs much slower than the obvious alternative.\nThere is nothing exceptional about finding a value in a `vector`.\n\n##### Enforcement\n\nWould need to be heuristic.\nLook for exception values \"leaked\" out of `catch` clauses.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"re-design-invariants\"></a>E.4: Design your error-handling strategy around invariants",
    "content": "### <a name=\"re-design-invariants\"></a>E.4: Design your error-handling strategy around invariants\n\n##### Reason\n\nTo use an object it must be in a valid state (defined formally or informally by an invariant) and to recover from an error every object not destroyed must be in a valid state.\n\n##### Note\n\nAn [invariant](#rc-struct) is a logical condition for the members of an object that a constructor must establish for the public member functions to assume.\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"re-invariant\"></a>E.5: Let a constructor establish an invariant, and throw if it cannot",
    "content": "### <a name=\"re-invariant\"></a>E.5: Let a constructor establish an invariant, and throw if it cannot\n\n##### Reason\n\nLeaving an object without its invariant established is asking for trouble.\nNot all member functions can be called.\n\n##### Example\n\n    class Vector {  // very simplified vector of doubles\n        // if elem != nullptr then elem points to sz doubles\n    public:\n        Vector() : elem{nullptr}, sz{0}{}\n        Vector(int s) : elem{new double[s]}, sz{s} { /* initialize elements */ }\n        ~Vector() { delete [] elem; }\n        double& operator[](int s) { return elem[s]; }\n        // ...\n    private:\n        owner<double*> elem;\n        int sz;\n    };\n\nThe class invariant - here stated as a comment - is established by the constructors.\n`new` throws if it cannot allocate the required memory.\nThe operators, notably the subscript operator, rely on the invariant.\n\n**See also**: [If a constructor cannot construct a valid object, throw an exception](#rc-throw)\n\n##### Enforcement\n\nFlag classes with `private` state without a constructor (public, protected, or private).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"re-raii\"></a>E.6: Use RAII to prevent leaks",
    "content": "### <a name=\"re-raii\"></a>E.6: Use RAII to prevent leaks\n\n##### Reason\n\nLeaks are typically unacceptable.\nManual resource release is error-prone.\nRAII (\"Resource Acquisition Is Initialization\") is the simplest, most systematic way of preventing leaks.\n\n##### Example\n\n    void f1(int i)   // Bad: possible leak\n    {\n        int* p = new int[12];\n        // ...\n        if (i < 17) throw Bad{\"in f()\", i};\n        // ...\n    }\n\nWe could carefully release the resource before the throw:\n\n    void f2(int i)   // Clumsy and error-prone: explicit release\n    {\n        int* p = new int[12];\n        // ...\n        if (i < 17) {\n            delete[] p;\n            throw Bad{\"in f()\", i};\n        }\n        // ...\n    }\n\nThis is verbose. In larger code with multiple possible `throw`s explicit releases become repetitive and error-prone.\n\n    void f3(int i)   // OK: resource management done by a handle (but see below)\n    {\n        auto p = make_unique<int[]>(12);\n        // ...\n        if (i < 17) throw Bad{\"in f()\", i};\n        // ...\n    }\n\nNote that this works even when the `throw` is implicit because it happened in a called function:\n\n    void f4(int i)   // OK: resource management done by a handle (but see below)\n    {\n        auto p = make_unique<int[]>(12);\n        // ...\n        helper(i);   // might throw\n        // ...\n    }\n\nUnless you really need pointer semantics, use a local resource object:\n\n    void f5(int i)   // OK: resource management done by local object\n    {\n        vector<int> v(12);\n        // ...\n        helper(i);   // might throw\n        // ...\n    }\n\nThat's even simpler and safer, and often more efficient.\n\n##### Note\n\nIf there is no obvious resource handle and for some reason defining a proper RAII object/handle is infeasible,\nas a last resort, cleanup actions can be represented by a [`final_action`](#re-finally) object.\n\n##### Note\n\nBut what do we do if we are writing a program where exceptions cannot be used?\nFirst challenge that assumption; there are many anti-exceptions myths around.\nWe know of only a few good reasons:\n\n* We are on a system so small that the exception support would eat up most of our 2K memory.\n* We are in a hard-real-time system and we don't have tools that guarantee us that an exception is handled within the required time.\n* We are in a system with tons of legacy code using lots of pointers in difficult-to-understand ways\n  (in particular without a recognizable ownership strategy) so that exceptions could cause leaks.\n* Our implementation of the C++ exception mechanisms is unreasonably poor\n(slow, memory consuming, failing to work correctly for dynamically linked libraries, etc.).\nComplain to your implementation purveyor; if no user complains, no improvement will happen.\n* We get fired if we challenge our manager's ancient wisdom.\n\nOnly the first of these reasons is fundamental, so whenever possible, use exceptions to implement RAII, or design your RAII objects to never fail.\nWhen exceptions cannot be used, simulate RAII.\nThat is, systematically check that objects are valid after construction and still release all resources in the destructor.\nOne strategy is to add a `valid()` operation to every resource handle:\n\n    void f()\n    {\n        vector<string> vs(100);   // not std::vector: valid() added\n        if (!vs.valid()) {\n            // handle error or exit\n        }\n\n        ifstream fs(\"foo\");   // not std::ifstream: valid() added\n        if (!fs.valid()) {\n            // handle error or exit\n        }\n\n        // ...\n    } // destructors clean up as usual\n\nObviously, this increases the size of the code, doesn't allow for implicit propagation of \"exceptions\" (`valid()` checks), and `valid()` checks can be forgotten.\nPrefer to use exceptions.\n\n**See also**: [Use of `noexcept`](#re-noexcept)\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"re-precondition\"></a>E.7: State your preconditions",
    "content": "### <a name=\"re-precondition\"></a>E.7: State your preconditions\n\n##### Reason\n\nTo avoid interface errors.\n\n**See also**: [precondition rule](#ri-pre)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"re-postcondition\"></a>E.8: State your postconditions",
    "content": "### <a name=\"re-postcondition\"></a>E.8: State your postconditions\n\n##### Reason\n\nTo avoid interface errors.\n\n**See also**: [postcondition rule](#ri-post)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"re-noexcept\"></a>E.12: Use `noexcept` when exiting a function because of a `throw` is impossible or unacceptable",
    "content": "### <a name=\"re-noexcept\"></a>E.12: Use `noexcept` when exiting a function because of a `throw` is impossible or unacceptable\n\n##### Reason\n\nTo make error handling systematic, robust, and efficient.\n\n##### Example\n\n    double compute(double d) noexcept\n    {\n        return log(sqrt(d <= 0 ? 1 : d));\n    }\n\nHere, we know that `compute` will not throw because it is composed out of operations that don't throw.\nBy declaring `compute` to be `noexcept`, we give the compiler and human readers information that can make it easier for them to understand and manipulate `compute`.\n\n##### Note\n\nMany standard-library functions are `noexcept` including all the standard-library functions \"inherited\" from the C Standard Library.\n\n##### Example\n\n    vector<double> munge(const vector<double>& v) noexcept\n    {\n        vector<double> v2(v.size());\n        // ... do something ...\n    }\n\nThe `noexcept` here states that I am not willing or able to handle the situation where I cannot construct the local `vector`.\nThat is, I consider memory exhaustion a serious design error (on par with hardware failures) so that I'm willing to crash the program if it happens.\n\n##### Note\n\nDo not use traditional [exception-specifications](#re-specifications).\n\n##### See also\n\n[discussion](#sd-noexcept).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"re-never-throw\"></a>E.13: Never throw while being the direct owner of an object",
    "content": "### <a name=\"re-never-throw\"></a>E.13: Never throw while being the direct owner of an object\n\n##### Reason\n\nThat would be a leak.\n\n##### Example\n\n    void leak(int x)   // don't: might leak\n    {\n        auto p = new int{7};\n        if (x < 0) throw Get_me_out_of_here{};  // might leak *p\n        // ...\n        delete p;   // we might never get here\n    }\n\nOne way of avoiding such problems is to use resource handles consistently:\n\n    void no_leak(int x)\n    {\n        auto p = make_unique<int>(7);\n        if (x < 0) throw Get_me_out_of_here{};  // will delete *p if necessary\n        // ...\n        // no need for delete p\n    }\n\nAnother solution (often better) would be to use a local variable to eliminate explicit use of pointers:\n\n    void no_leak_simplified(int x)\n    {\n        vector<int> v(7);\n        // ...\n    }\n\n##### Note\n\nIf you have a local \"thing\" that requires cleanup, but is not represented by an object with a destructor, such cleanup must\nalso be done before a `throw`.\nSometimes, [`finally()`](#re-finally) can make such unsystematic cleanup a bit more manageable.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"re-exception-types\"></a>E.14: Use purpose-designed user-defined types as exceptions (not built-in types)",
    "content": "### <a name=\"re-exception-types\"></a>E.14: Use purpose-designed user-defined types as exceptions (not built-in types)\n\n##### Reason\n\nA user-defined type can better transmit information about an error to a handler.  Information\ncan be encoded into the type itself and the type is unlikely to clash with other people's exceptions.\n\n##### Example\n\n    throw 7; // bad\n\n    throw \"something bad\";  // bad\n\n    throw std::exception{}; // bad - no info\n\nDeriving from `std::exception` gives the flexibility to catch the specific exception or handle generally through `std::exception`:\n\n    class MyException : public std::runtime_error\n    {\n    public:\n        MyException(const string& msg) : std::runtime_error{msg} {}\n        // ...\n    };\n\n    // ...\n\n    throw MyException{\"something bad\"};  // good\n\nExceptions do not need to be derived from `std::exception`:\n\n    class MyCustomError final {};  // not derived from std::exception\n\n    // ...\n\n    throw MyCustomError{};  // good - handlers must catch this type (or ...)\n\nLibrary types derived from `std::exception` can be used as generic exceptions if\nno useful information can be added at the point of detection:\n\n    throw std::runtime_error(\"something bad\"); // good\n\n    // ...\n\n    throw std::invalid_argument(\"i is not even\"); // good\n\n`enum` classes are also allowed:\n\n    enum class alert {RED, YELLOW, GREEN};\n\n    throw alert::RED; // good\n\n##### Enforcement\n\nCatch `throw` of built-in types and `std::exception`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"re-exception-ref\"></a>E.15: Throw by value, catch exceptions from a hierarchy by reference",
    "content": "### <a name=\"re-exception-ref\"></a>E.15: Throw by value, catch exceptions from a hierarchy by reference\n\n##### Reason\n\nThrowing by value (not by pointer) and catching by reference prevents copying, especially slicing base subobjects.\n\n##### Example; bad\n\n    void f()\n    {\n        try {\n            // ...\n            throw new widget{}; // don't: throw by value, not by raw pointer\n            // ...\n        }\n        catch (base_class e) {  // don't: might slice\n            // ...\n        }\n    }\n\nInstead, use a reference:\n\n    catch (base_class& e) { /* ... */ }\n\nor - typically better still - a `const` reference:\n\n    catch (const base_class& e) { /* ... */ }\n\nMost handlers do not modify their exception and in general we [recommend use of `const`](#res-const).\n\n##### Note\n\nCatch by value can be appropriate for a small value type such as an `enum` value.\n\n##### Note\n\nTo rethrow a caught exception use `throw;` not `throw e;`. Using `throw e;` would throw a new copy of `e` (sliced to the static type `std::exception`, when the exception is caught by `catch (const std::exception& e)`) instead of rethrowing the original exception of type `std::runtime_error`. (But keep [Don't try to catch every exception in every function](#re-not-always) and [Minimize the use of explicit `try`/`catch`](#re-catch) in mind.)\n\n##### Enforcement\n\n* Flag catching by value of a type that has a virtual function.\n* Flag throwing raw pointers.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"re-never-fail\"></a>E.16: Destructors, deallocation, `swap`, and exception type copy/move construction must never fail",
    "content": "### <a name=\"re-never-fail\"></a>E.16: Destructors, deallocation, `swap`, and exception type copy/move construction must never fail\n\n##### Reason\n\nWe don't know how to write reliable programs if a destructor, a swap, a memory deallocation, or attempting to copy/move-construct an exception object fails; that is, if it exits by an exception or simply doesn't perform its required action.\n\n##### Example, don't\n\n    class Connection {\n        // ...\n    public:\n        ~Connection()   // Don't: very bad destructor\n        {\n            if (cannot_disconnect()) throw I_give_up{information};\n            // ...\n        }\n    };\n\n##### Note\n\nMany have tried to write reliable code violating this rule for examples, such as a network connection that \"refuses to close\".\nTo the best of our knowledge nobody has found a general way of doing this.\nOccasionally, for very specific examples, you can get away with setting some state for future cleanup.\nFor example, we might put a socket that does not want to close on a \"bad socket\" list,\nto be examined by a regular sweep of the system state.\nEvery example we have seen of this is error-prone, specialized, and often buggy.\n\n##### Note\n\nThe standard library assumes that destructors, deallocation functions (e.g., `operator delete`), and `swap` do not throw. If they do, basic standard-library invariants are broken.\n\n##### Note\n\n* Deallocation functions, including `operator delete`, must be `noexcept`.\n* `swap` functions must be `noexcept`.\n* Most destructors are implicitly `noexcept` by default.\n* Also, [make move operations `noexcept`](#rc-move-noexcept).\n* If writing a type intended to be used as an exception type, ensure its copy constructor is `noexcept`. In general we cannot mechanically enforce this, because we do not know whether a type is intended to be used as an exception type.\n* Try not to `throw` a type whose copy constructor is not `noexcept`. In general we cannot mechanically enforce this, because even `throw std::string(...)` could throw but does not in practice.\n\n##### Enforcement\n\n* Catch destructors, deallocation operations, and `swap`s that `throw`.\n* Catch such operations that are not `noexcept`.\n\n**See also**: [discussion](#sd-never-fail)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"re-not-always\"></a>E.17: Don't try to catch every exception in every function",
    "content": "### <a name=\"re-not-always\"></a>E.17: Don't try to catch every exception in every function\n\n##### Reason\n\nCatching an exception in a function that cannot take a meaningful recovery action leads to complexity and waste.\nLet an exception propagate until it reaches a function that can handle it.\nLet cleanup actions on the unwinding path be handled by [RAII](#re-raii).\n\n##### Example, don't\n\n    void f()   // bad\n    {\n        try {\n            // ...\n        }\n        catch (...) {\n            // no action\n            throw;   // propagate exception\n        }\n    }\n\n##### Enforcement\n\n* Flag nested try-blocks.\n* Flag source code files with a too high ratio of try-blocks to functions. (??? Problem: define \"too high\")\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"re-catch\"></a>E.18: Minimize the use of explicit `try`/`catch`",
    "content": "### <a name=\"re-catch\"></a>E.18: Minimize the use of explicit `try`/`catch`\n\n##### Reason\n\n `try`/`catch` is verbose and non-trivial uses are error-prone.\n `try`/`catch` can be a sign of unsystematic and/or low-level resource management or error handling.\n\n##### Example, Bad\n\n    void f(zstring s)\n    {\n        Gadget* p;\n        try {\n            p = new Gadget(s);\n            // ...\n            delete p;\n        }\n        catch (Gadget_construction_failure) {\n            delete p;\n            throw;\n        }\n    }\n\nThis code is messy.\nThere could be a leak from the naked pointer in the `try` block.\nNot all exceptions are handled.\n`deleting` an object that failed to construct is almost certainly a mistake.\nBetter:\n\n    void f2(zstring s)\n    {\n        Gadget g {s};\n    }\n\n##### Alternatives\n\n* proper resource handles and [RAII](#re-raii)\n* [`finally`](#re-finally)\n\n##### Enforcement\n\n??? hard, needs a heuristic\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"re-finally\"></a>E.19: Use a `final_action` object to express cleanup if no suitable resource handle is available",
    "content": "### <a name=\"re-finally\"></a>E.19: Use a `final_action` object to express cleanup if no suitable resource handle is available\n\n##### Reason\n\n`finally` from the [GSL](#gsl-guidelines-support-library) is less verbose and harder to get wrong than `try`/`catch`.\n\n##### Example\n\n    void f(int n)\n    {\n        void* p = malloc(n);\n        auto _ = gsl::finally([p] { free(p); });\n        // ...\n    }\n\n##### Note\n\n`finally` is not as messy as `try`/`catch`, but it is still ad-hoc.\nPrefer [proper resource management objects](#re-raii).\nConsider `finally` a last resort.\n\n##### Note\n\nUse of `finally` is a systematic and reasonably clean alternative to the old [`goto exit;` technique](#re-no-throw-codes)\nfor dealing with cleanup where resource management is not systematic.\n\n##### Enforcement\n\nHeuristic: Detect `goto exit;`\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"re-no-throw-raii\"></a>E.25: If you can't throw exceptions, simulate RAII for resource management",
    "content": "### <a name=\"re-no-throw-raii\"></a>E.25: If you can't throw exceptions, simulate RAII for resource management\n\n##### Reason\n\nEven without exceptions, [RAII](#re-raii) is usually the best and most systematic way of dealing with resources.\n\n##### Note\n\nError handling using exceptions is the only complete and systematic way of handling non-local errors in C++.\nIn particular, non-intrusively signaling failure to construct an object requires an exception.\nSignaling errors in a way that cannot be ignored requires exceptions.\nIf you can't use exceptions, simulate their use as best you can.\n\nA lot of fear of exceptions is misguided.\nWhen used for exceptional circumstances in code that is not littered with pointers and complicated control structures,\nexception handling is almost always affordable (in time and space) and almost always leads to better code.\nThis, of course, assumes a good implementation of the exception handling mechanisms, which is not available on all systems.\nThere are also cases where the problems above do not apply, but exceptions cannot be used for other reasons.\nSome hard-real-time systems are an example: An operation has to be completed within a fixed time with an error or a correct answer.\nIn the absence of appropriate time estimation tools, this is hard to guarantee for exceptions.\nSuch systems (e.g. flight control software) typically also ban the use of dynamic (heap) memory.\n\nSo, the primary guideline for error handling is \"use exceptions and [RAII](#re-raii).\"\nThis section deals with the cases where you either do not have an efficient implementation of exceptions,\nor have such a rat's nest of old-style code\n(e.g., lots of pointers, ill-defined ownership, and lots of unsystematic error handling based on tests of error codes)\nthat it is infeasible to introduce simple and systematic exception handling.\n\nBefore condemning exceptions or complaining too much about their cost, consider examples of the use of [error codes](#re-no-throw-codes).\nConsider the cost and complexity of the use of error codes.\nIf performance is your worry, measure.\n\n##### Example\n\nAssume you wanted to write\n\n    void func(zstring arg)\n    {\n        Gadget g {arg};\n        // ...\n    }\n\nIf the `gadget` isn't correctly constructed, `func` exits with an exception.\nIf we cannot throw an exception, we can simulate this RAII style of resource handling by adding a `valid()` member function to `Gadget`:\n\n    error_indicator func(zstring arg)\n    {\n        Gadget g {arg};\n        if (!g.valid()) return gadget_construction_error;\n        // ...\n        return 0;   // zero indicates \"good\"\n    }\n\nThe problem is of course that the caller now has to remember to test the return value. To encourage doing so, consider adding a `[[nodiscard]]`.\n\n**See also**: [Discussion](#sd-???)\n\n##### Enforcement\n\nPossible (only) for specific versions of this idea: e.g., test for systematic test of `valid()` after resource handle construction\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"re-no-throw-crash\"></a>E.26: If you can't throw exceptions, consider failing fast",
    "content": "### <a name=\"re-no-throw-crash\"></a>E.26: If you can't throw exceptions, consider failing fast\n\n##### Reason\n\nIf you can't do a good job at recovering, at least you can get out before too much consequential damage is done.\n\n**See also**: [Simulating RAII](#re-no-throw-raii)\n\n##### Note\n\nIf you cannot be systematic about error handling, consider \"crashing\" as a response to any error that cannot be handled locally.\nThat is, if you cannot recover from an error in the context of the function that detected it, call `abort()`, `quick_exit()`,\nor a similar function that will trigger some sort of system restart.\n\nIn systems where you have lots of processes and/or lots of computers, you need to expect and handle fatal crashes anyway,\nsay from hardware failures.\nIn such cases, \"crashing\" is simply leaving error handling to the next level of the system.\n\n##### Example\n\n    void f(int n)\n    {\n        // ...\n        p = static_cast<X*>(malloc(n * sizeof(X)));\n        if (!p) abort();     // abort if memory is exhausted\n        // ...\n    }\n\nMost programs cannot handle memory exhaustion gracefully anyway. This is roughly equivalent to\n\n    void f(int n)\n    {\n        // ...\n        p = new X[n];    // throw if memory is exhausted (by default, terminate)\n        // ...\n    }\n\nTypically, it is a good idea to log the reason for the \"crash\" before exiting.\n\n##### Enforcement\n\nAwkward\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"re-no-throw-codes\"></a>E.27: If you can't throw exceptions, use error codes systematically",
    "content": "### <a name=\"re-no-throw-codes\"></a>E.27: If you can't throw exceptions, use error codes systematically\n\n##### Reason\n\nSystematic use of any error-handling strategy minimizes the chance of forgetting to handle an error.\n\n**See also**: [Simulating RAII](#re-no-throw-raii)\n\n##### Note\n\nThere are several issues to be addressed:\n\n* How do you transmit an error indicator from out of a function?\n* How do you release all resources from a function before doing an error exit?\n* What do you use as an error indicator?\n\nIn general, returning an error indicator implies returning two values: The result and an error indicator.\nThe error indicator can be part of the object, e.g. an object can have a `valid()` indicator\nor a pair of values can be returned.\n\n##### Example\n\n    Gadget make_gadget(int n)\n    {\n        // ...\n    }\n\n    void user()\n    {\n        Gadget g = make_gadget(17);\n        if (!g.valid()) {\n                // error handling\n        }\n        // ...\n    }\n\nThis approach fits with [simulated RAII resource management](#re-no-throw-raii).\nThe `valid()` function could return an `error_indicator` (e.g. a member of an `error_indicator` enumeration).\n\n##### Example\n\nWhat if we cannot or do not want to modify the `Gadget` type?\nIn that case, we must return a pair of values.\nFor example:\n\n    std::pair<Gadget, error_indicator> make_gadget(int n)\n    {\n        // ...\n    }\n\n    void user()\n    {\n        auto r = make_gadget(17);\n        if (!r.second) {\n                // error handling\n        }\n        Gadget& g = r.first;\n        // ...\n    }\n\nAs shown, `std::pair` is a possible return type.\nSome people prefer a specific type.\nFor example:\n\n    Gval make_gadget(int n)\n    {\n        // ...\n    }\n\n    void user()\n    {\n        auto r = make_gadget(17);\n        if (!r.err) {\n                // error handling\n        }\n        Gadget& g = r.val;\n        // ...\n    }\n\nOne reason to prefer a specific return type is to have names for its members, rather than the somewhat cryptic `first` and `second`\nand to avoid confusion with other uses of `std::pair`.\n\n##### Example\n\nIn general, you must clean up before an error exit.\nThis can be messy:\n\n    std::pair<int, error_indicator> user()\n    {\n        Gadget g1 = make_gadget(17);\n        if (!g1.valid()) {\n            return {0, g1_error};\n        }\n\n        Gadget g2 = make_gadget(31);\n        if (!g2.valid()) {\n            cleanup(g1);\n            return {0, g2_error};\n        }\n\n        // ...\n\n        if (all_foobar(g1, g2)) {\n            cleanup(g2);\n            cleanup(g1);\n            return {0, foobar_error};\n        }\n\n        // ...\n\n        cleanup(g2);\n        cleanup(g1);\n        return {res, 0};\n    }\n\nSimulating RAII can be non-trivial, especially in functions with multiple resources and multiple possible errors.\nA not uncommon technique is to gather cleanup at the end of the function to avoid repetition (note that the extra scope around `g2` is undesirable but necessary to make the `goto` version compile):\n\n    std::pair<int, error_indicator> user()\n    {\n        error_indicator err = 0;\n        int res = 0;\n\n        Gadget g1 = make_gadget(17);\n        if (!g1.valid()) {\n            err = g1_error;\n            goto g1_exit;\n        }\n\n        {\n            Gadget g2 = make_gadget(31);\n            if (!g2.valid()) {\n                err = g2_error;\n                goto g2_exit;\n            }\n\n            if (all_foobar(g1, g2)) {\n                err = foobar_error;\n                goto g2_exit;\n            }\n\n            // ...\n\n        g2_exit:\n            if (g2.valid()) cleanup(g2);\n        }\n\n    g1_exit:\n        if (g1.valid()) cleanup(g1);\n        return {res, err};\n    }\n\nThe larger the function, the more tempting this technique becomes.\n`finally` can [ease the pain a bit](#re-finally).\nAlso, the larger the program becomes the harder it is to apply an error-indicator-based error-handling strategy systematically.\n\nWe [prefer exception-based error handling](#re-throw) and recommend [keeping functions short](#rf-single).\n\n**See also**: [Discussion](#sd-???)\n\n**See also**: [Returning multiple values](#rf-out-multi)\n\n##### Enforcement\n\nAwkward.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"re-no-throw\"></a>E.28: Avoid error handling based on global state (e.g. `errno`)",
    "content": "### <a name=\"re-no-throw\"></a>E.28: Avoid error handling based on global state (e.g. `errno`)\n\n##### Reason\n\nGlobal state is hard to manage and it is easy to forget to check it.\nWhen did you last test the return value of `printf()`?\n\n**See also**: [Simulating RAII](#re-no-throw-raii)\n\n##### Example, bad\n\n    int last_err;\n\n    void f(int n)\n    {\n        // ...\n        p = static_cast<X*>(malloc(n * sizeof(X)));\n        if (!p) last_err = -1;     // error if memory is exhausted\n        // ...\n    }\n\n##### Note\n\nC-style error handling is based on the global variable `errno`, so it is essentially impossible to avoid this style completely.\n\n##### Enforcement\n\nAwkward.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"re-specifications\"></a>E.30: Don't use exception specifications",
    "content": "### <a name=\"re-specifications\"></a>E.30: Don't use exception specifications\n\n##### Reason\n\nException specifications make error handling brittle, impose a run-time cost, and have been removed from the C++ standard.\n\n##### Example\n\n    int use(int arg)\n        throw(X, Y)\n    {\n        // ...\n        auto x = f(arg);\n        // ...\n    }\n\nIf `f()` throws an exception different from `X` and `Y` the unexpected handler is invoked, which by default terminates.\nThat's OK, but say that we have checked that this cannot happen and `f` is changed to throw a new exception `Z`,\nwe now have a crash on our hands unless we change `use()` (and re-test everything).\nThe snag is that `f()` might be in a library we do not control and the new exception is not anything that `use()` can do\nanything about or is in any way interested in.\nWe can change `use()` to pass `Z` through, but now `use()`'s callers probably need to be modified.\nThis quickly becomes unmanageable.\nAlternatively, we can add a `try`-`catch` to `use()` to map `Z` into an acceptable exception.\nThis, too, quickly becomes unmanageable.\nNote that changes to the set of exceptions often happen at the lowest level of a system\n(e.g., because of changes to a network library or some middleware), so changes \"bubble up\" through long call chains.\nIn a large code base, this could mean that nobody could update to a new version of a library until the last user was modified.\nIf `use()` is part of a library, it might not be possible to update it because a change could affect unknown clients.\n\nThe policy of letting exceptions propagate until they reach a function that potentially can handle it has proven itself over the years.\n\n##### Note\n\nNo. This would not be any better had exception specifications been statically enforced.\nFor example, see [Stroustrup94](#Stroustrup94).\n\n##### Note\n\nIf no exception can be thrown, use [`noexcept`](#re-noexcept).\n\n##### Enforcement\n\nFlag every exception specification.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"re_catch\"></a>E.31: Properly order your `catch`-clauses",
    "content": "### <a name=\"re_catch\"></a>E.31: Properly order your `catch`-clauses\n\n##### Reason\n\n`catch`-clauses are evaluated in the order they appear and one clause can hide another.\n\n##### Example, bad\n\n    void f()\n    {\n        // ...\n        try {\n                // ...\n        }\n        catch (Base& b) { /* ... */ }\n        catch (Derived& d) { /* ... */ }\n        catch (...) { /* ... */ }\n        catch (std::exception& e) { /* ... */ }\n    }\n\nIf `Derived`is derived from `Base` the `Derived`-handler will never be invoked.\nThe \"catch everything\" handler ensured that the `std::exception`-handler will never be invoked.\n\n##### Enforcement\n\nFlag all \"hiding handlers\".\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-const\"></a>Con: Constants and immutability",
    "content": "# <a name=\"s-const\"></a>Con: Constants and immutability\n\nYou can't have a race condition on a constant.\nIt is easier to reason about a program when many of the objects cannot change their values.\nInterfaces that promise \"no change\" of objects passed as arguments greatly increase readability.\n\nConstant rule summary:\n\n* [Con.1: By default, make objects immutable](#rconst-immutable)\n* [Con.2: By default, make member functions `const`](#rconst-fct)\n* [Con.3: By default, pass pointers and references to `const`s](#rconst-ref)\n* [Con.4: Use `const` to define objects with values that do not change after construction](#rconst-const)\n* [Con.5: Use `constexpr` for values that can be computed at compile time](#rconst-constexpr)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconst-immutable\"></a>Con.1: By default, make objects immutable",
    "content": "### <a name=\"rconst-immutable\"></a>Con.1: By default, make objects immutable\n\n##### Reason\n\nImmutable objects are easier to reason about, so make objects non-`const` only when there is a need to change their value.\nPrevents accidental or hard-to-notice change of value.\n\n##### Example\n\n    for (const int i : c) cout << i << '\\n';    // just reading: const\n\n    for (int i : c) cout << i << '\\n';          // BAD: just reading\n\n##### Exceptions\n\nA local variable that is returned by value and is cheaper to move than copy should not be declared `const`\nbecause it can force an unnecessary copy.\n\n    std::vector<int> f(int i)\n    {\n        std::vector<int> v{ i, i, i };  // const not needed\n        return v;\n    }\n\nFunction parameters passed by value are rarely mutated, but also rarely declared `const`.\nTo avoid confusion and lots of false positives, don't enforce this rule for function parameters.\n\n    void g(const int i) { ... }  // pedantic\n\nNote that a function parameter is a local variable so changes to it are local.\n\n##### Enforcement\n\n* Flag non-`const` variables that are not modified (except for parameters to avoid many false positives\nand returned local variables)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconst-fct\"></a>Con.2: By default, make member functions `const`",
    "content": "### <a name=\"rconst-fct\"></a>Con.2: By default, make member functions `const`\n\n##### Reason\n\nA member function should be marked `const` unless it changes the object's observable state.\nThis gives a more precise statement of design intent, better readability, more errors caught by the compiler, and sometimes more optimization opportunities.\n\n##### Example, bad\n\n    class Point {\n        int x, y;\n    public:\n        int getx() { return x; }    // BAD, should be const as it doesn't modify the object's state\n        // ...\n    };\n\n    void f(const Point& pt)\n    {\n        int x = pt.getx();          // ERROR, doesn't compile because getx was not marked const\n    }\n\n##### Note\n\nIt is not inherently bad to pass a pointer or reference to non-`const`,\nbut that should be done only when the called function is supposed to modify the object.\nA reader of code must assume that a function that takes a \"plain\" `T*` or `T&` will modify the object referred to.\nIf it doesn't now, it might do so later without forcing recompilation.\n\n##### Note\n\nThere are code/libraries that offer functions that declare a `T*` even though\nthose functions do not modify that `T`.\nThis is a problem for people modernizing code.\nYou can\n\n* update the library to be `const`-correct; preferred long-term solution\n* \"cast away `const`\"; [best avoided](#res-casts-const)\n* provide a wrapper function\n\nExample:\n\n    void f(int* p);   // old code: f() does not modify `*p`\n    void f(const int* p) { f(const_cast<int*>(p)); } // wrapper\n\nNote that this wrapper solution is a patch that should be used only when the declaration of `f()` cannot be modified,\ne.g. because it is in a library that you cannot modify.\n\n##### Note\n\nA `const` member function can modify the value of an object that is `mutable` or accessed through a pointer member.\nA common use is to maintain a cache rather than repeatedly do a complicated computation.\nFor example, here is a `Date` that caches (memoizes) its string representation to simplify repeated uses:\n\n    class Date {\n    public:\n        // ...\n        const string& string_ref() const\n        {\n            if (string_val == \"\") compute_string_rep();\n            return string_val;\n        }\n        // ...\n    private:\n        void compute_string_rep() const;    // compute string representation and place it in string_val\n        mutable string string_val;\n        // ...\n    };\n\nAnother way of saying this is that `const`ness is not transitive.\nIt is possible for a `const` member function to change the value of `mutable` members and the value of objects accessed\nthrough non-`const` pointers.\nIt is the job of the class to ensure such mutation is done only when it makes sense according to the semantics (invariants)\nit offers to its users.\n\n**See also**: [Pimpl](#ri-pimpl)\n\n##### Enforcement\n\n* Flag a member function that is not marked `const`, but that does not perform a non-`const` operation on any data member.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconst-ref\"></a>Con.3: By default, pass pointers and references to `const`s",
    "content": "### <a name=\"rconst-ref\"></a>Con.3: By default, pass pointers and references to `const`s\n\n##### Reason\n\n To avoid a called function unexpectedly changing the value.\n It's far easier to reason about programs when called functions don't modify state.\n\n##### Example\n\n    void f(char* p);        // does f modify *p? (assume it does)\n    void g(const char* p);  // g does not modify *p\n\n##### Note\n\nIt is not inherently bad to pass a pointer or reference to non-`const`,\nbut that should be done only when the called function is supposed to modify the object.\n\n##### Note\n\n[Do not cast away `const`](#res-casts-const).\n\n##### Enforcement\n\n* Flag a function that does not modify an object passed by pointer or reference to non-`const`\n* Flag a function that (using a cast) modifies an object passed by pointer or reference to `const`\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconst-const\"></a>Con.4: Use `const` to define objects with values that do not change after construction",
    "content": "### <a name=\"rconst-const\"></a>Con.4: Use `const` to define objects with values that do not change after construction\n\n##### Reason\n\n Prevent surprises from unexpectedly changed object values.\n\n##### Example\n\n    void f()\n    {\n        int x = 7;\n        const int y = 9;\n\n        for (;;) {\n            // ...\n        }\n        // ...\n    }\n\nAs `x` is not `const`, we must assume that it is modified somewhere in the loop.\n\n##### Enforcement\n\n* Flag unmodified non-`const` variables.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rconst-constexpr\"></a>Con.5: Use `constexpr` for values that can be computed at compile time",
    "content": "### <a name=\"rconst-constexpr\"></a>Con.5: Use `constexpr` for values that can be computed at compile time\n\n##### Reason\n\nBetter performance, better compile-time checking, guaranteed compile-time evaluation, no possibility of race conditions.\n\n##### Example\n\n    double x = f(2);            // possible run-time evaluation\n    const double y = f(2);      // possible run-time evaluation\n    constexpr double z = f(2);  // error unless f(2) can be evaluated at compile time\n\n##### Note\n\nSee F.4.\n\n##### Enforcement\n\n* Flag `const` definitions with constant expression initializers.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-templates\"></a>T: Templates and generic programming",
    "content": "# <a name=\"s-templates\"></a>T: Templates and generic programming\n\nGeneric programming is programming using types and algorithms parameterized by types, values, and algorithms.\nIn C++, generic programming is supported by the `template` language mechanisms.\n\nArguments to generic functions are characterized by sets of requirements on the argument types and values involved.\nIn C++, these requirements are expressed by compile-time predicates called concepts.\n\nTemplates can also be used for meta-programming; that is, programs that compose code at compile time.\n\nA central notion in generic programming is \"concepts\"; that is, requirements on template arguments presented as compile-time predicates.\n\"Concepts\" were standardized in C++20, although they were first made available, in slightly older syntax, in GCC 6.1.\n\nTemplate use rule summary:\n\n* [T.1: Use templates to raise the level of abstraction of code](#rt-raise)\n* [T.2: Use templates to express algorithms that apply to many argument types](#rt-algo)\n* [T.3: Use templates to express containers and ranges](#rt-cont)\n* [T.4: Use templates to express syntax tree manipulation](#rt-expr)\n* [T.5: Combine generic and OO techniques to amplify their strengths, not their costs](#rt-generic-oo)\n\nConcept use rule summary:\n\n* [T.10: Specify concepts for all template arguments](#rt-concepts)\n* [T.11: Whenever possible use standard concepts](#rt-std-concepts)\n* [T.12: Prefer concept names over `auto` for local variables](#rt-auto)\n* [T.13: Prefer the shorthand notation for simple, single-type argument concepts](#rt-shorthand)\n* ???\n\nConcept definition rule summary:\n\n* [T.20: Avoid \"concepts\" without meaningful semantics](#rt-low)\n* [T.21: Require a complete set of operations for a concept](#rt-complete)\n* [T.22: Specify axioms for concepts](#rt-axiom)\n* [T.23: Differentiate a refined concept from its more general case by adding new use patterns](#rt-refine)\n* [T.24: Use tag classes or traits to differentiate concepts that differ only in semantics](#rt-tag)\n* [T.25: Avoid complementary constraints](#rt-not)\n* [T.26: Prefer to define concepts in terms of use-patterns rather than simple syntax](#rt-use)\n* [T.30: Use concept negation (`!C<T>`) sparingly to express a minor difference](#rt-???)\n* [T.31: Use concept disjunction (`C1<T> || C2<T>`) sparingly to express alternatives](#rt-???)\n* ???\n\nTemplate interface rule summary:\n\n* [T.40: Use function objects to pass operations to algorithms](#rt-fo)\n* [T.41: Require only essential properties in a template's concepts](#rt-essential)\n* [T.42: Use template aliases to simplify notation and hide implementation details](#rt-alias)\n* [T.43: Prefer `using` over `typedef` for defining aliases](#rt-using)\n* [T.44: Use function templates to deduce class template argument types (where feasible)](#rt-deduce)\n* [T.46: Require template arguments to be at least semiregular](#rt-regular)\n* [T.47: Avoid highly visible unconstrained templates with common names](#rt-visible)\n* [T.48: If your compiler does not support concepts, fake them with `enable_if`](#rt-concept-def)\n* [T.49: Where possible, avoid type-erasure](#rt-erasure)\n\nTemplate definition rule summary:\n\n* [T.60: Minimize a template's context dependencies](#rt-depend)\n* [T.61: Do not over-parameterize members (SCARY)](#rt-scary)\n* [T.62: Place non-dependent class template members in a non-templated base class](#rt-nondependent)\n* [T.64: Use specialization to provide alternative implementations of class templates](#rt-specialization)\n* [T.65: Use tag dispatch to provide alternative implementations of functions](#rt-tag-dispatch)\n* [T.67: Use specialization to provide alternative implementations for irregular types](#rt-specialization2)\n* [T.68: Use `{}` rather than `()` within templates to avoid ambiguities](#rt-cast)\n* [T.69: Inside a template, don't make an unqualified non-member function call unless you intend it to be a customization point](#rt-customization)\n\nTemplate and hierarchy rule summary:\n\n* [T.80: Do not naively templatize a class hierarchy](#rt-hier)\n* [T.81: Do not mix hierarchies and arrays](#rt-array) // ??? somewhere in \"hierarchies\"\n* [T.82: Linearize a hierarchy when virtual functions are undesirable](#rt-linear)\n* [T.83: Do not declare a member function template virtual](#rt-virtual)\n* [T.84: Use a non-template core implementation to provide an ABI-stable interface](#rt-abi)\n* [T.??: ????](#rt-???)\n\nVariadic template rule summary:\n\n* [T.100: Use variadic templates when you need a function that takes a variable number of arguments of a variety of types](#rt-variadic)\n* [T.101: ??? How to pass arguments to a variadic template ???](#rt-variadic-pass)\n* [T.102: ??? How to process arguments to a variadic template ???](#rt-variadic-process)\n* [T.103: Don't use variadic templates for homogeneous argument lists](#rt-variadic-not)\n* [T.??: ????](#rt-???)\n\nMetaprogramming rule summary:\n\n* [T.120: Use template metaprogramming only when you really need to](#rt-metameta)\n* [T.121: Use template metaprogramming primarily to emulate concepts](#rt-emulate)\n* [T.122: Use templates (usually template aliases) to compute types at compile time](#rt-tmp)\n* [T.123: Use `constexpr` functions to compute values at compile time](#rt-fct)\n* [T.124: Prefer to use standard-library TMP facilities](#rt-std-tmp)\n* [T.125: If you need to go beyond the standard-library TMP facilities, use an existing library](#rt-lib)\n* [T.??: ????](#rt-???)\n\nOther template rules summary:\n\n* [T.140: If an operation can be reused, give it a name](#rt-name)\n* [T.141: Use an unnamed lambda if you need a simple function object in one place only](#rt-lambda)\n* [T.142: Use template variables to simplify notation](#rt-var)\n* [T.143: Don't write unintentionally non-generic code](#rt-non-generic)\n* [T.144: Don't specialize function templates](#rt-specialize-function)\n* [T.150: Check that a class matches a concept using `static_assert`](#rt-check-class)\n* [T.??: ????](#rt-???)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-gp\"></a>T.gp: Generic programming",
    "content": "## <a name=\"ss-gp\"></a>T.gp: Generic programming\n\nGeneric programming is programming using types and algorithms parameterized by types, values, and algorithms.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-raise\"></a>T.1: Use templates to raise the level of abstraction of code",
    "content": "### <a name=\"rt-raise\"></a>T.1: Use templates to raise the level of abstraction of code\n\n##### Reason\n\nGenerality. Reuse. Efficiency. Encourages consistent definition of user types.\n\n##### Example, bad\n\nConceptually, the following requirements are wrong because what we want of `T` is more than just the very low-level concepts of \"can be incremented\" or \"can be added\":\n\n    template<typename T>\n        requires Incrementable<T>\n    T sum1(vector<T>& v, T s)\n    {\n        for (auto x : v) s += x;\n        return s;\n    }\n\n    template<typename T>\n        requires Simple_number<T>\n    T sum2(vector<T>& v, T s)\n    {\n        for (auto x : v) s = s + x;\n        return s;\n    }\n\nAssuming that `Incrementable` does not support `+` and `Simple_number` does not support `+=`, we have overconstrained implementers of `sum1` and `sum2`.\nAnd, in this case, missed an opportunity for a generalization.\n\n##### Example\n\n    template<typename T>\n        requires Arithmetic<T>\n    T sum(vector<T>& v, T s)\n    {\n        for (auto x : v) s += x;\n        return s;\n    }\n\nAssuming that `Arithmetic` requires both `+` and `+=`, we have constrained the user of `sum` to provide a complete arithmetic type.\nThat is not a minimal requirement, but it gives the implementer of algorithms much needed freedom and ensures that any `Arithmetic` type\ncan be used for a wide variety of algorithms.\n\nFor additional generality and reusability, we could also use a more general `Container` or `Range` concept instead of committing to only one container, `vector`.\n\n##### Note\n\nIf we define a template to require exactly the operations required for a single implementation of a single algorithm\n(e.g., requiring just `+=` rather than also `=` and `+`) and only those, we have overconstrained maintainers.\nWe aim to minimize requirements on template arguments, but the absolutely minimal requirements of an implementation is rarely a meaningful concept.\n\n##### Note\n\nTemplates can be used to express essentially everything (they are Turing complete), but the aim of generic programming (as expressed using templates)\nis to efficiently generalize operations/algorithms over a set of types with similar semantic properties.\n\n##### Enforcement\n\n* Flag algorithms with \"overly simple\" requirements, such as direct use of specific operators without a concept.\n* Do not flag the definition of the \"overly simple\" concepts themselves; they might simply be building blocks for more useful concepts.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-algo\"></a>T.2: Use templates to express algorithms that apply to many argument types",
    "content": "### <a name=\"rt-algo\"></a>T.2: Use templates to express algorithms that apply to many argument types\n\n##### Reason\n\nGenerality. Minimizing the amount of source code. Interoperability. Reuse.\n\n##### Example\n\nThat's the foundation of the STL. A single `find` algorithm easily works with any kind of input range:\n\n    template<typename Iter, typename Val>\n        // requires Input_iterator<Iter>\n        //       && Equality_comparable<Value_type<Iter>, Val>\n    Iter find(Iter b, Iter e, Val v)\n    {\n        // ...\n    }\n\n##### Note\n\nDon't use a template unless you have a realistic need for more than one template argument type.\nDon't overabstract.\n\n##### Enforcement\n\n??? tough, probably needs a human\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-cont\"></a>T.3: Use templates to express containers and ranges",
    "content": "### <a name=\"rt-cont\"></a>T.3: Use templates to express containers and ranges\n\n##### Reason\n\nContainers need an element type, and expressing that as a template argument is general, reusable, and type safe.\nIt also avoids brittle or inefficient workarounds. Convention: That's the way the STL does it.\n\n##### Example\n\n    template<typename T>\n        // requires Regular<T>\n    class Vector {\n        // ...\n        T* elem;   // points to sz Ts\n        int sz;\n    };\n\n    Vector<double> v(10);\n    v[7] = 9.9;\n\n##### Example, bad\n\n    class Container {\n        // ...\n        void* elem;   // points to size elements of some type\n        int sz;\n    };\n\n    Container c(10, sizeof(double));\n    ((double*) c.elem)[7] = 9.9;\n\nThis doesn't directly express the intent of the programmer and hides the structure of the program from the type system and optimizer.\n\nHiding the `void*` behind macros simply obscures the problems and introduces new opportunities for confusion.\n\n**Exceptions**: If you need an ABI-stable interface, you might have to provide a base implementation and express the (type-safe) template in terms of that.\nSee [Stable base](#rt-abi).\n\n##### Enforcement\n\n* Flag uses of `void*`s and casts outside low-level implementation code\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-expr\"></a>T.4: Use templates to express syntax tree manipulation",
    "content": "### <a name=\"rt-expr\"></a>T.4: Use templates to express syntax tree manipulation\n\n##### Reason\n\n ???\n\n##### Example\n\n    ???\n\n**Exceptions**: ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-generic-oo\"></a>T.5: Combine generic and OO techniques to amplify their strengths, not their costs",
    "content": "### <a name=\"rt-generic-oo\"></a>T.5: Combine generic and OO techniques to amplify their strengths, not their costs\n\n##### Reason\n\nGeneric and OO techniques are complementary.\n\n##### Example\n\nStatic helps dynamic: Use static polymorphism to implement dynamically polymorphic interfaces.\n\n    class Command {\n        // pure virtual functions\n    };\n\n    // implementations\n    template</*...*/>\n    class ConcreteCommand : public Command {\n        // implement virtuals\n    };\n\n##### Example\n\nDynamic helps static: Offer a generic, comfortable, statically bound interface, but internally dispatch dynamically, so you offer a uniform object layout.\nExamples include type erasure as with `std::shared_ptr`'s deleter (but [don't overuse type erasure](#rt-erasure)).\n\n    #include <memory>\n\n    class Object {\n    public:\n        template<typename T>\n        Object(T&& obj)\n            : concept_(std::make_shared<ConcreteCommand<T>>(std::forward<T>(obj))) {}\n\n        int get_id() const { return concept_->get_id(); }\n\n    private:\n        struct Command {\n            virtual ~Command() {}\n            virtual int get_id() const = 0;\n        };\n\n        template<typename T>\n        struct ConcreteCommand final : Command {\n            ConcreteCommand(T&& obj) noexcept : object_(std::forward<T>(obj)) {}\n            int get_id() const final { return object_.get_id(); }\n\n        private:\n            T object_;\n        };\n\n        std::shared_ptr<Command> concept_;\n    };\n\n    class Bar {\n    public:\n        int get_id() const { return 1; }\n    };\n\n    struct Foo {\n    public:\n        int get_id() const { return 2; }\n    };\n\n    Object o(Bar{});\n    Object o2(Foo{});\n\n##### Note\n\nIn a class template, non-virtual functions are only instantiated if they're used -- but virtual functions are instantiated every time.\nThis can bloat code size, and might overconstrain a generic type by instantiating functionality that is never needed.\nAvoid this, even though the standard-library facets made this mistake.\n\n##### See also\n\n* ref ???\n* ref ???\n* ref ???\n\n##### Enforcement\n\nSee the reference to more specific rules.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-concepts\"></a>T.concepts: Concept rules",
    "content": "## <a name=\"ss-concepts\"></a>T.concepts: Concept rules\n\nConcepts is a C++20 facility for specifying requirements for template arguments.\nThey are crucial in the thinking about generic programming and the basis of much work on future C++ libraries\n(standard and other).\n\nThis section assumes concept support\n\nConcept use rule summary:\n\n* [T.10: Specify concepts for all template arguments](#rt-concepts)\n* [T.11: Whenever possible use standard concepts](#rt-std-concepts)\n* [T.12: Prefer concept names over `auto`](#rt-auto)\n* [T.13: Prefer the shorthand notation for simple, single-type argument concepts](#rt-shorthand)\n* ???\n\nConcept definition rule summary:\n\n* [T.20: Avoid \"concepts\" without meaningful semantics](#rt-low)\n* [T.21: Require a complete set of operations for a concept](#rt-complete)\n* [T.22: Specify axioms for concepts](#rt-axiom)\n* [T.23: Differentiate a refined concept from its more general case by adding new use patterns](#rt-refine)\n* [T.24: Use tag classes or traits to differentiate concepts that differ only in semantics](#rt-tag)\n* [T.25: Avoid complimentary constraints](#rt-not)\n* [T.26: Prefer to define concepts in terms of use-patterns rather than simple syntax](#rt-use)\n* ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-concept-use\"></a>T.con-use: Concept use",
    "content": "## <a name=\"ss-concept-use\"></a>T.con-use: Concept use\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-concepts\"></a>T.10: Specify concepts for all template arguments",
    "content": "### <a name=\"rt-concepts\"></a>T.10: Specify concepts for all template arguments\n\n##### Reason\n\nCorrectness and readability.\nThe assumed meaning (syntax and semantics) of a template argument is fundamental to the interface of a template.\nA concept dramatically improves documentation and error handling for the template.\nSpecifying concepts for template arguments is a powerful design tool.\n\n##### Example\n\n    template<typename Iter, typename Val>\n        requires input_iterator<Iter>\n                 && equality_comparable_with<iter_value_t<Iter>, Val>\n    Iter find(Iter b, Iter e, Val v)\n    {\n        // ...\n    }\n\nor equivalently and more succinctly:\n\n    template<input_iterator Iter, typename Val>\n        requires equality_comparable_with<iter_value_t<Iter>, Val>\n    Iter find(Iter b, Iter e, Val v)\n    {\n        // ...\n    }\n\n##### Note\n\nPlain `typename` (or `auto`) is the least constraining concept.\nIt should be used only rarely when nothing more than \"it's a type\" can be assumed.\nThis is typically only needed when (as part of template metaprogramming code) we manipulate pure expression trees, postponing type checking.\n\n**References**: TC++PL4\n\n##### Enforcement\n\nFlag template type arguments without concepts\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-std-concepts\"></a>T.11: Whenever possible use standard concepts",
    "content": "### <a name=\"rt-std-concepts\"></a>T.11: Whenever possible use standard concepts\n\n##### Reason\n\n \"Standard\" concepts (as provided by the [GSL](#gsl-guidelines-support-library) and the ISO standard itself)\nsave us the work of thinking up our own concepts, are better thought out than we can manage to do in a hurry, and improve interoperability.\n\n##### Note\n\nUnless you are creating a new generic library, most of the concepts you need will already be defined by the standard library.\n\n##### Example\n\n    template<typename T>\n        // don't define this: sortable is in <iterator>\n    concept Ordered_container = Sequence<T> && Random_access<Iterator<T>> && Ordered<Value_type<T>>;\n\n    void sort(Ordered_container auto& s);\n\nThis `Ordered_container` is quite plausible, but it is very similar to the `sortable` concept in the standard library.\nIs it better? Is it right? Does it accurately reflect the standard's requirements for `sort`?\nIt is better and simpler just to use `sortable`:\n\n    void sort(sortable auto& s);   // better\n\n##### Note\n\nThe set of \"standard\" concepts is evolving as we approach an ISO standard including concepts.\n\n##### Note\n\nDesigning a useful concept is challenging.\n\n##### Enforcement\n\nHard.\n\n* Look for unconstrained arguments, templates that use \"unusual\"/non-standard concepts, templates that use \"homebrew\" concepts without axioms.\n* Develop a concept-discovery tool (e.g., see [an early experiment](https://www.stroustrup.com/sle2010_webversion.pdf)).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-auto\"></a>T.12: Prefer concept names over `auto` for local variables",
    "content": "### <a name=\"rt-auto\"></a>T.12: Prefer concept names over `auto` for local variables\n\n##### Reason\n\n `auto` is the weakest concept. Concept names convey more meaning than just `auto`.\n\n##### Example\n\n    vector<string> v{ \"abc\", \"xyz\" };\n    auto& x = v.front();        // bad\n    String auto& s = v.front(); // good (String is a GSL concept)\n\n##### Enforcement\n\n* ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-shorthand\"></a>T.13: Prefer the shorthand notation for simple, single-type argument concepts",
    "content": "### <a name=\"rt-shorthand\"></a>T.13: Prefer the shorthand notation for simple, single-type argument concepts\n\n##### Reason\n\nReadability. Direct expression of an idea.\n\n##### Example\n\nTo say \"`T` is `sortable`\":\n\n    template<typename T>       // Correct but verbose: \"The parameter is\n        requires sortable<T>   // of type T which is the name of a type\n    void sort(T&);             // that is sortable\"\n\n    template<sortable T>       // Better: \"The parameter is of type T\n    void sort(T&);             // which is Sortable\"\n\n    void sort(sortable auto&); // Best: \"The parameter is Sortable\"\n\nThe shorter versions better match the way we speak. Note that many templates don't need to use the `template` keyword.\n\n##### Enforcement\n\n* Not feasible in the short term when people convert from the `<typename T>` and `<class T`> notation.\n* Later, flag declarations that first introduce a typename and then constrain it with a simple, single-type-argument concept.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-concepts-def\"></a>T.concepts.def: Concept definition rules",
    "content": "## <a name=\"ss-concepts-def\"></a>T.concepts.def: Concept definition rules\n\nDefining good concepts is non-trivial.\nConcepts are meant to represent fundamental concepts in an application domain (hence the name \"concepts\").\nSimilarly throwing together a set of syntactic constraints to be used for the arguments for a single class or algorithm is not what concepts were designed for\nand will not give the full benefits of the mechanism.\n\nObviously, defining concepts is most useful for code that can use an implementation (e.g., C++20 or later)\nbut defining concepts is in itself a useful design technique and helps catch conceptual errors and clean up the concepts (sic!) of an implementation.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-low\"></a>T.20: Avoid \"concepts\" without meaningful semantics",
    "content": "### <a name=\"rt-low\"></a>T.20: Avoid \"concepts\" without meaningful semantics\n\n##### Reason\n\nConcepts are meant to express semantic notions, such as \"a number\", \"a range\" of elements, and \"totally ordered.\"\nSimple constraints, such as \"has a `+` operator\" and \"has a `>` operator\" cannot be meaningfully specified in isolation\nand should be used only as building blocks for meaningful concepts, rather than in user code.\n\n##### Example, bad\n\n    template<typename T>\n    // bad; insufficient\n    concept Addable = requires(T a, T b) { a + b; };\n\n    template<Addable N>\n    auto algo(const N& a, const N& b) // use two numbers\n    {\n        // ...\n        return a + b;\n    }\n\n    int x = 7;\n    int y = 9;\n    auto z = algo(x, y);   // z = 16\n\n    string xx = \"7\";\n    string yy = \"9\";\n    auto zz = algo(xx, yy);   // zz = \"79\"\n\nMaybe the concatenation was expected. More likely, it was an accident. Defining minus equivalently would give dramatically different sets of accepted types.\nThis `Addable` violates the mathematical rule that addition is supposed to be commutative: `a+b == b+a`.\n\n##### Note\n\nThe ability to specify meaningful semantics is a defining characteristic of a true concept, as opposed to a syntactic constraint.\n\n##### Example\n\n    template<typename T>\n    // The operators +, -, *, and / for a number are assumed to follow the usual mathematical rules\n    concept Number = requires(T a, T b) { a + b; a - b; a * b; a / b; };\n\n    template<Number N>\n    auto algo(const N& a, const N& b)\n    {\n        // ...\n        return a + b;\n    }\n\n    int x = 7;\n    int y = 9;\n    auto z = algo(x, y);   // z = 16\n\n    string xx = \"7\";\n    string yy = \"9\";\n    auto zz = algo(xx, yy);   // error: string is not a Number\n\n##### Note\n\nConcepts with multiple operations have far lower chance of accidentally matching a type than a single-operation concept.\n\n##### Enforcement\n\n* Flag single-operation `concepts` when used outside the definition of other `concepts`.\n* Flag uses of `enable_if` that appear to simulate single-operation `concepts`.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-complete\"></a>T.21: Require a complete set of operations for a concept",
    "content": "### <a name=\"rt-complete\"></a>T.21: Require a complete set of operations for a concept\n\n##### Reason\n\nEase of comprehension.\nImproved interoperability.\nHelps implementers and maintainers.\n\n##### Note\n\nThis is a specific variant of the general rule that [a concept must make semantic sense](#rt-low).\n\n##### Example, bad\n\n    template<typename T> concept Subtractable = requires(T a, T b) { a - b; };\n\nThis makes no semantic sense.\nYou need at least `+` to make `-` meaningful and useful.\n\nExamples of complete sets are\n\n* `Arithmetic`: `+`, `-`, `*`, `/`, `+=`, `-=`, `*=`, `/=`\n* `Comparable`: `<`, `>`, `<=`, `>=`, `==`, `!=`\n\n##### Note\n\nThis rule applies whether we use direct language support for concepts or not.\nIt is a general design rule that even applies to non-templates:\n\n    class Minimal {\n        // ...\n    };\n\n    bool operator==(const Minimal&, const Minimal&);\n    bool operator<(const Minimal&, const Minimal&);\n\n    Minimal operator+(const Minimal&, const Minimal&);\n    // no other operators\n\n    void f(const Minimal& x, const Minimal& y)\n    {\n        if (!(x == y)) { /* ... */ }    // OK\n        if (x != y) { /* ... */ }       // surprise! error\n\n        while (!(x < y)) { /* ... */ }  // OK\n        while (x >= y) { /* ... */ }    // surprise! error\n\n        x = x + y;          // OK\n        x += y;             // surprise! error\n    }\n\nThis is minimal, but surprising and constraining for users.\nIt could even be less efficient.\n\nThe rule supports the view that a concept should reflect a (mathematically) coherent set of operations.\n\n##### Example\n\n    class Convenient {\n        // ...\n    };\n\n    bool operator==(const Convenient&, const Convenient&);\n    bool operator<(const Convenient&, const Convenient&);\n    // ... and the other comparison operators ...\n\n    Convenient operator+(const Convenient&, const Convenient&);\n    // ... and the other arithmetic operators ...\n\n    void f(const Convenient& x, const Convenient& y)\n    {\n        if (!(x == y)) { /* ... */ }    // OK\n        if (x != y) { /* ... */ }       // OK\n\n        while (!(x < y)) { /* ... */ }  // OK\n        while (x >= y) { /* ... */ }    // OK\n\n        x = x + y;     // OK\n        x += y;        // OK\n    }\n\nIt can be a nuisance to define all operators, but not hard.\nIdeally, that rule should be language supported by giving you comparison operators by default.\n\n##### Enforcement\n\n* Flag classes that support \"odd\" subsets of a set of operators, e.g., `==` but not `!=` or `+` but not `-`.\n  Yes, `std::string` is \"odd\", but it's too late to change that.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-axiom\"></a>T.22: Specify axioms for concepts",
    "content": "### <a name=\"rt-axiom\"></a>T.22: Specify axioms for concepts\n\n##### Reason\n\nA meaningful/useful concept has a semantic meaning.\nExpressing these semantics in an informal, semi-formal, or formal way makes the concept comprehensible to readers and the effort to express it can catch conceptual errors.\nSpecifying semantics is a powerful design tool.\n\n##### Example\n\n    template<typename T>\n        // The operators +, -, *, and / for a number are assumed to follow the usual mathematical rules\n        // axiom(T a, T b) { a + b == b + a; a - a == 0; a * (b + c) == a * b + a * c; /*...*/ }\n        concept Number = requires(T a, T b) {\n            { a + b } -> convertible_to<T>;\n            { a - b } -> convertible_to<T>;\n            { a * b } -> convertible_to<T>;\n            { a / b } -> convertible_to<T>;\n        };\n\n##### Note\n\nThis is an axiom in the mathematical sense: something that can be assumed without proof.\nIn general, axioms are not provable, and when they are the proof is often beyond the capability of a compiler.\nAn axiom might not be general, but the template writer can assume that it holds for all inputs actually used (similar to a precondition).\n\n##### Note\n\nIn this context axioms are Boolean expressions.\nSee the [Palo Alto TR](#s-references) for examples.\nCurrently, C++ does not support axioms (even the ISO Concepts TS), so we have to make do with comments for a longish while.\nOnce language support is available, the `//` in front of the axiom can be removed\n\n##### Note\n\nThe GSL concepts have well-defined semantics; see the Palo Alto TR and the Ranges TS.\n\n##### Exception\n\nEarly versions of a new \"concept\" still under development will often just define simple sets of constraints without a well-specified semantics.\nFinding good semantics can take effort and time.\nAn incomplete set of constraints can still be very useful:\n\n    // balancer for a generic binary tree\n    template<typename Node> concept Balancer = requires(Node* p) {\n        add_fixup(p);\n        touch(p);\n        detach(p);\n    };\n\nSo a `Balancer` must supply at least these operations on a tree `Node`,\nbut we are not yet ready to specify detailed semantics because a new kind of balanced tree might require more operations\nand the precise general semantics for all nodes is hard to pin down in the early stages of design.\n\nA \"concept\" that is incomplete or without a well-specified semantics can still be useful.\nFor example, it allows for some checking during initial experimentation.\nHowever, it should not be assumed to be stable.\nEach new use case might require such an incomplete concept to be improved.\n\n##### Enforcement\n\n* Look for the word \"axiom\" in concept definition comments\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-refine\"></a>T.23: Differentiate a refined concept from its more general case by adding new use patterns.",
    "content": "### <a name=\"rt-refine\"></a>T.23: Differentiate a refined concept from its more general case by adding new use patterns.\n\n##### Reason\n\nOtherwise they cannot be distinguished automatically by the compiler.\n\n##### Example\n\n    template<typename I>\n    // Note: input_iterator is defined in <iterator>\n    concept Input_iter = requires(I iter) { ++iter; };\n\n    template<typename I>\n    // Note: forward_iterator is defined in <iterator>\n    concept Fwd_iter = Input_iter<I> && requires(I iter) { iter++; };\n\nThe compiler can determine refinement based on the sets of required operations (here, suffix `++`).\nThis decreases the burden on implementers of these types since\nthey do not need any special declarations to \"hook into the concept\".\nIf two concepts have exactly the same requirements, they are logically equivalent (there is no refinement).\n\n##### Enforcement\n\n* Flag a concept that has exactly the same requirements as another already-seen concept (neither is more refined).\nTo disambiguate them, see [T.24](#rt-tag).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-tag\"></a>T.24: Use tag classes or traits to differentiate concepts that differ only in semantics.",
    "content": "### <a name=\"rt-tag\"></a>T.24: Use tag classes or traits to differentiate concepts that differ only in semantics.\n\n##### Reason\n\nTwo concepts requiring the same syntax but having different semantics lead to ambiguity unless the programmer differentiates them.\n\n##### Example\n\n    template<typename I>    // iterator providing random access\n    // Note: random_access_iterator is defined in <iterator>\n    concept RA_iter = ...;\n\n    template<typename I>    // iterator providing random access to contiguous data\n    // Note: contiguous_iterator is defined in <iterator>\n    concept Contiguous_iter =\n        RA_iter<I> && is_contiguous_v<I>;  // using is_contiguous trait\n\nThe programmer (in a library) must define `is_contiguous` (a trait) appropriately.\n\nWrapping a tag class into a concept leads to a simpler expression of this idea:\n\n    template<typename I> concept Contiguous = is_contiguous_v<I>;\n\n    template<typename I>\n    concept Contiguous_iter = RA_iter<I> && Contiguous<I>;\n\nThe programmer (in a library) must define `is_contiguous` (a trait) appropriately.\n\n##### Note\n\nTraits can be trait classes or type traits.\nThese can be user-defined or standard-library ones.\nPrefer the standard-library ones.\n\n##### Enforcement\n\n* The compiler flags ambiguous use of identical concepts.\n* Flag the definition of identical concepts.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-not\"></a>T.25: Avoid complementary constraints",
    "content": "### <a name=\"rt-not\"></a>T.25: Avoid complementary constraints\n\n##### Reason\n\nClarity. Maintainability.\nFunctions with complementary requirements expressed using negation are brittle.\n\n##### Example\n\nInitially, people will try to define functions with complementary requirements:\n\n    template<typename T>\n        requires !C<T>    // bad\n    void f();\n\n    template<typename T>\n        requires C<T>\n    void f();\n\nThis is better:\n\n    template<typename T>   // general template\n        void f();\n\n    template<typename T>   // specialization by concept\n        requires C<T>\n    void f();\n\nThe compiler will choose the unconstrained template only when `C<T>` is\nunsatisfied. If you do not want to (or cannot) define an unconstrained\nversion of `f()`, then delete it.\n\n    template<typename T>\n    void f() = delete;\n\nThe compiler will select the overload, or emit an appropriate error.\n\n##### Note\n\nComplementary constraints are unfortunately common in `enable_if` code:\n\n    template<typename T>\n    enable_if<!C<T>, void>   // bad\n    f();\n\n    template<typename T>\n    enable_if<C<T>, void>\n    f();\n\n\n##### Note\n\nComplementary requirements on one requirement are sometimes (wrongly) considered manageable.\nHowever, for two or more requirements the number of definitions needs can go up exponentially (2,4,8,16,...):\n\n    C1<T> && C2<T>\n    !C1<T> && C2<T>\n    C1<T> && !C2<T>\n    !C1<T> && !C2<T>\n\nNow the opportunities for errors multiply.\n\n##### Enforcement\n\n* Flag pairs of functions with `C<T>` and `!C<T>` constraints\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-use\"></a>T.26: Prefer to define concepts in terms of use-patterns rather than simple syntax",
    "content": "### <a name=\"rt-use\"></a>T.26: Prefer to define concepts in terms of use-patterns rather than simple syntax\n\n##### Reason\n\nThe definition is more readable and corresponds directly to what a user has to write.\nConversions are taken into account. You don't have to remember the names of all the type traits.\n\n##### Example\n\nYou might be tempted to define a concept `Equality` like this:\n\n    template<typename T> concept Equality = has_equal<T> && has_not_equal<T>;\n\nObviously, it would be better and easier just to use the standard `equality_comparable`,\nbut - just as an example - if you had to define such a concept, prefer:\n\n    template<typename T> concept Equality = requires(T a, T b) {\n        { a == b } -> std::convertible_to<bool>;\n        { a != b } -> std::convertible_to<bool>;\n        // axiom { !(a == b) == (a != b) }\n        // axiom { a = b; => a == b }  // => means \"implies\"\n    };\n\nas opposed to defining two meaningless concepts `has_equal` and `has_not_equal` just as helpers in the definition of `Equality`.\nBy \"meaningless\" we mean that we cannot specify the semantics of `has_equal` in isolation.\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-temp-interface\"></a>Template interfaces",
    "content": "## <a name=\"ss-temp-interface\"></a>Template interfaces\n\nOver the years, programming with templates has suffered from a weak distinction between the interface of a template\nand its implementation.\nBefore concepts, that distinction had no direct language support.\nHowever, the interface to a template is a critical concept - a contract between a user and an implementer - and should be carefully designed.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-fo\"></a>T.40: Use function objects to pass operations to algorithms",
    "content": "### <a name=\"rt-fo\"></a>T.40: Use function objects to pass operations to algorithms\n\n##### Reason\n\nFunction objects can carry more information through an interface than a \"plain\" pointer to function.\nIn general, passing function objects gives better performance than passing pointers to functions.\n\n##### Example\n\n    bool greater(double x, double y) { return x > y; }\n    sort(v, greater);                                    // pointer to function: potentially slow\n    sort(v, [](double x, double y) { return x > y; });   // function object\n    sort(v, std::greater{});                             // function object\n\n    bool greater_than_7(double x) { return x > 7; }\n    auto x = find_if(v, greater_than_7);                 // pointer to function: inflexible\n    auto y = find_if(v, [](double x) { return x > 7; }); // function object: carries the needed data\n    auto z = find_if(v, Greater_than<double>(7));        // function object: carries the needed data\n\nYou can, of course, generalize those functions using `auto` or concepts. For example:\n\n    auto y1 = find_if(v, [](totally_ordered auto x) { return x > 7; }); // require an ordered type\n    auto z1 = find_if(v, [](auto x) { return x > 7; });                 // hope that the type has a >\n\n##### Note\n\nLambdas generate function objects.\n\n##### Note\n\nThe performance argument depends on compiler and optimizer technology.\n\n##### Enforcement\n\n* Flag pointer to function template arguments.\n* Flag pointers to functions passed as arguments to a template (risk of false positives).\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-essential\"></a>T.41: Require only essential properties in a template's concepts",
    "content": "### <a name=\"rt-essential\"></a>T.41: Require only essential properties in a template's concepts\n\n##### Reason\n\nKeep interfaces simple and stable.\n\n##### Example\n\nConsider, a `sort` instrumented with (oversimplified) simple debug support:\n\n    void sort(sortable auto& s)  // sort sequence s\n    {\n        if (debug) cerr << \"enter sort( \" << s <<  \")\\n\";\n        // ...\n        if (debug) cerr << \"exit sort( \" << s <<  \")\\n\";\n    }\n\nShould this be rewritten to:\n\n    template<sortable S>\n        requires Streamable<S>\n    void sort(S& s)  // sort sequence s\n    {\n        if (debug) cerr << \"enter sort( \" << s <<  \")\\n\";\n        // ...\n        if (debug) cerr << \"exit sort( \" << s <<  \")\\n\";\n    }\n\nAfter all, there is nothing in `sortable` that requires `iostream` support.\nOn the other hand, there is nothing in the fundamental idea of sorting that says anything about debugging.\n\n##### Note\n\nIf we require every operation used to be listed among the requirements, the interface becomes unstable:\nEvery time we change the debug facilities, the usage data gathering, testing support, error reporting, etc.,\nthe definition of the template would need change and every use of the template would have to be recompiled.\nThis is cumbersome, and in some environments infeasible.\n\nConversely, if we use an operation in the implementation that is not guaranteed by concept checking,\nwe might get a late compile-time error.\n\nBy not using concept checking for properties of a template argument that is not considered essential,\nwe delay checking until instantiation time.\nWe consider this a worthwhile tradeoff.\n\nNote that using non-local, non-dependent names (such as `debug` and `cerr`) also introduces context dependencies that might lead to \"mysterious\" errors.\n\n##### Note\n\nIt can be hard to decide which properties of a type are essential and which are not.\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-alias\"></a>T.42: Use template aliases to simplify notation and hide implementation details",
    "content": "### <a name=\"rt-alias\"></a>T.42: Use template aliases to simplify notation and hide implementation details\n\n##### Reason\n\nImproved readability.\nImplementation hiding.\nNote that template aliases replace many uses of traits to compute a type.\nThey can also be used to wrap a trait.\n\n##### Example\n\n    template<typename T, size_t N>\n    class Matrix {\n        // ...\n        using Iterator = typename std::vector<T>::iterator;\n        // ...\n    };\n\nThis saves the user of `Matrix` from having to know that its elements are stored in a `vector` and also saves the user from repeatedly typing `typename std::vector<T>::`.\n\n##### Example\n\n    template<typename T>\n    void user(T& c)\n    {\n        // ...\n        typename container_traits<T>::value_type x; // bad, verbose\n        // ...\n    }\n\n    template<typename T>\n    using Value_type = typename container_traits<T>::value_type;\n\n\nThis saves the user of `Value_type` from having to know the technique used to implement `value_type`s.\n\n    template<typename T>\n    void user2(T& c)\n    {\n        // ...\n        Value_type<T> x;\n        // ...\n    }\n\n##### Note\n\nA simple, common use could be expressed: \"Wrap traits!\"\n\n##### Enforcement\n\n* Flag use of `typename` as a disambiguator outside `using` declarations.\n* ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-using\"></a>T.43: Prefer `using` over `typedef` for defining aliases",
    "content": "### <a name=\"rt-using\"></a>T.43: Prefer `using` over `typedef` for defining aliases\n\n##### Reason\n\nImproved readability: With `using`, the new name comes first rather than being embedded somewhere in a declaration.\nGenerality: `using` can be used for template aliases, whereas `typedef`s can't easily be templates.\nUniformity: `using` is syntactically similar to `auto`.\n\n##### Example\n\n    typedef int (*PFI)(int);   // OK, but convoluted\n\n    using PFI2 = int (*)(int);   // OK, preferred\n\n    template<typename T>\n    typedef int (*PFT)(T);      // error\n\n    template<typename T>\n    using PFT2 = int (*)(T);   // OK\n\n##### Enforcement\n\n* Flag uses of `typedef`. This will give a lot of \"hits\" :-(\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-deduce\"></a>T.44: Use function templates to deduce class template argument types (where feasible)",
    "content": "### <a name=\"rt-deduce\"></a>T.44: Use function templates to deduce class template argument types (where feasible)\n\n##### Reason\n\nWriting the template argument types explicitly can be tedious and unnecessarily verbose.\n\n##### Example\n\n    tuple<int, string, double> t1 = {1, \"Hamlet\", 3.14};   // explicit type\n    auto t2 = make_tuple(1, \"Ophelia\"s, 3.14);         // better; deduced type\n\nNote the use of the `s` suffix to ensure that the string is a `std::string`, rather than a C-style string.\n\n##### Note\n\nSince you can trivially write a `make_T` function, so could the compiler. Thus, `make_T` functions might become redundant in the future.\n\n##### Exception\n\nSometimes there isn't a good way of getting the template arguments deduced and sometimes, you want to specify the arguments explicitly:\n\n    vector<double> v = { 1, 2, 3, 7.9, 15.99 };\n    list<Record*> lst;\n\n##### Note\n\nNote that C++17 will make this rule redundant by allowing the template arguments to be deduced directly from constructor arguments:\n[Template parameter deduction for constructors (Rev. 3)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r1.html).\nFor example:\n\n    tuple t1 = {1, \"Hamlet\"s, 3.14}; // deduced: tuple<int, string, double>\n\n##### Enforcement\n\nFlag uses where an explicitly specialized type exactly matches the types of the arguments used.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-regular\"></a>T.46: Require template arguments to be at least semiregular",
    "content": "### <a name=\"rt-regular\"></a>T.46: Require template arguments to be at least semiregular\n\n##### Reason\n\nReadability.\nPreventing surprises and errors.\nMost uses support that anyway.\n\n##### Example\n\n    class X {\n    public:\n        explicit X(int);\n        X(const X&);            // copy\n        X operator=(const X&);\n        X(X&&) noexcept;        // move\n        X& operator=(X&&) noexcept;\n        ~X();\n        // ... no more constructors ...\n    };\n\n    X x {1};              // fine\n    X y = x;              // fine\n    std::vector<X> v(10); // error: no default constructor\n\n##### Note\n\nSemiregular requires default constructible.\n\n##### Enforcement\n\n* Flag types used as template arguments that are not at least semiregular.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-visible\"></a>T.47: Avoid highly visible unconstrained templates with common names",
    "content": "### <a name=\"rt-visible\"></a>T.47: Avoid highly visible unconstrained templates with common names\n\n##### Reason\n\n An unconstrained template argument is a perfect match for anything so such a template can be preferred over more specific types that require minor conversions.\n This is particularly annoying/dangerous when ADL is used.\n Common names make this problem more likely.\n\n##### Example\n\n    namespace Bad {\n        struct S { int m; };\n        template<typename T1, typename T2>\n        bool operator==(T1, T2) { cout << \"Bad\\n\"; return true; }\n    }\n\n    namespace T0 {\n        bool operator==(int, Bad::S) { cout << \"T0\\n\"; return true; }  // compare to int\n\n        void test()\n        {\n            Bad::S bad{ 1 };\n            vector<int> v(10);\n            bool b = 1 == bad;\n            bool b2 = v.size() == bad;\n        }\n    }\n\nThis prints `T0` and `Bad`.\n\nNow the `==` in `Bad` was designed to cause trouble, but would you have spotted the problem in real code?\nThe problem is that `v.size()` returns an `unsigned` integer so that a conversion is needed to call the local `==`;\nthe `==` in `Bad` requires no conversions.\nRealistic types, such as the standard-library iterators can be made to exhibit similar anti-social tendencies.\n\n##### Note\n\nIf an unconstrained template is defined in the same namespace as a type,\nthat unconstrained template can be found by ADL (as happened in the example).\nThat is, it is highly visible.\n\n##### Note\n\nThis rule should not be necessary, but the committee cannot agree to exclude unconstrained templates from ADL.\n\nUnfortunately this will get many false positives; the standard library violates this widely, by putting many unconstrained templates and types into the single namespace `std`.\n\n\n##### Enforcement\n\nFlag templates defined in a namespace where concrete types are also defined (maybe not feasible until we have concepts).\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-concept-def\"></a>T.48: If your compiler does not support concepts, fake them with `enable_if`",
    "content": "### <a name=\"rt-concept-def\"></a>T.48: If your compiler does not support concepts, fake them with `enable_if`\n\n##### Reason\n\nBecause that's the best we can do without direct concept support.\n`enable_if` can be used to conditionally define functions and to select among a set of functions.\n\n##### Example\n\n    template<typename T>\n    enable_if_t<is_integral_v<T>>\n    f(T v)\n    {\n        // ...\n    }\n\n    // Equivalent to:\n    template<Integral T>\n    void f(T v)\n    {\n        // ...\n    }\n\n##### Note\n\nBeware of [complementary constraints](#rt-not).\nFaking concept overloading using `enable_if` sometimes forces us to use that error-prone design technique.\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-erasure\"></a>T.49: Where possible, avoid type-erasure",
    "content": "### <a name=\"rt-erasure\"></a>T.49: Where possible, avoid type-erasure\n\n##### Reason\n\nType erasure incurs an extra level of indirection by hiding type information behind a separate compilation boundary.\n\n##### Example\n\n    ???\n\n**Exceptions**: Type erasure is sometimes appropriate, such as for `std::function`.\n\n##### Enforcement\n\n???\n\n\n##### Note\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-temp-def\"></a>T.def: Template definitions",
    "content": "## <a name=\"ss-temp-def\"></a>T.def: Template definitions\n\nA template definition (class or function) can contain arbitrary code, so only a comprehensive review of C++ programming techniques would cover this topic.\nHowever, this section focuses on what is specific to template implementation.\nIn particular, it focuses on a template definition's dependence on its context.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-depend\"></a>T.60: Minimize a template's context dependencies",
    "content": "### <a name=\"rt-depend\"></a>T.60: Minimize a template's context dependencies\n\n##### Reason\n\nEases understanding.\nMinimizes errors from unexpected dependencies.\nEases tool creation.\n\n##### Example\n\n    template<typename C>\n    void sort(C& c)\n    {\n        std::sort(begin(c), end(c)); // necessary and useful dependency\n    }\n\n    template<typename Iter>\n    Iter algo(Iter first, Iter last)\n    {\n        for (; first != last; ++first) {\n            auto x = sqrt(*first); // potentially surprising dependency: which sqrt()?\n            helper(first, x);      // potentially surprising dependency:\n                                   // helper is chosen based on first and x\n            TT var = 7;            // potentially surprising dependency: which TT?\n        }\n    }\n\n##### Note\n\nTemplates typically appear in header files so their context dependencies are more vulnerable to `#include` order dependencies than functions in `.cpp` files.\n\n##### Note\n\nHaving a template operate only on its arguments would be one way of reducing the number of dependencies to a minimum, but that would generally be unmanageable.\nFor example, algorithms usually use other algorithms and invoke operations that do not exclusively operate on arguments.\nAnd don't get us started on macros!\n\n**See also**: [T.69](#rt-customization)\n\n##### Enforcement\n\n??? Tricky\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-scary\"></a>T.61: Do not over-parameterize members (SCARY)",
    "content": "### <a name=\"rt-scary\"></a>T.61: Do not over-parameterize members (SCARY)\n\n##### Reason\n\nA member that does not depend on a template parameter cannot be used except for a specific template argument.\nThis limits use and typically increases code size.\n\n##### Example, bad\n\n    template<typename T, typename A = std::allocator<T>>\n        // requires Regular<T> && Allocator<A>\n    class List {\n    public:\n        struct Link {   // does not depend on A\n            T elem;\n            Link* pre;\n            Link* suc;\n        };\n\n        using iterator = Link*;\n\n        iterator first() const { return head; }\n\n        // ...\n    private:\n        Link* head;\n    };\n\n    List<int> lst1;\n    List<int, My_allocator> lst2;\n\nThis looks innocent enough, but now `Link` formally depends on the allocator (even though it doesn't use the allocator). This forces redundant instantiations that can be surprisingly costly in some real-world scenarios.\nTypically, the solution is to make what would have been a nested class non-local, with its own minimal set of template parameters.\n\n    template<typename T>\n    struct Link {\n        T elem;\n        Link* pre;\n        Link* suc;\n    };\n\n    template<typename T, typename A = std::allocator<T>>\n        // requires Regular<T> && Allocator<A>\n    class List2 {\n    public:\n        using iterator = Link<T>*;\n\n        iterator first() const { return head; }\n\n        // ...\n    private:\n        Link<T>* head;\n    };\n\n    List2<int> lst1;\n    List2<int, My_allocator> lst2;\n\nSome people found the idea that the `Link` no longer was hidden inside the list scary, so we named the technique\n[SCARY](https://www.open-std.org/jtc1/sc22/WG21/docs/papers/2009/n2911.pdf). From that academic paper:\n\"The acronym SCARY describes assignments and initializations that are Seemingly erroneous (appearing Constrained by conflicting generic parameters), but Actually work with the Right implementation (unconstrained bY the conflict due to minimized dependencies).\"\n\n##### Note\n\nThis also applies to lambdas that don't depend on all of the template parameters.\n\n##### Enforcement\n\n* Flag member types that do not depend on every template parameter\n* Flag member functions that do not depend on every template parameter\n* Flag lambdas or variable templates that do not depend on every template parameter\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-nondependent\"></a>T.62: Place non-dependent class template members in a non-templated base class",
    "content": "### <a name=\"rt-nondependent\"></a>T.62: Place non-dependent class template members in a non-templated base class\n\n##### Reason\n\n Allow the base class members to be used without specifying template arguments and without template instantiation.\n\n##### Example\n\n    template<typename T>\n    class Foo {\n    public:\n        enum { v1, v2 };\n        // ...\n    };\n\n???\n\n    struct Foo_base {\n        enum { v1, v2 };\n        // ...\n    };\n\n    template<typename T>\n    class Foo : public Foo_base {\n    public:\n        // ...\n    };\n\n##### Note\n\nA more general version of this rule would be\n\"If a class template member depends on only N template parameters out of M, place it in a base class with only N parameters.\"\nFor N == 1, we have a choice of a base class of a class in the surrounding scope as in [T.61](#rt-scary).\n\n??? What about constants? class statics?\n\n##### Enforcement\n\n* Flag ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-specialization\"></a>T.64: Use specialization to provide alternative implementations of class templates",
    "content": "### <a name=\"rt-specialization\"></a>T.64: Use specialization to provide alternative implementations of class templates\n\n##### Reason\n\nA template defines a general interface.\nSpecialization offers a powerful mechanism for providing alternative implementations of that interface.\n\n##### Example\n\n    ??? string specialization (==)\n\n    ??? representation specialization ?\n\n##### Note\n\n???\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-tag-dispatch\"></a>T.65: Use tag dispatch to provide alternative implementations of a function",
    "content": "### <a name=\"rt-tag-dispatch\"></a>T.65: Use tag dispatch to provide alternative implementations of a function\n\n##### Reason\n\n* A template defines a general interface.\n* Tag dispatch allows us to select implementations based on specific properties of an argument type.\n* Performance.\n\n##### Example\n\nThis is a simplified version of `std::copy` (ignoring the possibility of non-contiguous sequences)\n\n    struct trivially_copyable_tag {};\n    struct non_trivially_copyable_tag {};\n\n    // T is not trivially copyable\n    template<class T> struct copy_trait { using tag = non_trivially_copyable_tag; };\n    // int is trivially copyable\n    template<> struct copy_trait<int> { using tag = trivially_copyable_tag; };\n\n    template<class Iter>\n    Out copy_helper(Iter first, Iter last, Iter out, trivially_copyable_tag)\n    {\n        // use memmove\n    }\n\n    template<class Iter>\n    Out copy_helper(Iter first, Iter last, Iter out, non_trivially_copyable_tag)\n    {\n        // use loop calling copy constructors\n    }\n\n    template<class Iter>\n    Out copy(Iter first, Iter last, Iter out)\n    {\n        using tag_type = typename copy_trait<std::iter_value_t<Iter>>::tag;\n        return copy_helper(first, last, out, tag_type{})\n    }\n\n    void use(vector<int>& vi, vector<int>& vi2, vector<string>& vs, vector<string>& vs2)\n    {\n        copy(vi.begin(), vi.end(), vi2.begin()); // uses memmove\n        copy(vs.begin(), vs.end(), vs2.begin()); // uses a loop calling copy constructors\n    }\n\nThis is a general and powerful technique for compile-time algorithm selection.\n\n##### Note\n\nWith C++20 constraints, such alternatives can be distinguished directly:\n\n    template<class Iter>\n        requires std::is_trivially_copyable_v<std::iter_value_t<Iter>>\n    Out copy_helper(In, first, In last, Out out)\n    {\n        // use memmove\n    }\n\n    template<class Iter>\n    Out copy_helper(In, first, In last, Out out)\n    {\n        // use loop calling copy constructors\n    }\n\n##### Enforcement\n\n???\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-specialization2\"></a>T.67: Use specialization to provide alternative implementations for irregular types",
    "content": "### <a name=\"rt-specialization2\"></a>T.67: Use specialization to provide alternative implementations for irregular types\n\n##### Reason\n\n ???\n\n##### Example\n\n    ???\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-cast\"></a>T.68: Use `{}` rather than `()` within templates to avoid ambiguities",
    "content": "### <a name=\"rt-cast\"></a>T.68: Use `{}` rather than `()` within templates to avoid ambiguities\n\n##### Reason\n\n`()` is vulnerable to grammar ambiguities.\n\n##### Example\n\n    template<typename T, typename U>\n    void f(T t, U u)\n    {\n        T v1(T(u));    // mistake: oops, v1 is a function, not a variable\n        T v2{u};       // clear:   obviously a variable\n        auto x = T(u); // unclear: construction or cast?\n    }\n\n    f(1, \"asdf\"); // bad: cast from const char* to int\n\n##### Enforcement\n\n* flag `()` initializers\n* flag function-style casts\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-customization\"></a>T.69: Inside a template, don't make an unqualified non-member function call unless you intend it to be a customization point",
    "content": "### <a name=\"rt-customization\"></a>T.69: Inside a template, don't make an unqualified non-member function call unless you intend it to be a customization point\n\n##### Reason\n\n* Provide only intended flexibility.\n* Avoid vulnerability to accidental environmental changes.\n\n##### Example\n\nThere are three major ways to let calling code customize a template.\n\n    template<class T>\n        // Call a member function\n    void test1(T t)\n    {\n        t.f();    // require T to provide f()\n    }\n\n    template<class T>\n    void test2(T t)\n        // Call a non-member function without qualification\n    {\n        f(t);     // require f(/*T*/) be available in caller's scope or in T's namespace\n    }\n\n    template<class T>\n    void test3(T t)\n        // Invoke a \"trait\"\n    {\n        test_traits<T>::f(t); // require customizing test_traits<>\n                              // to get non-default functions/types\n    }\n\nA trait is usually a type alias to compute a type,\na `constexpr` function to compute a value,\nor a traditional traits template to be specialized on the user's type.\n\n##### Note\n\nIf you intend to call your own helper function `helper(t)` with a value `t` that depends on a template type parameter,\nput it in a `::detail` namespace and qualify the call as `detail::helper(t);`.\nAn unqualified call becomes a customization point where any function `helper` in the namespace of `t`'s type can be invoked;\nthis can cause problems like [unintentionally invoking unconstrained function templates](#rt-visible).\n\n\n##### Enforcement\n\n* In a template, flag an unqualified call to a non-member function that passes a variable of dependent type when there is a non-member function of the same name in the template's namespace.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-temp-hier\"></a>T.temp-hier: Template and hierarchy rules:",
    "content": "## <a name=\"ss-temp-hier\"></a>T.temp-hier: Template and hierarchy rules:\n\nTemplates are the backbone of C++'s support for generic programming and class hierarchies the backbone of its support\nfor object-oriented programming.\nThe two language mechanisms can be used effectively in combination, but a few design pitfalls must be avoided.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-hier\"></a>T.80: Do not naively templatize a class hierarchy",
    "content": "### <a name=\"rt-hier\"></a>T.80: Do not naively templatize a class hierarchy\n\n##### Reason\n\nTemplating a class hierarchy that has many functions, especially many virtual functions, can lead to code bloat.\n\n##### Example, bad\n\n    template<typename T>\n    struct Container {         // an interface\n        virtual T* get(int i);\n        virtual T* first();\n        virtual T* next();\n        virtual void sort();\n    };\n\n    template<typename T>\n    class Vector : public Container<T> {\n    public:\n        // ...\n    };\n\n    Vector<int> vi;\n    Vector<string> vs;\n\nIt is probably a bad idea to define a `sort` as a member function of a container, but it is not unheard of and it makes a good example of what not to do.\n\nGiven this, the compiler cannot know if `vector<int>::sort()` is called, so it must generate code for it.\nSimilar for `vector<string>::sort()`.\nUnless those two functions are called that's code bloat.\nImagine what this would do to a class hierarchy with dozens of member functions and dozens of derived classes with many instantiations.\n\n##### Note\n\nIn many cases you can provide a stable interface by not parameterizing a base;\nsee [\"stable base\"](#rt-abi) and [OO and GP](#rt-generic-oo)\n\n##### Enforcement\n\n* Flag virtual functions that depend on a template argument. ??? False positives\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-array\"></a>T.81: Do not mix hierarchies and arrays",
    "content": "### <a name=\"rt-array\"></a>T.81: Do not mix hierarchies and arrays\n\n##### Reason\n\nAn array of derived classes can implicitly \"decay\" to a pointer to a base class with potential disastrous results.\n\n##### Example\n\nAssume that `Apple` and `Pear` are two kinds of `Fruit`s.\n\n    void maul(Fruit* p)\n    {\n        *p = Pear{};     // put a Pear into *p\n        p[1] = Pear{};   // put a Pear into p[1]\n    }\n\n    Apple aa [] = { an_apple, another_apple };   // aa contains Apples (obviously!)\n\n    maul(aa);\n    Apple& a0 = &aa[0];   // a Pear?\n    Apple& a1 = &aa[1];   // a Pear?\n\nProbably, `aa[0]` will be a `Pear` (without the use of a cast!).\nIf `sizeof(Apple) != sizeof(Pear)` the access to `aa[1]` will not be aligned to the proper start of an object in the array.\nWe have a type violation and possibly (probably) a memory corruption.\nNever write such code.\n\nNote that `maul()` violates the a [`T*` points to an individual object rule](#rf-ptr).\n\n**Alternative**: Use a proper (templatized) container:\n\n    void maul2(Fruit* p)\n    {\n        *p = Pear{};   // put a Pear into *p\n    }\n\n    vector<Apple> va = { an_apple, another_apple };   // va contains Apples (obviously!)\n\n    maul2(va);       // error: cannot convert a vector<Apple> to a Fruit*\n    maul2(&va[0]);   // you asked for it\n\n    Apple& a0 = &va[0];   // a Pear?\n\nNote that the assignment in `maul2()` violated the [no-slicing rule](#res-slice).\n\n##### Enforcement\n\n* Detect this horror!\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-linear\"></a>T.82: Linearize a hierarchy when virtual functions are undesirable",
    "content": "### <a name=\"rt-linear\"></a>T.82: Linearize a hierarchy when virtual functions are undesirable\n\n##### Reason\n\n ???\n\n##### Example\n\n    ???\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-virtual\"></a>T.83: Do not declare a member function template virtual",
    "content": "### <a name=\"rt-virtual\"></a>T.83: Do not declare a member function template virtual\n\n##### Reason\n\nC++ does not support that.\nIf it did, vtbls could not be generated until link time.\nAnd in general, implementations must deal with dynamic linking.\n\n##### Example, don't\n\n    class Shape {\n        // ...\n        template<class T>\n        virtual bool intersect(T* p);   // error: template cannot be virtual\n    };\n\n##### Note\n\nWe need a rule because people keep asking about this\n\n##### Alternative\n\nDouble dispatch, visitors, calculate which function to call\n\n##### Enforcement\n\nThe compiler handles that.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-abi\"></a>T.84: Use a non-template core implementation to provide an ABI-stable interface",
    "content": "### <a name=\"rt-abi\"></a>T.84: Use a non-template core implementation to provide an ABI-stable interface\n\n##### Reason\n\nImprove stability of code.\nAvoid code bloat.\n\n##### Example\n\nIt could be a base class:\n\n    struct Link_base {   // stable\n        Link_base* suc;\n        Link_base* pre;\n    };\n\n    template<typename T>   // templated wrapper to add type safety\n    struct Link : Link_base {\n        T val;\n    };\n\n    struct List_base {\n        Link_base* first;   // first element (if any)\n        int sz;             // number of elements\n        void add_front(Link_base* p);\n        // ...\n    };\n\n    template<typename T>\n    class List : List_base {\n    public:\n        void put_front(const T& e) { add_front(new Link<T>{e}); }   // implicit cast to Link_base\n        T& front() { return static_cast<Link<T>*>(first)->val; }   // explicit cast back to Link<T>\n        // ...\n    };\n\n    List<int> li;\n    List<string> ls;\n\nNow there is only one copy of the operations linking and unlinking elements of a `List`.\nThe `Link` and `List` classes do nothing but type manipulation.\n\nInstead of using a separate \"base\" type, another common technique is to specialize for `void` or `void*` and have the general template for `T` be just the safely-encapsulated casts to and from the core `void` implementation.\n\n**Alternative**: Use a [Pimpl](#ri-pimpl) implementation.\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-variadic\"></a>T.var: Variadic template rules",
    "content": "## <a name=\"ss-variadic\"></a>T.var: Variadic template rules\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-variadic\"></a>T.100: Use variadic templates when you need a function that takes a variable number of arguments of a variety of types",
    "content": "### <a name=\"rt-variadic\"></a>T.100: Use variadic templates when you need a function that takes a variable number of arguments of a variety of types\n\n##### Reason\n\nVariadic templates is the most general mechanism for that, and is both efficient and type-safe. Don't use C varargs.\n\n##### Example\n\n    ??? printf\n\n##### Enforcement\n\n* Flag uses of `va_arg` in user code.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-variadic-pass\"></a>T.101: ??? How to pass arguments to a variadic template ???",
    "content": "### <a name=\"rt-variadic-pass\"></a>T.101: ??? How to pass arguments to a variadic template ???\n\n##### Reason\n\n ???\n\n##### Example\n\n    ??? beware of move-only and reference arguments\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-variadic-process\"></a>T.102: How to process arguments to a variadic template",
    "content": "### <a name=\"rt-variadic-process\"></a>T.102: How to process arguments to a variadic template\n\n##### Reason\n\n ???\n\n##### Example\n\n    ??? forwarding, type checking, references\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-variadic-not\"></a>T.103: Don't use variadic templates for homogeneous argument lists",
    "content": "### <a name=\"rt-variadic-not\"></a>T.103: Don't use variadic templates for homogeneous argument lists\n\n##### Reason\n\nThere are more precise ways of specifying a homogeneous sequence, such as an `initializer_list`.\n\n##### Example\n\n    ???\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-meta\"></a>T.meta: Template metaprogramming (TMP)",
    "content": "## <a name=\"ss-meta\"></a>T.meta: Template metaprogramming (TMP)\n\nTemplates provide a general mechanism for compile-time programming.\n\nMetaprogramming is programming where at least one input or one result is a type.\nTemplates offer Turing-complete (modulo memory capacity) duck typing at compile time.\nThe syntax and techniques needed are pretty horrendous.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-metameta\"></a>T.120: Use template metaprogramming only when you really need to",
    "content": "### <a name=\"rt-metameta\"></a>T.120: Use template metaprogramming only when you really need to\n\n##### Reason\n\nTemplate metaprogramming is hard to get right, slows down compilation, and is often very hard to maintain.\nHowever, there are real-world examples where template metaprogramming provides better performance than any alternative short of expert-level assembly code.\nAlso, there are real-world examples where template metaprogramming expresses the fundamental ideas better than run-time code.\nFor example, if you really need AST manipulation at compile time (e.g., for optional matrix operation folding) there might be no other way in C++.\n\n##### Example, bad\n\n    ???\n\n##### Example, bad\n\n    enable_if\n\nInstead, use concepts. But see [How to emulate concepts if you don't have language support](#rt-emulate).\n\n##### Example\n\n    ??? good\n\n**Alternative**: If the result is a value, rather than a type, use a [`constexpr` function](#rt-fct).\n\n##### Note\n\nIf you feel the need to hide your template metaprogramming in macros, you have probably gone too far.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-emulate\"></a>T.121: Use template metaprogramming primarily to emulate concepts",
    "content": "### <a name=\"rt-emulate\"></a>T.121: Use template metaprogramming primarily to emulate concepts\n\n##### Reason\n\nWhere C++20 is not available, we need to emulate them using TMP.\nUse cases that require concepts (e.g. overloading based on concepts) are among the most common (and simple) uses of TMP.\n\n##### Example\n\n    template<typename Iter>\n        /*requires*/ enable_if<random_access_iterator<Iter>, void>\n    advance(Iter p, int n) { p += n; }\n\n    template<typename Iter>\n        /*requires*/ enable_if<forward_iterator<Iter>, void>\n    advance(Iter p, int n) { assert(n >= 0); while (n--) ++p;}\n\n##### Note\n\nSuch code is much simpler using concepts:\n\n    void advance(random_access_iterator auto p, int n) { p += n; }\n\n    void advance(forward_iterator auto p, int n) { assert(n >= 0); while (n--) ++p;}\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-tmp\"></a>T.122: Use templates (usually template aliases) to compute types at compile time",
    "content": "### <a name=\"rt-tmp\"></a>T.122: Use templates (usually template aliases) to compute types at compile time\n\n##### Reason\n\nTemplate metaprogramming is the only directly supported and half-way principled way of generating types at compile time.\n\n##### Note\n\n\"Traits\" techniques are mostly replaced by template aliases to compute types and `constexpr` functions to compute values.\n\n##### Example\n\n    ??? big object / small object optimization\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-fct\"></a>T.123: Use `constexpr` functions to compute values at compile time",
    "content": "### <a name=\"rt-fct\"></a>T.123: Use `constexpr` functions to compute values at compile time\n\n##### Reason\n\nA function is the most obvious and conventional way of expressing the computation of a value.\nOften a `constexpr` function implies less compile-time overhead than alternatives.\n\n##### Note\n\n\"Traits\" techniques are mostly replaced by template aliases to compute types and `constexpr` functions to compute values.\n\n##### Example\n\n    template<typename T>\n        // requires Number<T>\n    constexpr T pow(T v, int n)   // power/exponential\n    {\n        T res = 1;\n        while (n--) res *= v;\n        return res;\n    }\n\n    constexpr auto f7 = pow(pi, 7);\n\n##### Enforcement\n\n* Flag template metaprograms yielding a value. These should be replaced with `constexpr` functions.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-std-tmp\"></a>T.124: Prefer to use standard-library TMP facilities",
    "content": "### <a name=\"rt-std-tmp\"></a>T.124: Prefer to use standard-library TMP facilities\n\n##### Reason\n\nFacilities defined in the standard, such as `conditional`, `enable_if`, and `tuple`, are portable and can be assumed to be known.\n\n##### Example\n\n    ???\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-lib\"></a>T.125: If you need to go beyond the standard-library TMP facilities, use an existing library",
    "content": "### <a name=\"rt-lib\"></a>T.125: If you need to go beyond the standard-library TMP facilities, use an existing library\n\n##### Reason\n\nGetting advanced TMP facilities is not easy and using a library makes you part of a (hopefully supportive) community.\nWrite your own \"advanced TMP support\" only if you really have to.\n\n##### Example\n\n    ???\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-temp-other\"></a>Other template rules",
    "content": "## <a name=\"ss-temp-other\"></a>Other template rules\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-name\"></a>T.140: If an operation can be reused, give it a name",
    "content": "### <a name=\"rt-name\"></a>T.140: If an operation can be reused, give it a name\n\nSee [F.10](#rf-name)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-lambda\"></a>T.141: Use an unnamed lambda if you need a simple function object in one place only",
    "content": "### <a name=\"rt-lambda\"></a>T.141: Use an unnamed lambda if you need a simple function object in one place only\n\nSee [F.11](#rf-lambda)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-var\"></a>T.142?: Use template variables to simplify notation",
    "content": "### <a name=\"rt-var\"></a>T.142?: Use template variables to simplify notation\n\n##### Reason\n\nImproved readability.\n\n##### Example\n\n    ???\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-non-generic\"></a>T.143: Don't write unintentionally non-generic code",
    "content": "### <a name=\"rt-non-generic\"></a>T.143: Don't write unintentionally non-generic code\n\n##### Reason\n\nGenerality. Reusability. Don't gratuitously commit to details; use the most general facilities available.\n\n##### Example\n\nUse `!=` instead of `<` to compare iterators; `!=` works for more objects because it doesn't rely on ordering.\n\n    for (auto i = first; i < last; ++i) {   // less generic\n        // ...\n    }\n\n    for (auto i = first; i != last; ++i) {   // good; more generic\n        // ...\n    }\n\nOf course, range-`for` is better still where it does what you want.\n\n##### Example\n\nUse the least-derived class that has the functionality you need.\n\n    class Base {\n    public:\n        Bar f();\n        Bar g();\n    };\n\n    class Derived1 : public Base {\n    public:\n        Bar h();\n    };\n\n    class Derived2 : public Base {\n    public:\n        Bar j();\n    };\n\n    // bad, unless there is a specific reason for limiting to Derived1 objects only\n    void my_func(Derived1& param)\n    {\n        use(param.f());\n        use(param.g());\n    }\n\n    // good, uses only Base interface so only commit to that\n    void my_func(Base& param)\n    {\n        use(param.f());\n        use(param.g());\n    }\n\n##### Enforcement\n\n* Flag comparison of iterators using `<` instead of `!=`.\n* Flag `x.size() == 0` when `x.empty()` or `x.is_empty()` is available. Emptiness works for more containers than size(), because some containers don't know their size or are conceptually of unbounded size.\n* Flag functions that take a pointer or reference to a more-derived type but only use functions declared in a base type.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-specialize-function\"></a>T.144: Don't specialize function templates",
    "content": "### <a name=\"rt-specialize-function\"></a>T.144: Don't specialize function templates\n\n##### Reason\n\nYou can't partially specialize a function template per language rules. You can fully specialize a function template but you almost certainly want to overload instead -- because function template specializations don't participate in overloading, they don't act as you probably wanted. Rarely, you should actually specialize by delegating to a class template that you can specialize properly.\n\n##### Example\n\n    ???\n\n**Exceptions**: If you do have a valid reason to specialize a function template, just write a single function template that delegates to a class template, then specialize the class template (including the ability to write partial specializations).\n\n##### Enforcement\n\n* Flag all specializations of a function template. Overload instead.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rt-check-class\"></a>T.150: Check that a class matches a concept using `static_assert`",
    "content": "### <a name=\"rt-check-class\"></a>T.150: Check that a class matches a concept using `static_assert`\n\n##### Reason\n\nIf you intend for a class to match a concept, verifying that early saves users' pain.\n\n##### Example\n\n    class X {\n    public:\n        X() = delete;\n        X(const X&) = default;\n        X(X&&) = default;\n        X& operator=(const X&) = default;\n        // ...\n    };\n\nSomewhere, possibly in an implementation file, let the compiler check the desired properties of `X`:\n\n    static_assert(Default_constructible<X>);    // error: X has no default constructor\n    static_assert(Copyable<X>);                 // error: we forgot to define X's move constructor\n\n\n##### Enforcement\n\nNot feasible.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-cpl\"></a>CPL: C-style programming",
    "content": "# <a name=\"s-cpl\"></a>CPL: C-style programming\n\nC and C++ are closely related languages.\nThey both originate in \"Classic C\" from 1978 and have evolved in ISO committees since then.\nMany attempts have been made to keep them compatible, but neither is a subset of the other.\n\nC rule summary:\n\n* [CPL.1: Prefer C++ to C](#rcpl-c)\n* [CPL.2: If you must use C, use the common subset of C and C++, and compile the C code as C++](#rcpl-subset)\n* [CPL.3: If you must use C for interfaces, use C++ in the calling code using such interfaces](#rcpl-interface)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rcpl-c\"></a>CPL.1: Prefer C++ to C",
    "content": "### <a name=\"rcpl-c\"></a>CPL.1: Prefer C++ to C\n\n##### Reason\n\nC++ provides better type checking and more notational support.\nIt provides better support for high-level programming and often generates faster code.\n\n##### Example\n\n    char ch = 7;\n    void* pv = &ch;\n    int* pi = pv;   // not C++\n    *pi = 999;      // overwrite sizeof(int) bytes near &ch\n\nThe rules for implicit casting to and from `void*` in C are subtle and unenforced.\nIn particular, this example violates a rule against converting to a type with stricter alignment.\n\n##### Enforcement\n\nUse a C++ compiler.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rcpl-subset\"></a>CPL.2: If you must use C, use the common subset of C and C++, and compile the C code as C++",
    "content": "### <a name=\"rcpl-subset\"></a>CPL.2: If you must use C, use the common subset of C and C++, and compile the C code as C++\n\n##### Reason\n\nThat subset can be compiled with both C and C++ compilers, and when compiled as C++ is better type checked than \"pure C.\"\n\n##### Example\n\n    int* p1 = malloc(10 * sizeof(int));                      // not C++\n    int* p2 = static_cast<int*>(malloc(10 * sizeof(int)));   // not C, C-style C++\n    int* p3 = new int[10];                                   // not C\n    int* p4 = (int*) malloc(10 * sizeof(int));               // both C and C++\n\n##### Enforcement\n\n* Flag if using a build mode that compiles code as C.\n\n  * The C++ compiler will enforce that the code is valid C++ unless you use C extension options.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rcpl-interface\"></a>CPL.3: If you must use C for interfaces, use C++ in the calling code using such interfaces",
    "content": "### <a name=\"rcpl-interface\"></a>CPL.3: If you must use C for interfaces, use C++ in the calling code using such interfaces\n\n##### Reason\n\nC++ is more expressive than C and offers better support for many types of programming.\n\n##### Example\n\nFor example, to use a 3rd party C library or C systems interface, define the low-level interface in the common subset of C and C++ for better type checking.\nWhenever possible encapsulate the low-level interface in an interface that follows the C++ guidelines (for better abstraction, memory safety, and resource safety) and use that C++ interface in C++ code.\n\n##### Example\n\nYou can call C from C++:\n\n    // in C:\n    double sqrt(double);\n\n    // in C++:\n    extern \"C\" double sqrt(double);\n\n    sqrt(2);\n\n##### Example\n\nYou can call C++ from C:\n\n    // in C:\n    X call_f(struct Y*, int);\n\n    // in C++:\n    extern \"C\" X call_f(Y* p, int i)\n    {\n        return p->f(i);   // possibly a virtual function call\n    }\n\n##### Enforcement\n\nNone needed\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-source\"></a>SF: Source files",
    "content": "# <a name=\"s-source\"></a>SF: Source files\n\nDistinguish between declarations (used as interfaces) and definitions (used as implementations).\nUse header files to represent interfaces and to emphasize logical structure.\n\nSource file rule summary:\n\n* [SF.1: Use a `.cpp` suffix for code files and `.h` for interface files if your project doesn't already follow another convention](#rs-file-suffix)\n* [SF.2: A header file must not contain object definitions or non-inline function definitions](#rs-inline)\n* [SF.3: Use header files for all declarations used in multiple source files](#rs-declaration-header)\n* [SF.4: Include header files before other declarations in a file](#rs-include-order)\n* [SF.5: A `.cpp` file must include the header file(s) that defines its interface](#rs-consistency)\n* [SF.6: Use `using namespace` directives for transition, for foundation libraries (such as `std`), or within a local scope (only)](#rs-using)\n* [SF.7: Don't write `using namespace` at global scope in a header file](#rs-using-directive)\n* [SF.8: Use `#include` guards for all header files](#rs-guards)\n* [SF.9: Avoid cyclic dependencies among source files](#rs-cycles)\n* [SF.10: Avoid dependencies on implicitly `#include`d names](#rs-implicit)\n* [SF.11: Header files should be self-contained](#rs-contained)\n* [SF.12: Prefer the quoted form of `#include` for files relative to the including file and the angle bracket form everywhere else](#rs-incform)\n* [SF.13: Use portable header identifiers in `#include` statements](#rs-portable-header-id)\n\n* [SF.20: Use `namespace`s to express logical structure](#rs-namespace)\n* [SF.21: Don't use an unnamed (anonymous) namespace in a header](#rs-unnamed)\n* [SF.22: Use an unnamed (anonymous) namespace for all internal/non-exported entities](#rs-unnamed2)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rs-file-suffix\"></a>SF.1: Use a `.cpp` suffix for code files and `.h` for interface files if your project doesn't already follow another convention",
    "content": "### <a name=\"rs-file-suffix\"></a>SF.1: Use a `.cpp` suffix for code files and `.h` for interface files if your project doesn't already follow another convention\n\nSee [NL.27](#rl-file-suffix)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rs-inline\"></a>SF.2: A header file must not contain object definitions or non-inline function definitions",
    "content": "### <a name=\"rs-inline\"></a>SF.2: A header file must not contain object definitions or non-inline function definitions\n\n##### Reason\n\nIncluding entities subject to the one-definition rule leads to linkage errors.\n\n##### Example\n\n    // file.h:\n    namespace Foo {\n        int x = 7;\n        int xx() { return x+x; }\n    }\n\n    // file1.cpp:\n    #include <file.h>\n    // ... more ...\n\n     // file2.cpp:\n    #include <file.h>\n    // ... more ...\n\nLinking `file1.cpp` and `file2.cpp` will give two linker errors.\n\n**Alternative formulation**: A header file must contain only:\n\n* `#include`s of other header files (possibly with include guards)\n* templates\n* class definitions\n* function declarations\n* `extern` declarations\n* `inline` function definitions\n* `constexpr` definitions\n* `const` definitions\n* `using` alias definitions\n* ???\n\n##### Enforcement\n\nCheck the positive list above.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rs-declaration-header\"></a>SF.3: Use header files for all declarations used in multiple source files",
    "content": "### <a name=\"rs-declaration-header\"></a>SF.3: Use header files for all declarations used in multiple source files\n\n##### Reason\n\nMaintainability. Readability.\n\n##### Example, bad\n\n    // bar.cpp:\n    void bar() { cout << \"bar\\n\"; }\n\n    // foo.cpp:\n    extern void bar();\n    void foo() { bar(); }\n\nA maintainer of `bar` cannot find all declarations of `bar` if its type needs changing.\nThe user of `bar` cannot know if the interface used is complete and correct. At best, error messages come (late) from the linker.\n\n##### Enforcement\n\n* Flag declarations of entities in other source files not placed in a `.h`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rs-include-order\"></a>SF.4: Include header files before other declarations in a file",
    "content": "### <a name=\"rs-include-order\"></a>SF.4: Include header files before other declarations in a file\n\n##### Reason\n\nMinimize context dependencies and increase readability.\n\n##### Example\n\n    #include <vector>\n    #include <algorithm>\n    #include <string>\n\n    // ... my code here ...\n\n##### Example, bad\n\n    #include <vector>\n\n    // ... my code here ...\n\n    #include <algorithm>\n    #include <string>\n\n##### Note\n\nThis applies to both `.h` and `.cpp` files.\n\n##### Note\n\nThere is an argument for insulating code from declarations and macros in header files by `#including` headers *after* the code we want to protect\n(as in the example labeled \"bad\").\nHowever\n\n* that only works for one file (at one level): Use that technique in a header included with other headers and the vulnerability reappears.\n* a namespace (an \"implementation namespace\") can protect against many context dependencies.\n* full protection and flexibility require modules.\n\n**See also**:\n\n* [Working Draft, Extensions to C++ for Modules](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4592.pdf)\n* [Modules, Componentization, and Transition](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0141r0.pdf)\n\n##### Enforcement\n\nEasy.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rs-consistency\"></a>SF.5: A `.cpp` file must include the header file(s) that defines its interface",
    "content": "### <a name=\"rs-consistency\"></a>SF.5: A `.cpp` file must include the header file(s) that defines its interface\n\n##### Reason\n\nThis enables the compiler to do an early consistency check.\n\n##### Example, bad\n\n    // foo.h:\n    void foo(int);\n    int bar(long);\n    int foobar(int);\n\n    // foo.cpp:\n    void foo(int) { /* ... */ }\n    int bar(double) { /* ... */ }\n    double foobar(int);\n\nThe errors will not be caught until link time for a program calling `bar` or `foobar`.\n\n##### Example\n\n    // foo.h:\n    void foo(int);\n    int bar(long);\n    int foobar(int);\n\n    // foo.cpp:\n    #include \"foo.h\"\n\n    void foo(int) { /* ... */ }\n    int bar(double) { /* ... */ }\n    double foobar(int);   // error: wrong return type\n\nThe return-type error for `foobar` is now caught immediately when `foo.cpp` is compiled.\nThe argument-type error for `bar` cannot be caught until link time because of the possibility of overloading, but systematic use of `.h` files increases the likelihood that it is caught earlier by the programmer.\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rs-using\"></a>SF.6: Use `using namespace` directives for transition, for foundation libraries (such as `std`), or within a local scope (only)",
    "content": "### <a name=\"rs-using\"></a>SF.6: Use `using namespace` directives for transition, for foundation libraries (such as `std`), or within a local scope (only)\n\n##### Reason\n\n `using namespace` can lead to name clashes, so it should be used sparingly.\n However, it is not always possible to qualify every name from a namespace in user code (e.g., during transition)\n and sometimes a namespace is so fundamental and prevalent in a code base, that consistent qualification would be verbose and distracting.\n\n##### Example\n\n    #include <string>\n    #include <vector>\n    #include <iostream>\n    #include <memory>\n    #include <algorithm>\n\n    using namespace std;\n\n    // ...\n\nHere (obviously), the standard library is used pervasively and apparently no other library is used, so requiring `std::` everywhere\ncould be distracting.\n\n##### Example\n\nThe use of `using namespace std;` leaves the programmer open to a name clash with a name from the standard library\n\n    #include <cmath>\n    using namespace std;\n\n    int g(int x)\n    {\n        int sqrt = 7;\n        // ...\n        return sqrt(x); // error\n    }\n\nHowever, this is not particularly likely to lead to a resolution that is not an error and\npeople who use `using namespace std` are supposed to know about `std` and about this risk.\n\n##### Note\n\nA `.cpp` file is a form of local scope.\nThere is little difference in the opportunities for name clashes in an N-line `.cpp` containing a `using namespace X`,\nan N-line function containing a `using namespace X`,\nand M functions each containing a `using namespace X` with N lines of code in total.\n\n##### Note\n\n[Don't write `using namespace` at global scope in a header file](#rs-using-directive).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rs-using-directive\"></a>SF.7: Don't write `using namespace` at global scope in a header file",
    "content": "### <a name=\"rs-using-directive\"></a>SF.7: Don't write `using namespace` at global scope in a header file\n\n##### Reason\n\nDoing so takes away an `#include`r's ability to effectively disambiguate and to use alternatives. It also makes `#include`d headers order-dependent as they might have different meaning when included in different orders.\n\n##### Example\n\n    // bad.h\n    #include <iostream>\n    using namespace std; // bad\n\n    // user.cpp\n    #include \"bad.h\"\n\n    bool copy(/*... some parameters ...*/);    // some function that happens to be named copy\n\n    int main()\n    {\n        copy(/*...*/);    // now overloads local ::copy and std::copy, could be ambiguous\n    }\n\n##### Note\n\nAn exception is `using namespace std::literals;`. This is necessary to use string literals\nin header files and given [the rules](https://eel.is/c++draft/over.literal) - users are required\nto name their own UDLs `operator\"\"_x` - they will not collide with the standard library.\n\n##### Enforcement\n\nFlag `using namespace` at global scope in a header file.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rs-guards\"></a>SF.8: Use `#include` guards for all header files",
    "content": "### <a name=\"rs-guards\"></a>SF.8: Use `#include` guards for all header files\n\n##### Reason\n\nTo avoid files being `#include`d several times.\n\nIn order to avoid include guard collisions, do not just name the guard after the filename.\nBe sure to also include a key and good differentiator, such as the name of library or component\nthe header file is part of.\n\n##### Example\n\n    // file foobar.h:\n    #ifndef LIBRARY_FOOBAR_H\n    #define LIBRARY_FOOBAR_H\n    // ... declarations ...\n    #endif // LIBRARY_FOOBAR_H\n\n##### Enforcement\n\nFlag `.h` files without `#include` guards.\n\n##### Note\n\nSome implementations offer vendor extensions like `#pragma once` as alternative to include guards.\nIt is not standard and it is not portable.  It injects the hosting machine's filesystem semantics\ninto your program, in addition to locking you down to a vendor.\nOur recommendation is to write in ISO C++: See [rule P.2](#rp-cplusplus).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rs-cycles\"></a>SF.9: Avoid cyclic dependencies among source files",
    "content": "### <a name=\"rs-cycles\"></a>SF.9: Avoid cyclic dependencies among source files\n\n##### Reason\n\nCycles complicate comprehension and slow down compilation. They also\ncomplicate conversion to use language-supported modules (when they become\navailable).\n\n##### Note\n\nEliminate cycles; don't just break them with `#include` guards.\n\n##### Example, bad\n\n    // file1.h:\n    #include \"file2.h\"\n\n    // file2.h:\n    #include \"file3.h\"\n\n    // file3.h:\n    #include \"file1.h\"\n\n##### Enforcement\n\nFlag all cycles.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rs-implicit\"></a>SF.10: Avoid dependencies on implicitly `#include`d names",
    "content": "### <a name=\"rs-implicit\"></a>SF.10: Avoid dependencies on implicitly `#include`d names\n\n##### Reason\n\nAvoid surprises.\nAvoid having to change `#include`s if an `#include`d header changes.\nAvoid accidentally becoming dependent on implementation details and logically separate entities included in a header.\n\n##### Example, bad\n\n    #include <iostream>\n    using namespace std;\n\n    void use()\n    {\n        string s;\n        cin >> s;               // fine\n        getline(cin, s);        // error: getline() not defined\n        if (s == \"surprise\") {  // error == not defined\n            // ...\n        }\n    }\n\n`<iostream>` exposes the definition of `std::string` (\"why?\" makes for a fun trivia question),\nbut it is not required to do so by transitively including the entire `<string>` header,\nresulting in the popular beginner question \"why doesn't `getline(cin,s);` work?\"\nor even an occasional \"`string`s cannot be compared with `==`\").\n\nThe solution is to explicitly `#include <string>`:\n\n##### Example, good\n\n    #include <iostream>\n    #include <string>\n    using namespace std;\n\n    void use()\n    {\n        string s;\n        cin >> s;               // fine\n        getline(cin, s);        // fine\n        if (s == \"surprise\") {  // fine\n            // ...\n        }\n    }\n\n##### Note\n\nSome headers exist exactly to collect a set of consistent declarations from a variety of headers.\nFor example:\n\n    // basic_std_lib.h:\n\n    #include <string>\n    #include <map>\n    #include <iostream>\n    #include <random>\n    #include <vector>\n\na user can now get that set of declarations with a single `#include`\n\n    #include \"basic_std_lib.h\"\n\nThis rule against implicit inclusion is not meant to prevent such deliberate aggregation.\n\n##### Enforcement\n\nEnforcement would require some knowledge about what in a header is meant to be \"exported\" to users and what is there to enable implementation.\nNo really good solution is possible until we have modules.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rs-contained\"></a>SF.11: Header files should be self-contained",
    "content": "### <a name=\"rs-contained\"></a>SF.11: Header files should be self-contained\n\n##### Reason\n\nUsability, headers should be simple to use and work when included on their own.\nHeaders should encapsulate the functionality they provide.\nAvoid clients of a header having to manage that header's dependencies.\n\n##### Example\n\n    #include \"helpers.h\"\n    // helpers.h depends on std::string and includes <string>\n\n##### Note\n\nFailing to follow this results in difficult to diagnose errors for clients of a header.\n\n##### Note\n\nA header should include all its dependencies. Be careful about using relative paths because C++ implementations diverge on their meaning.\n\n##### Enforcement\n\nA test should verify that the header file itself compiles or that a cpp file which only includes the header file compiles.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rs-incform\"></a>SF.12: Prefer the quoted form of `#include` for files relative to the including file and the angle bracket form everywhere else",
    "content": "### <a name=\"rs-incform\"></a>SF.12: Prefer the quoted form of `#include` for files relative to the including file and the angle bracket form everywhere else\n\n##### Reason\n\nThe [standard](https://eel.is/c++draft/cpp.include) provides flexibility for compilers to implement\nthe two forms of `#include` selected using the angle (`<>`) or quoted (`\"\"`) syntax. Vendors take\nadvantage of this and use different search algorithms and methods for specifying the include path.\n\nNevertheless, the guidance is to use the quoted form for including files that exist at a relative path to the file containing the `#include` statement (from within the same component or project) and to use the angle bracket form everywhere else, where possible. This encourages being clear about the locality of the file relative to files that include it, or scenarios where the different search algorithm is required. It makes it easy to understand at a glance whether a header is being included from a local relative file versus a standard library header or a header from the alternate search path (e.g. a header from another library or a common set of includes).\n\n##### Example\n\n    // foo.cpp:\n    #include <string>                // From the standard library, requires the <> form\n    #include <some_library/common.h> // A file that is not locally relative, included from another library; use the <> form\n    #include \"foo.h\"                 // A file locally relative to foo.cpp in the same project, use the \"\" form\n    #include \"util/util.h\"           // A file locally relative to foo.cpp in the same project, use the \"\" form\n    #include <component_b/bar.h>     // A file in the same project located via a search path, use the <> form\n\n##### Note\n\nFailing to follow this results in difficult to diagnose errors due to picking up the wrong file by incorrectly specifying the scope when it is included. For example, in a typical case where the `#include \"\"` search algorithm might search for a file existing at a local relative path first, then using this form to refer to a file that is not locally relative could mean that if a file ever comes into existence at the local relative path (e.g. the including file is moved to a new location), it will now be found ahead of the previous include file and the set of includes will have been changed in an unexpected way.\n\nLibrary creators should put their headers in a folder and have clients include those files using the relative path `#include <some_library/common.h>`\n\n##### Enforcement\n\nA test should identify whether headers referenced via `\"\"` could be referenced with `<>`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rs-portable-header-id\"></a>SF.13: Use portable header identifiers in `#include` statements",
    "content": "### <a name=\"rs-portable-header-id\"></a>SF.13: Use portable header identifiers in `#include` statements\n\n##### Reason\n\nThe [standard](https://eel.is/c++draft/cpp.include) does not specify how compilers uniquely locate headers from an identifier in an `#include` directive, nor does it specify what constitutes uniqueness. For example, whether the implementation considers the identifiers to be case-sensitive, or whether the identifiers are file system paths to a header file, and if so, how a hierarchical file system path is delimited.\n\nTo maximize the portability of `#include` directives across compilers, guidance is to:\n\n* use case-sensitivity for the header identifier, matching how the header is defined by the standard, specification, implementation, or file that provides the header.\n* when the header identifier is a hierarchical file path, use forward-slash `/` to delimit path components as this is the most widely-accepted path-delimiting character.\n\n##### Example\n\n    // good examples\n    #include <vector>\n    #include <string>\n    #include \"util/util.h\"\n\n    // bad examples\n    #include <VECTOR>        // bad: the standard library defines a header identified as <vector>, not <VECTOR>\n    #include <String>        // bad: the standard library defines a header identified as <string>, not <String>\n    #include \"Util/Util.H\"   // bad: the header file exists on the file system as \"util/util.h\"\n    #include \"util\\util.h\"   // bad: may not work if the implementation interprets `\\u` as an escape sequence, or where '\\' is not a valid path separator\n\n##### Enforcement\n\nIt is only possible to enforce on implementations where header identifiers are case-sensitive and which only support `/` as a file path delimiter.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rs-namespace\"></a>SF.20: Use `namespace`s to express logical structure",
    "content": "### <a name=\"rs-namespace\"></a>SF.20: Use `namespace`s to express logical structure\n\n##### Reason\n\n ???\n\n##### Example\n\n    ???\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rs-unnamed\"></a>SF.21: Don't use an unnamed (anonymous) namespace in a header",
    "content": "### <a name=\"rs-unnamed\"></a>SF.21: Don't use an unnamed (anonymous) namespace in a header\n\n##### Reason\n\nIt is almost always a bug to mention an unnamed namespace in a header file.\n\n##### Example\n\n    // file foo.h:\n    namespace\n    {\n        const double x = 1.234;  // bad\n\n        double foo(double y)     // bad\n        {\n            return y + x;\n        }\n    }\n\n    namespace Foo\n    {\n        const double x = 1.234; // good\n\n        inline double foo(double y)        // good\n        {\n            return y + x;\n        }\n    }\n\n##### Enforcement\n\n* Flag any use of an anonymous namespace in a header file.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rs-unnamed2\"></a>SF.22: Use an unnamed (anonymous) namespace for all internal/non-exported entities",
    "content": "### <a name=\"rs-unnamed2\"></a>SF.22: Use an unnamed (anonymous) namespace for all internal/non-exported entities\n\n##### Reason\n\nNothing external can depend on an entity in a nested unnamed namespace.\nConsider putting every definition in an implementation source file in an unnamed namespace unless that is defining an \"external/exported\" entity.\n\n##### Example; bad\n\n    static int f();\n    int g();\n    static bool h();\n    int k();\n\n##### Example; good\n\n    namespace {\n        int f();\n        bool h();\n    }\n    int g();\n    int k();\n\n##### Example\n\nAn API class and its members can't live in an unnamed namespace; but any \"helper\" class or function that is defined in an implementation source file should be at an unnamed namespace scope.\n\n    ???\n\n##### Enforcement\n\n* ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-stdlib\"></a>SL: The Standard Library",
    "content": "# <a name=\"s-stdlib\"></a>SL: The Standard Library\n\nUsing only the bare language, every task is tedious (in any language).\nUsing a suitable library any task can be reasonably simple.\n\nThe standard library has steadily grown over the years.\nIts description in the standard is now larger than that of the language features.\nSo, it is likely that this library section of the guidelines will eventually grow in size to equal or exceed all the rest.\n\n<< ??? We need another level of rule numbering ??? >>\n\nC++ Standard Library component summary:\n\n* [SL.con: Containers](#ss-con)\n* [SL.str: String](#ss-string)\n* [SL.io: Iostream](#ss-io)\n* [SL.regex: Regex](#ss-regex)\n* [SL.chrono: Time](#ss-chrono)\n* [SL.C: The C Standard Library](#ss-clib)\n\nStandard-library rule summary:\n\n* [SL.1: Use libraries wherever possible](#rsl-lib)\n* [SL.2: Prefer the standard library to other libraries](#rsl-sl)\n* [SL.3: Do not add non-standard entities to namespace `std`](#sl-std)\n* [SL.4: Use the standard library in a type-safe manner](#sl-safe)\n* ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rsl-lib\"></a>SL.1:  Use libraries wherever possible",
    "content": "### <a name=\"rsl-lib\"></a>SL.1:  Use libraries wherever possible\n\n##### Reason\n\nSave time. Don't re-invent the wheel.\nDon't replicate the work of others.\nBenefit from other people's work when they make improvements.\nHelp other people when you make improvements.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rsl-sl\"></a>SL.2: Prefer the standard library to other libraries",
    "content": "### <a name=\"rsl-sl\"></a>SL.2: Prefer the standard library to other libraries\n\n##### Reason\n\nMore people know the standard library.\nIt is more likely to be stable, well-maintained, and widely available than your own code or most other libraries.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"sl-std\"></a>SL.3: Do not add non-standard entities to namespace `std`",
    "content": "### <a name=\"sl-std\"></a>SL.3: Do not add non-standard entities to namespace `std`\n\n##### Reason\n\nAdding to `std` might change the meaning of otherwise standards conforming code.\nAdditions to `std` might clash with future versions of the standard.\n\n##### Example\n\n    namespace std { // BAD: violates standard\n\n    class My_vector {\n        //     . . .\n    };\n\n    }\n\n    namespace Foo { // GOOD: user namespace is allowed\n\n    class My_vector {\n        //     . . .\n    };\n\n    }\n\n##### Enforcement\n\nPossible, but messy and likely to cause problems with platforms.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"sl-safe\"></a>SL.4: Use the standard library in a type-safe manner",
    "content": "### <a name=\"sl-safe\"></a>SL.4: Use the standard library in a type-safe manner\n\n##### Reason\n\nBecause, obviously, breaking this rule can lead to undefined behavior, memory corruption, and all kinds of other bad errors.\n\n##### Note\n\nThis is a semi-philosophical meta-rule, which needs many supporting concrete rules.\nWe need it as an umbrella for the more specific rules.\n\nSummary of more specific rules:\n\n* [SL.4: Use the standard library in a type-safe manner](#sl-safe)\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-con\"></a>SL.con: Containers",
    "content": "## <a name=\"ss-con\"></a>SL.con: Containers\n\n???\n\nContainer rule summary:\n\n* [SL.con.1: Prefer using STL `array` or `vector` instead of a C array](#rsl-arrays)\n* [SL.con.2: Prefer using STL `vector` by default unless you have a reason to use a different container](#rsl-vector)\n* [SL.con.3: Avoid bounds errors](#rsl-bounds)\n* [SL.con.4: don't use `memset` or `memcpy` for arguments that are not trivially-copyable](#rsl-copy)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rsl-arrays\"></a>SL.con.1: Prefer using STL `array` or `vector` instead of a C array",
    "content": "### <a name=\"rsl-arrays\"></a>SL.con.1: Prefer using STL `array` or `vector` instead of a C array\n\n##### Reason\n\nC arrays are less safe, and have no advantages over `array` and `vector`.\nFor a fixed-length array, use `std::array`, which does not degenerate to a pointer when passed to a function and does know its size.\nAlso, like a built-in array, a stack-allocated `std::array` keeps its elements on the stack.\nFor a variable-length array, use `std::vector`, which additionally can change its size and handles memory allocation.\n\n##### Example\n\n    int v[SIZE];                        // BAD\n\n    std::array<int, SIZE> w;            // ok\n\n##### Example\n\n    int* v = new int[initial_size];     // BAD, owning raw pointer\n    delete[] v;                         // BAD, manual delete\n\n    std::vector<int> w(initial_size);   // ok\n\n##### Note\n\nUse `gsl::span` for non-owning references into a container.\n\n##### Note\n\nComparing the performance of a fixed-sized array allocated on the stack against a `vector` with its elements on the free store is bogus.\nYou could just as well compare a `std::array` on the stack against the result of a `malloc()` accessed through a pointer.\nFor most code, even the difference between stack allocation and free-store allocation doesn't matter, but the convenience and safety of `vector` does.\nPeople working with code for which that difference matters are quite capable of choosing between `array` and `vector`.\n\n##### Enforcement\n\n* Flag declaration of a C array inside a function or class that also declares an STL container (to avoid excessive noisy warnings on legacy non-STL code). To fix: At least change the C array to a `std::array`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rsl-vector\"></a>SL.con.2: Prefer using STL `vector` by default unless you have a reason to use a different container",
    "content": "### <a name=\"rsl-vector\"></a>SL.con.2: Prefer using STL `vector` by default unless you have a reason to use a different container\n\n##### Reason\n\n`vector` and `array` are the only standard containers that offer the following advantages:\n\n* the fastest general-purpose access (random access, including being vectorization-friendly);\n* the fastest default access pattern (begin-to-end or end-to-begin is prefetcher-friendly);\n* the lowest space overhead (contiguous layout has zero per-element overhead, which is cache-friendly).\n\nUsually you need to add and remove elements from the container, so use `vector` by default; if you don't need to modify the container's size, use `array`.\n\nEven when other containers seem more suited, such as `map` for O(log N) lookup performance or a `list` for efficient insertion in the middle, a `vector` will usually still perform better for containers up to a few KB in size.\n\n##### Note\n\n`string` should not be used as a container of individual characters. A `string` is a textual string; if you want a container of characters, use `vector</*char_type*/>` or `array</*char_type*/>` instead.\n\n##### Exceptions\n\nIf you have a good reason to use another container, use that instead. For example:\n\n* If `vector` suits your needs but you don't need the container to be variable size, use `array` instead.\n\n* If you want a dictionary-style lookup container that guarantees O(K) or O(log N) lookups, the container will be larger (more than a few KB) and you perform frequent inserts so that the overhead of maintaining a sorted `vector` is infeasible, go ahead and use an `unordered_map` or `map` instead.\n\n##### Note\n\nTo initialize a vector with a number of elements, use `()`-initialization.\nTo initialize a vector with a list of elements, use `{}`-initialization.\n\n    vector<int> v1(20);  // v1 has 20 elements with the value 0 (vector<int>{})\n    vector<int> v2 {20}; // v2 has 1 element with the value 20\n\n[Prefer the {}-initializer syntax](#res-list).\n\n##### Enforcement\n\n* Flag a `vector` whose size never changes after construction (such as because it's `const` or because no non-`const` functions are called on it). To fix: Use an `array` instead.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rsl-bounds\"></a>SL.con.3: Avoid bounds errors",
    "content": "### <a name=\"rsl-bounds\"></a>SL.con.3: Avoid bounds errors\n\n##### Reason\n\nRead or write beyond an allocated range of elements typically leads to bad errors, wrong results, crashes, and security violations.\n\n##### Note\n\nThe standard-library functions that apply to ranges of elements all have (or could have) bounds-safe overloads that take `span`.\nStandard types such as `vector` can be modified to perform bounds-checks under the bounds profile (in a compatible way, such as by adding contracts), or used with `at()`.\n\nIdeally, the in-bounds guarantee should be statically enforced.\nFor example:\n\n* a range-`for` cannot loop beyond the range of the container to which it is applied\n* a `v.begin(),v.end()` is easily determined to be bounds safe\n\nSuch loops are as fast as any unchecked/unsafe equivalent.\n\nOften a simple pre-check can eliminate the need for checking of individual indices.\nFor example\n\n* for `v.begin(),v.begin()+i` the `i` can easily be checked against `v.size()`\n\nSuch loops can be much faster than individually checked element accesses.\n\n##### Example, bad\n\n    void f()\n    {\n        array<int, 10> a, b;\n        memset(a.data(), 0, 10);         // BAD, and contains a length error (length = 10 * sizeof(int))\n        memcmp(a.data(), b.data(), 10);  // BAD, and contains a length error (length = 10 * sizeof(int))\n    }\n\nAlso, `std::array<>::fill()` or `std::fill()` or even an empty initializer are better candidates than `memset()`.\n\n##### Example, good\n\n    void f()\n    {\n        array<int, 10> a, b, c{};       // c is initialized to zero\n        a.fill(0);\n        fill(b.begin(), b.end(), 0);    // std::fill()\n        fill(b, 0);                     // std::ranges::fill()\n\n        if ( a == b ) {\n          // ...\n        }\n    }\n\n##### Example\n\nIf code is using an unmodified standard library, then there are still workarounds that enable use of `std::array` and `std::vector` in a bounds-safe manner. Code can call the `.at()` member function on each class, which will result in an `std::out_of_range` exception being thrown. Alternatively, code can call the `at()` free function, which will result in fail-fast (or a customized action) on a bounds violation.\n\n    void f(std::vector<int>& v, std::array<int, 12> a, int i)\n    {\n        v[0] = a[0];        // BAD\n        v.at(0) = a[0];     // OK (alternative 1)\n        at(v, 0) = a[0];    // OK (alternative 2)\n\n        v.at(0) = a[i];     // BAD\n        v.at(0) = a.at(i);  // OK (alternative 1)\n        v.at(0) = at(a, i); // OK (alternative 2)\n    }\n\n##### Enforcement\n\n* Issue a diagnostic for any call to a standard-library function that is not bounds-checked.\n??? insert link to a list of banned functions\n\nThis rule is part of the [bounds profile](#ss-bounds).\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rsl-copy\"></a>SL.con.4: don't use `memset` or `memcpy` for arguments that are not trivially-copyable",
    "content": "### <a name=\"rsl-copy\"></a>SL.con.4: don't use `memset` or `memcpy` for arguments that are not trivially-copyable\n\n##### Reason\n\nDoing so messes the semantics of the objects (e.g., by overwriting a `vptr`).\n\n##### Note\n\nSimilarly for (w)memset, (w)memcpy, (w)memmove, and (w)memcmp\n\n##### Example\n\n    struct base {\n        virtual void update() = 0;\n    };\n\n    struct derived : public base {\n        void update() override {}\n    };\n\n\n    void f(derived& a, derived& b) // goodbye v-tables\n    {\n        memset(&a, 0, sizeof(derived));\n        memcpy(&a, &b, sizeof(derived));\n        memcmp(&a, &b, sizeof(derived));\n    }\n\nInstead, define proper default initialization, copy, and comparison functions\n\n    void g(derived& a, derived& b)\n    {\n        a = {};    // default initialize\n        b = a;     // copy\n        if (a == b) do_something(a, b);\n    }\n\n##### Enforcement\n\n* Flag the use of those functions for types that are not trivially copyable\n\n**TODO Notes**:\n\n* Impact on the standard library will require close coordination with WG21, if only to ensure compatibility even if never standardized.\n* We are considering specifying bounds-safe overloads for stdlib (especially C stdlib) functions like `memcmp` and shipping them in the GSL.\n* For existing stdlib functions and types like `vector` that are not fully bounds-checked, the goal is for these features to be bounds-checked when called from code with the bounds profile on, and unchecked when called from legacy code, possibly using contracts (concurrently being proposed by several WG21 members).\n\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-string\"></a>SL.str: String",
    "content": "## <a name=\"ss-string\"></a>SL.str: String\n\nText manipulation is a huge topic.\n`std::string` doesn't cover all of it.\nThis section primarily tries to clarify `std::string`'s relation to `char*`, `zstring`, `string_view`, and `gsl::span<char>`.\nThe important issue of non-ASCII character sets and encodings (e.g., `wchar_t`, Unicode, and UTF-8) will be covered elsewhere.\n\n**See also**: [regular expressions](#ss-regex)\n\nHere, we use \"sequence of characters\" or \"string\" to refer to a sequence of characters meant to be read as text (somehow, eventually).\nWe don't consider ???\n\nString summary:\n\n* [SL.str.1: Use `std::string` to own character sequences](#rstr-string)\n* [SL.str.2: Use `std::string_view` or `gsl::span<char>` to refer to character sequences](#rstr-view)\n* [SL.str.3: Use `zstring` or `czstring` to refer to a C-style, zero-terminated, sequence of characters](#rstr-zstring)\n* [SL.str.4: Use `char*` to refer to a single character](#rstr-charp)\n* [SL.str.5: Use `std::byte` to refer to byte values that do not necessarily represent characters](#rstr-byte)\n\n* [SL.str.10: Use `std::string` when you need to perform locale-sensitive string operations](#rstr-locale)\n* [SL.str.11: Use `gsl::span<char>` rather than `std::string_view` when you need to mutate a string](#rstr-span)\n* [SL.str.12: Use the `s` suffix for string literals meant to be standard-library `string`s](#rstr-s)\n\n**See also**:\n\n* [F.24 span](#rf-range)\n* [F.25 zstring](#rf-zstring)\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rstr-string\"></a>SL.str.1: Use `std::string` to own character sequences",
    "content": "### <a name=\"rstr-string\"></a>SL.str.1: Use `std::string` to own character sequences\n\n##### Reason\n\n`string` correctly handles allocation, ownership, copying, gradual expansion, and offers a variety of useful operations.\n\n##### Example\n\n    vector<string> read_until(const string& terminator)\n    {\n        vector<string> res;\n        for (string s; cin >> s && s != terminator; ) // read a word\n            res.push_back(s);\n        return res;\n    }\n\nNote how `>>` and `!=` are provided for `string` (as examples of useful operations) and there are no explicit\nallocations, deallocations, or range checks (`string` takes care of those).\n\nIn C++17, we might use `string_view` as the argument, rather than `const string&` to allow more flexibility to callers:\n\n    vector<string> read_until(string_view terminator)   // C++17\n    {\n        vector<string> res;\n        for (string s; cin >> s && s != terminator; ) // read a word\n            res.push_back(s);\n        return res;\n    }\n\n##### Example, bad\n\nDon't use C-style strings for operations that require non-trivial memory management\n\n    char* cat(const char* s1, const char* s2)   // beware!\n        // return s1 + '.' + s2\n    {\n        int l1 = strlen(s1);\n        int l2 = strlen(s2);\n        char* p = (char*) malloc(l1 + l2 + 2);\n        strcpy(p, s1, l1);\n        p[l1] = '.';\n        strcpy(p + l1 + 1, s2, l2);\n        p[l1 + l2 + 1] = 0;\n        return p;\n    }\n\nDid we get that right?\nWill the caller remember to `free()` the returned pointer?\nWill this code pass a security review?\n\n##### Note\n\nDo not assume that `string` is slower than lower-level techniques without measurement and remember that not all code is performance critical.\n[Don't optimize prematurely](#rper-knuth)\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rstr-view\"></a>SL.str.2: Use `std::string_view` or `gsl::span<char>` to refer to character sequences",
    "content": "### <a name=\"rstr-view\"></a>SL.str.2: Use `std::string_view` or `gsl::span<char>` to refer to character sequences\n\n##### Reason\n\n`std::string_view` or `gsl::span<char>` provides simple and (potentially) safe access to character sequences independently of how\nthose sequences are allocated and stored.\n\n##### Example\n\n    vector<string> read_until(string_view terminator);\n\n    void user(zstring p, const string& s, string_view ss)\n    {\n        auto v1 = read_until(p);\n        auto v2 = read_until(s);\n        auto v3 = read_until(ss);\n        // ...\n    }\n\n##### Note\n\n`std::string_view` (C++17) is read-only.\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rstr-zstring\"></a>SL.str.3: Use `zstring` or `czstring` to refer to a C-style, zero-terminated, sequence of characters",
    "content": "### <a name=\"rstr-zstring\"></a>SL.str.3: Use `zstring` or `czstring` to refer to a C-style, zero-terminated, sequence of characters\n\n##### Reason\n\nReadability.\nStatement of intent.\nA plain `char*` can be a pointer to a single character, a pointer to an array of characters, a pointer to a C-style (zero-terminated) string, or even to a small integer.\nDistinguishing these alternatives prevents misunderstandings and bugs.\n\n##### Example\n\n    void f1(const char* s); // s is probably a string\n\nAll we know is that it is supposed to be the nullptr or point to at least one character\n\n    void f1(zstring s);     // s is a C-style string or the nullptr\n    void f1(czstring s);    // s is a C-style string constant or the nullptr\n    void f1(std::byte* s);  // s is a pointer to a byte (C++17)\n\n##### Note\n\nDon't convert a C-style string to `string` unless there is a reason to.\n\n##### Note\n\nLike any other \"plain pointer\", a `zstring` should not represent ownership.\n\n##### Note\n\nThere are billions of lines of C++ \"out there\", most use `char*` and `const char*` without documenting intent.\nThey are used in a wide variety of ways, including to represent ownership and as generic pointers to memory (instead of `void*`).\nIt is hard to separate these uses, so this guideline is hard to follow.\nThis is one of the major sources of bugs in C and C++ programs, so it is worthwhile to follow this guideline wherever feasible.\n\n##### Enforcement\n\n* Flag uses of `[]` on a `char*`\n* Flag uses of `delete` on a `char*`\n* Flag uses of `free()` on a `char*`\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rstr-charp\"></a>SL.str.4: Use `char*` to refer to a single character",
    "content": "### <a name=\"rstr-charp\"></a>SL.str.4: Use `char*` to refer to a single character\n\n##### Reason\n\nThe variety of uses of `char*` in current code is a major source of errors.\n\n##### Example, bad\n\n    char arr[] = {'a', 'b', 'c'};\n\n    void print(const char* p)\n    {\n        cout << p << '\\n';\n    }\n\n    void use()\n    {\n        print(arr);   // run-time error; potentially very bad\n    }\n\nThe array `arr` is not a C-style string because it is not zero-terminated.\n\n##### Alternative\n\nSee [`zstring`](#rstr-zstring), [`string`](#rstr-string), and [`string_view`](#rstr-view).\n\n##### Enforcement\n\n* Flag uses of `[]` on a `char*`\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rstr-byte\"></a>SL.str.5: Use `std::byte` to refer to byte values that do not necessarily represent characters",
    "content": "### <a name=\"rstr-byte\"></a>SL.str.5: Use `std::byte` to refer to byte values that do not necessarily represent characters\n\n##### Reason\n\nUse of `char*` to represent a pointer to something that is not necessarily a character causes confusion\nand disables valuable optimizations.\n\n##### Example\n\n    ???\n\n##### Note\n\nC++17\n\n##### Enforcement\n\n???\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rstr-locale\"></a>SL.str.10: Use `std::string` when you need to perform locale-sensitive string operations",
    "content": "### <a name=\"rstr-locale\"></a>SL.str.10: Use `std::string` when you need to perform locale-sensitive string operations\n\n##### Reason\n\n`std::string` supports standard-library [`locale` facilities](#rstr-locale)\n\n##### Example\n\n    ???\n\n##### Note\n\n???\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rstr-span\"></a>SL.str.11: Use `gsl::span<char>` rather than `std::string_view` when you need to mutate a string",
    "content": "### <a name=\"rstr-span\"></a>SL.str.11: Use `gsl::span<char>` rather than `std::string_view` when you need to mutate a string\n\n##### Reason\n\n`std::string_view` is read-only.\n\n##### Example\n\n???\n\n##### Note\n\n???\n\n##### Enforcement\n\nThe compiler will flag attempts to write to a `string_view`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rstr-s\"></a>SL.str.12: Use the `s` suffix for string literals meant to be standard-library `string`s",
    "content": "### <a name=\"rstr-s\"></a>SL.str.12: Use the `s` suffix for string literals meant to be standard-library `string`s\n\n##### Reason\n\nDirect expression of an idea minimizes mistakes.\n\n##### Example\n\n    auto pp1 = make_pair(\"Tokyo\", 9.00);         // {C-style string,double} intended?\n    pair<string, double> pp2 = {\"Tokyo\", 9.00};  // a bit verbose\n    auto pp3 = make_pair(\"Tokyo\"s, 9.00);        // {std::string,double}    // C++14\n    pair pp4 = {\"Tokyo\"s, 9.00};                 // {std::string,double}    // C++17\n\n\n\n##### Enforcement\n\n???\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-io\"></a>SL.io: Iostream",
    "content": "## <a name=\"ss-io\"></a>SL.io: Iostream\n\n`iostream`s is a type safe, extensible, formatted and unformatted I/O library for streaming I/O.\nIt supports multiple (and user extensible) buffering strategies and multiple locales.\nIt can be used for conventional I/O, reading and writing to memory (string streams),\nand user-defined extensions, such as streaming across networks (asio: not yet standardized).\n\nIostream rule summary:\n\n* [SL.io.1: Use character-level input only when you have to](#rio-low)\n* [SL.io.2: When reading, always consider ill-formed input](#rio-validate)\n* [SL.io.3: Prefer iostreams for I/O](#rio-streams)\n* [SL.io.10: Unless you use `printf`-family functions call `ios_base::sync_with_stdio(false)`](#rio-sync)\n* [SL.io.50: Avoid `endl`](#rio-endl)\n* [???](#???)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rio-low\"></a>SL.io.1: Use character-level input only when you have to",
    "content": "### <a name=\"rio-low\"></a>SL.io.1: Use character-level input only when you have to\n\n##### Reason\n\nUnless you genuinely just deal with individual characters, using character-level input leads to the user code performing potentially error-prone\nand potentially inefficient composition of tokens out of characters.\n\n##### Example\n\n    char c;\n    char buf[128];\n    int i = 0;\n    while (cin.get(c) && !isspace(c) && i < 128)\n        buf[i++] = c;\n    if (i == 128) {\n        // ... handle too long string ....\n    }\n\nBetter (much simpler and probably faster):\n\n    string s;\n    s.reserve(128);\n    cin >> s;\n\nand the `reserve(128)` is probably not worthwhile.\n\n##### Enforcement\n\n???\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rio-validate\"></a>SL.io.2: When reading, always consider ill-formed input",
    "content": "### <a name=\"rio-validate\"></a>SL.io.2: When reading, always consider ill-formed input\n\n##### Reason\n\nErrors are typically best handled as soon as possible.\nIf input isn't validated, every function must be written to cope with bad data (and that is not practical).\n\n##### Example\n\n    ???\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rio-streams\"></a>SL.io.3: Prefer `iostream`s for I/O",
    "content": "### <a name=\"rio-streams\"></a>SL.io.3: Prefer `iostream`s for I/O\n\n##### Reason\n\n`iostream`s are safe, flexible, and extensible.\n\n##### Example\n\n    // write a complex number:\n    complex<double> z{ 3, 4 };\n    cout << z << '\\n';\n\n`complex` is a user-defined type and its I/O is defined without modifying the `iostream` library.\n\n##### Example\n\n    // read a file of complex numbers:\n    for (complex<double> z; cin >> z; )\n        v.push_back(z);\n\n##### Exception\n\n??? performance ???\n\n##### Discussion: `iostream`s vs. the `printf()` family\n\nIt is often (and often correctly) pointed out that the `printf()` family has two advantages compared to `iostream`s:\nflexibility of formatting and performance.\nThis has to be weighed against `iostream`s advantages of extensibility to handle user-defined types, resilience against security violations,\nimplicit memory management, and `locale` handling.\n\nIf you need I/O performance, you can almost always do better than `printf()`.\n\n`gets()`, `scanf()` using `%s`, and `printf()` using `%s` are security hazards (vulnerable to buffer overflow and generally error-prone).\nC11 defines some \"optional extensions\" that do extra checking of their arguments.\nIf present in your C library, `gets_s()`, `scanf_s()`, and `printf_s()` might be safer alternatives, but they are still not type safe.\n\n##### Enforcement\n\nOptionally flag `<cstdio>` and `<stdio.h>`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rio-sync\"></a>SL.io.10: Unless you use `printf`-family functions call `ios_base::sync_with_stdio(false)`",
    "content": "### <a name=\"rio-sync\"></a>SL.io.10: Unless you use `printf`-family functions call `ios_base::sync_with_stdio(false)`\n\n##### Reason\n\nSynchronizing `iostreams` with `printf-style` I/O can be costly.\n`cin` and `cout` are by default synchronized with `printf`.\n\n##### Example\n\n    int main()\n    {\n        ios_base::sync_with_stdio(false);\n        // ... use iostreams ...\n    }\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rio-endl\"></a>SL.io.50: Avoid `endl`",
    "content": "### <a name=\"rio-endl\"></a>SL.io.50: Avoid `endl`\n\n##### Reason\n\nThe `endl` manipulator is mostly equivalent to `'\\n'` and `\"\\n\"`;\nas most commonly used it simply slows down output by doing redundant `flush()`s.\nThis slowdown can be significant compared to `printf`-style output.\n\n##### Example\n\n    cout << \"Hello, World!\" << endl;    // two output operations and a flush\n    cout << \"Hello, World!\\n\";          // one output operation and no flush\n\n##### Note\n\nFor `cin`/`cout` (and equivalent) interaction, there is no reason to flush; that's done automatically.\nFor writing to a file, there is rarely a need to `flush`.\n\n##### Note\n\nFor string streams (specifically `ostringstream`), the insertion of an `endl` is entirely equivalent\nto the insertion of a `'\\n'` character, but also in this case, `endl` might be significantly slower.\n\n`endl` does *not* take care of producing a platform specific end-of-line sequence (like `\"\\r\\n\"` on\nWindows). So for a string stream, `s << endl` just inserts a *single* character, `'\\n'`.\n\n##### Note\n\nApart from the (occasionally important) issue of performance,\nthe choice between `'\\n'` and `endl` is almost completely aesthetic.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-regex\"></a>SL.regex: Regex",
    "content": "## <a name=\"ss-regex\"></a>SL.regex: Regex\n\n`<regex>` is the standard C++ regular expression library.\nIt supports a variety of regular expression pattern conventions.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-chrono\"></a>SL.chrono: Time",
    "content": "## <a name=\"ss-chrono\"></a>SL.chrono: Time\n\n`<chrono>` (defined in namespace `std::chrono`) provides the notions of `time_point` and `duration` together with functions for\noutputting time in various units.\nIt provides clocks for registering `time_points`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-clib\"></a>SL.C: The C Standard Library",
    "content": "## <a name=\"ss-clib\"></a>SL.C: The C Standard Library\n\n???\n\nC Standard Library rule summary:\n\n* [SL.C.1: Don't use setjmp/longjmp](#rclib-jmp)\n* [???](#???)\n* [???](#???)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rclib-jmp\"></a>SL.C.1: Don't use setjmp/longjmp",
    "content": "### <a name=\"rclib-jmp\"></a>SL.C.1: Don't use setjmp/longjmp\n\n##### Reason\n\na `longjmp` ignores destructors, thus invalidating all resource-management strategies relying on RAII\n\n##### Enforcement\n\nFlag all occurrences of `longjmp`and `setjmp`\n\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-a\"></a>A: Architectural ideas",
    "content": "# <a name=\"s-a\"></a>A: Architectural ideas\n\nThis section contains ideas about higher-level architectural ideas and libraries.\n\nArchitectural rule summary:\n\n* [A.1: Separate stable code from less stable code](#ra-stable)\n* [A.2: Express potentially reusable parts as a library](#ra-lib)\n* [A.4: There should be no cycles among libraries](#ra-dag)\n* [???](#???)\n* [???](#???)\n* [???](#???)\n* [???](#???)\n* [???](#???)\n* [???](#???)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ra-stable\"></a>A.1: Separate stable code from less stable code",
    "content": "### <a name=\"ra-stable\"></a>A.1: Separate stable code from less stable code\n\nIsolating less stable code facilitates its unit testing, interface improvement, refactoring, and eventual deprecation.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ra-lib\"></a>A.2: Express potentially reusable parts as a library",
    "content": "### <a name=\"ra-lib\"></a>A.2: Express potentially reusable parts as a library\n\n##### Reason\n\n##### Note\n\nA library is a collection of declarations and definitions maintained, documented, and shipped together.\nA library could be a set of headers (a \"header-only library\") or a set of headers plus a set of object files.\nYou can statically or dynamically link a library into a program, or you can `#include` a header-only library.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ra-dag\"></a>A.4: There should be no cycles among libraries",
    "content": "### <a name=\"ra-dag\"></a>A.4: There should be no cycles among libraries\n\n##### Reason\n\n* A cycle complicates the build process.\n* Cycles are hard to understand and might introduce indeterminism (unspecified behavior).\n\n##### Note\n\nA library can contain cyclic references in the definition of its components.\nFor example:\n\n    ???\n\nHowever, a library should not depend on another that depends on it.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-not\"></a>NR: Non-Rules and myths",
    "content": "# <a name=\"s-not\"></a>NR: Non-Rules and myths\n\nThis section contains rules and guidelines that are popular somewhere, but that we deliberately don't recommend.\nWe know perfectly well that there have been times and places where these rules made sense, and we have used them ourselves at times.\nHowever, in the context of the styles of programming we recommend and support with the guidelines, these \"non-rules\" would do harm.\n\nEven today, there can be contexts where the rules make sense.\nFor example, lack of suitable tool support can make exceptions unsuitable in hard-real-time systems,\nbut please don't navely trust \"common wisdom\" (e.g., unsupported statements about \"efficiency\");\nsuch \"wisdom\" might be based on decades-old information or experiences from languages with very different properties than C++\n(e.g., C or Java).\n\nThe positive arguments for alternatives to these non-rules are listed in the rules offered as \"Alternatives\".\n\nNon-rule summary:\n\n* [NR.1: Don't insist that all declarations should be at the top of a function](#rnr-top)\n* [NR.2: Don't insist on having only a single `return`-statement in a function](#rnr-single-return)\n* [NR.3: Don't avoid exceptions](#rnr-no-exceptions)\n* [NR.4: Don't insist on placing each class definition in its own source file](#rnr-lots-of-files)\n* [NR.5: Don't use two-phase initialization](#rnr-two-phase-init)\n* [NR.6: Don't place all cleanup actions at the end of a function and `goto exit`](#rnr-goto-exit)\n* [NR.7: Don't make data members `protected`](#rnr-protected-data)\n* ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rnr-top\"></a>NR.1: Don't insist that all declarations should be at the top of a function",
    "content": "### <a name=\"rnr-top\"></a>NR.1: Don't insist that all declarations should be at the top of a function\n\n##### Reason\n\nThe \"all declarations on top\" rule is a legacy of old programming languages that didn't allow initialization of variables and constants after a statement.\nThis leads to longer programs and more errors caused by uninitialized and wrongly initialized variables.\n\n##### Example, bad\n\n    int use(int x)\n    {\n        int i;\n        char c;\n        double d;\n\n        // ... some stuff ...\n\n        if (x < i) {\n            // ...\n            i = f(x, d);\n        }\n        if (i < x) {\n            // ...\n            i = g(x, c);\n        }\n        return i;\n    }\n\nThe larger the distance between the uninitialized variable and its use, the larger the chance of a bug.\nFortunately, compilers catch many \"used before set\" errors.\nUnfortunately, compilers cannot catch all such errors and unfortunately, the bugs aren't always as simple to spot as in this small example.\n\n\n##### Alternative\n\n* [Always initialize an object](#res-always)\n* [ES.21: Don't introduce a variable (or constant) before you need to use it](#res-introduce)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rnr-single-return\"></a>NR.2: Don't insist on having only a single `return`-statement in a function",
    "content": "### <a name=\"rnr-single-return\"></a>NR.2: Don't insist on having only a single `return`-statement in a function\n\n##### Reason\n\nThe single-return rule can lead to unnecessarily convoluted code and the introduction of extra state variables.\nIn particular, the single-return rule makes it harder to concentrate error checking at the top of a function.\n\n##### Example\n\n    template<class T>\n    //  requires Number<T>\n    string sign(T x)\n    {\n        if (x < 0)\n            return \"negative\";\n        if (x > 0)\n            return \"positive\";\n        return \"zero\";\n    }\n\nto use a single return only we would have to do something like\n\n    template<class T>\n    //  requires Number<T>\n    string sign(T x)        // bad\n    {\n        string res;\n        if (x < 0)\n            res = \"negative\";\n        else if (x > 0)\n            res = \"positive\";\n        else\n            res = \"zero\";\n        return res;\n    }\n\nThis is both longer and likely to be less efficient.\nThe larger and more complicated the function is, the more painful the workarounds get.\nOf course many simple functions will naturally have just one `return` because of their simpler inherent logic.\n\n##### Example\n\n    int index(const char* p)\n    {\n        if (!p) return -1;  // error indicator: alternatively \"throw nullptr_error{}\"\n        // ... do a lookup to find the index for p\n        return i;\n    }\n\nIf we applied the rule, we'd get something like\n\n    int index2(const char* p)\n    {\n        int i;\n        if (!p)\n            i = -1;  // error indicator\n        else {\n            // ... do a lookup to find the index for p\n        }\n        return i;\n    }\n\nNote that we (deliberately) violated the rule against uninitialized variables because this style commonly leads to that.\nAlso, this style is a temptation to use the [goto exit](#rnr-goto-exit) non-rule.\n\n##### Alternative\n\n* Keep functions short and simple\n* Feel free to use multiple `return` statements (and to throw exceptions).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rnr-no-exceptions\"></a>NR.3: Don't avoid exceptions",
    "content": "### <a name=\"rnr-no-exceptions\"></a>NR.3: Don't avoid exceptions\n\n##### Reason\n\nThere seem to be four main reasons given for not using exceptions:\n\n* exceptions are inefficient\n* exceptions lead to leaks and errors\n* exception performance is not predictable\n* the exception-handling run-time support takes up too much space\n\nThere is no way we can settle this issue to the satisfaction of everybody.\nAfter all, the discussions about exceptions have been going on for 40+ years.\nSome languages cannot be used without exceptions, but others do not support them.\nThis leads to strong traditions for the use and non-use of exceptions, and to heated debates.\n\nHowever, we can briefly outline why we consider exceptions the best alternative for general-purpose programming\nand in the context of these guidelines.\nSimple arguments for and against are often inconclusive.\nThere are specialized applications where exceptions indeed can be inappropriate\n(e.g., hard-real-time systems without support for reliable estimates of the cost of handling an exception).\n\nConsider the major objections to exceptions in turn\n\n* Exceptions are inefficient:\nCompared to what?\nWhen comparing make sure that the same set of errors are handled and that they are handled equivalently.\nIn particular, do not compare a program that immediately terminates on seeing an error to a program\nthat carefully cleans up resources before logging an error.\nYes, some systems have poor exception handling implementations; sometimes, such implementations force us to use\nother error-handling approaches, but that's not a fundamental problem with exceptions.\nWhen using an efficiency argument - in any context - be careful that you have good data that actually provides\ninsight into the problem under discussion.\n* Exceptions lead to leaks and errors.\nThey do not.\nIf your program is a rat's nest of pointers without an overall strategy for resource management,\nyou have a problem whatever you do.\nIf your system consists of a million lines of such code,\nyou probably will not be able to use exceptions,\nbut that's a problem with excessive and undisciplined pointer use, rather than with exceptions.\nIn our opinion, you need RAII to make exception-based error handling simple and safe -- simpler and safer than alternatives.\n* Exception performance is not predictable.\nIf you are in a hard-real-time system where you must guarantee completion of a task in a given time,\nyou need tools to back up such guarantees.\nAs far as we know such tools are not available (at least not to most programmers).\n* The exception-handling run-time support takes up too much space.\nThis can be the case in small (usually embedded) systems.\nHowever, before abandoning exceptions consider what space consistent error-handling using error-codes would require\nand what failure to catch an error would cost.\n\nMany, possibly most, problems with exceptions stem from historical needs to interact with messy old code.\n\nThe fundamental arguments for the use of exceptions are\n\n* They clearly differentiate between erroneous return and ordinary return\n* They cannot be forgotten or ignored\n* They can be used systematically\n\nRemember\n\n* Exceptions are for reporting errors (in C++; other languages can have different uses for exceptions).\n* Exceptions are not for errors that can be handled locally.\n* Don't try to catch every exception in every function (that's tedious, clumsy, and leads to slow code).\n* Exceptions are not for errors that require instant termination of a module/system after a non-recoverable error.\n\n##### Example\n\n    ???\n\n##### Alternative\n\n* [RAII](#re-raii)\n* Contracts/assertions: Use GSL's `Expects` and `Ensures` (until we get language support for contracts)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rnr-lots-of-files\"></a>NR.4: Don't insist on placing each class definition in its own source file",
    "content": "### <a name=\"rnr-lots-of-files\"></a>NR.4: Don't insist on placing each class definition in its own source file\n\n##### Reason\n\nThe resulting number of files from placing each class in its own file are hard to manage and can slow down compilation.\nIndividual classes are rarely a good logical unit of maintenance and distribution.\n\n##### Example\n\n    ???\n\n##### Alternative\n\n* Use namespaces containing logically cohesive sets of classes and functions.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rnr-two-phase-init\"></a>NR.5: Don't use two-phase initialization",
    "content": "### <a name=\"rnr-two-phase-init\"></a>NR.5: Don't use two-phase initialization\n\n##### Reason\n\nSplitting initialization into two leads to weaker invariants,\nmore complicated code (having to deal with semi-constructed objects),\nand errors (when we didn't deal correctly with semi-constructed objects consistently).\n\n##### Note\n\nSometimes also called two-stage construction.\n\n##### Example, bad\n\n    // Old conventional style: many problems\n\n    class Picture\n    {\n        int mx;\n        int my;\n        int * data;\n    public:\n        // main problem: constructor does not fully construct\n        Picture(int x, int y)\n        {\n            mx = x;         // also bad: assignment in constructor body\n                            // rather than in member initializer\n            my = y;\n            data = nullptr; // also bad: constant initialization in constructor\n                            // rather than in member initializer\n        }\n\n        ~Picture()\n        {\n            Cleanup();\n        }\n\n        // ...\n\n        // bad: two-phase initialization\n        bool Init()\n        {\n            // invariant checks\n            if (mx <= 0 || my <= 0) {\n                return false;\n            }\n            if (data) {\n                return false;\n            }\n            data = (int*) malloc(mx*my*sizeof(int));   // also bad: owning raw * and malloc\n            return data != nullptr;\n        }\n\n        // also bad: no reason to make cleanup a separate function\n        void Cleanup()\n        {\n            if (data) free(data);\n            data = nullptr;\n        }\n    };\n\n    Picture picture(100, 0); // not ready-to-use picture here\n    // this will fail..\n    if (!picture.Init()) {\n        puts(\"Error, invalid picture\");\n    }\n    // now have an invalid picture object instance.\n\n##### Example, good\n\n    class Picture\n    {\n        int mx;\n        int my;\n        vector<int> data;\n\n        static int check_size(int size)\n        {\n            // invariant check\n            Expects(size > 0);\n            return size;\n        }\n\n    public:\n        // even better would be a class for a 2D Size as one single parameter\n        Picture(int x, int y)\n            : mx(check_size(x))\n            , my(check_size(y))\n            // now we know x and y have a valid size\n            , data(mx * my) // will throw std::bad_alloc on error\n        {\n            // picture is ready-to-use\n        }\n\n        // compiler generated dtor does the job. (also see C.21)\n\n        // ...\n    };\n\n    Picture picture1(100, 100);\n    // picture1 is ready-to-use here...\n\n    // not a valid size for y,\n    // default contract violation behavior will call std::terminate then\n    Picture picture2(100, 0);\n    // not reach here...\n\n##### Alternative\n\n* Always establish a class invariant in a constructor.\n* Don't define an object before it is needed.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rnr-goto-exit\"></a>NR.6: Don't place all cleanup actions at the end of a function and `goto exit`",
    "content": "### <a name=\"rnr-goto-exit\"></a>NR.6: Don't place all cleanup actions at the end of a function and `goto exit`\n\n##### Reason\n\n`goto` is error-prone.\nThis technique is a pre-exception technique for RAII-like resource and error handling.\n\n##### Example, bad\n\n    void do_something(int n)\n    {\n        if (n < 100) goto exit;\n        // ...\n        int* p = (int*) malloc(n);\n        // ...\n        if (some_error) goto exit;\n        // ...\n    exit:\n        free(p);\n    }\n\nand spot the bug.\n\n##### Alternative\n\n* Use exceptions and [RAII](#re-raii)\n* for non-RAII resources, use [`finally`](#re-finally).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rnr-protected-data\"></a>NR.7: Don't make data members `protected`",
    "content": "### <a name=\"rnr-protected-data\"></a>NR.7: Don't make data members `protected`\n\n##### Reason\n\n`protected` data is a source of errors.\n`protected` data can be manipulated from an unbounded amount of code in various places.\n`protected` data is the class hierarchy equivalent to global data.\n\n##### Example\n\n    ???\n\n##### Alternative\n\n* [Avoid `protected` data](#rh-protected)\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-references\"></a>RF: References",
    "content": "# <a name=\"s-references\"></a>RF: References\n\nMany coding standards, rules, and guidelines have been written for C++, and especially for specialized uses of C++.\nMany\n\n* focus on lower-level issues, such as the spelling of identifiers\n* are written by C++ novices\n* see \"stopping programmers from doing unusual things\" as their primary aim\n* aim at portability across many compilers (some 10 years old)\n* are written to preserve decades old code bases\n* aim at a single application domain\n* are downright counterproductive\n* are ignored (must be ignored by programmers to get their work done well)\n\nA bad coding standard is worse than no coding standard.\nHowever an appropriate set of guidelines are much better than no standards: \"Form is liberating.\"\n\nWhy can't we just have a language that allows all we want and disallows all we don't want (\"a perfect language\")?\nFundamentally, because affordable languages (and their tool chains) also serve people with needs that differ from yours and serve more needs than you have today.\nAlso, your needs change over time and a general-purpose language is needed to allow you to adapt.\nA language that is ideal for today would be overly restrictive tomorrow.\n\nCoding guidelines adapt the use of a language to specific needs.\nThus, there cannot be a single coding style for everybody.\nWe expect different organizations to provide additions, typically with more restrictions and firmer style rules.\n\nReference sections:\n\n* [RF.rules: Coding rules](#ss-rules)\n* [RF.books: Books with coding guidelines](#ss-books)\n* [RF.C++: C++ Programming (C++11/C++14/C++17)](#ss-cplusplus)\n* [RF.web: Websites](#ss-web)\n* [RS.video: Videos about \"modern C++\"](#ss-vid)\n* [RF.man: Manuals](#ss-man)\n* [RF.core: Core Guidelines materials](#ss-core)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-rules\"></a>RF.rules: Coding rules",
    "content": "## <a name=\"ss-rules\"></a>RF.rules: Coding rules\n\n* [AUTOSAR Guidelines for the use of the C++14 language in critical and safety-related systems v22.11](https://www.autosar.org/fileadmin/standards/R22-11/AP/AUTOSAR_RS_CPP14Guidelines.pdf) (obsolete, replaced by [MISRA C++:2023](https://misra.org.uk/product/misra-cpp2023/))\n* [Boost Library Requirements and Guidelines](https://www.boost.org/development/requirements.html).\n  ???.\n* [Bloomberg: BDE C++ Coding](https://github.com/bloomberg/bde/wiki/CodingStandards.pdf).\n  Has a strong emphasis on code organization and layout.\n* Facebook: ???\n* [GCC Coding Conventions](https://gcc.gnu.org/codingconventions.html).\n  C++03 and (reasonably) a bit backwards looking.\n* [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html).\n  Geared toward C++17 and (also) older code bases. Google experts are now actively collaborating here on helping to improve these Guidelines, and hopefully to merge efforts so these can be a modern common set they could also recommend.\n* [JSF++: JOINT STRIKE FIGHTER AIR VEHICLE C++ CODING STANDARDS](https://www.stroustrup.com/JSF-AV-rules.pdf).\n  Document Number 2RDU00001 Rev C. December 2005.\n  For flight control software.\n  For hard-real-time.\n  This means that it is necessarily very restrictive (\"if the program fails somebody dies\").\n  For example, no free store allocation or deallocation is allowed to occur after the plane takes off (no memory overflow and no fragmentation allowed).\n  No exception is allowed to be used (because there was no available tool for guaranteeing that an exception would be handled within a fixed short time).\n  Libraries used have to have been approved for mission critical applications.\n  Any similarities to this set of guidelines are unsurprising because Bjarne Stroustrup was an author of JSF++.\n  Recommended, but note its very specific focus.\n* [MISRA C++:2023 Guidelines for the use C++17 in critical systems](https://misra.org.uk/product/misra-cpp2023/).\n* [Using C++ in Mozilla Code](https://firefox-source-docs.mozilla.org/code-quality/coding-style/using_cxx_in_firefox_code.html).\n  As the name indicates, this aims for portability across many (old) compilers.\n  As such, it is restrictive.\n* [Geosoft.no: C++ Programming Style Guidelines](https://geosoft.no/development/cppstyle.html).\n  ???.\n* [Possibility.com: C++ Coding Standard](https://www.possibility.com/Cpp/CppCodingStandard.html).\n  ???.\n* [SEI CERT: Secure C++ Coding Standard](https://wiki.sei.cmu.edu/confluence/x/Wnw-BQ).\n  A very nicely done set of rules (with examples and rationales) done for security-sensitive code.\n  Many of their rules apply generally.\n* [High Integrity C++ Coding Standard](https://www.codingstandard.com/).\n* [llvm](https://llvm.org/docs/CodingStandards.html).\n  Somewhat brief, based on C++14, and (not unreasonably) adjusted to its domain.\n* ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-books\"></a>RF.books: Books with coding guidelines",
    "content": "## <a name=\"ss-books\"></a>RF.books: Books with coding guidelines\n\n* [Meyers96](#Meyers96) Scott Meyers: *More Effective C++*. Addison-Wesley 1996.\n* [Meyers97](#Meyers97) Scott Meyers: *Effective C++, Second Edition*. Addison-Wesley 1997.\n* [Meyers01](#Meyers01) Scott Meyers: *Effective STL*. Addison-Wesley 2001.\n* [Meyers05](#Meyers05) Scott Meyers: *Effective C++, Third Edition*. Addison-Wesley 2005.\n* [Meyers15](#Meyers15) Scott Meyers: *Effective Modern C++*. O'Reilly 2015.\n* [SuttAlex05](#SuttAlex05) Sutter and Alexandrescu: *C++ Coding Standards*. Addison-Wesley 2005. More a set of meta-rules than a set of rules. Pre-C++11.\n* [Stroustrup05](#Stroustrup05) Bjarne Stroustrup: [A rationale for semantically enhanced library languages](https://www.stroustrup.com/SELLrationale.pdf).\n  LCSD05. October 2005.\n* [Stroustrup14](#Stroustrup05) Stroustrup: [A Tour of C++](https://www.stroustrup.com/Tour.html).\n  Addison-Wesley 2014.\n  Each chapter ends with an advice section consisting of a set of recommendations.\n* [Stroustrup13](#Stroustrup13) Stroustrup: [The C++ Programming Language (4th Edition)](https://www.stroustrup.com/4th.html).\n  Addison-Wesley 2013.\n  Each chapter ends with an advice section consisting of a set of recommendations.\n* Stroustrup: [Style Guide](https://www.stroustrup.com/Programming/PPP-style.pdf)\n  for [Programming: Principles and Practice using C++](https://www.stroustrup.com/programming.html).\n  Mostly low-level naming and layout rules.\n  Primarily a teaching tool.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-cplusplus\"></a>RF.C++: C++ Programming (C++11/C++14)",
    "content": "## <a name=\"ss-cplusplus\"></a>RF.C++: C++ Programming (C++11/C++14)\n\n* [TC++PL4](https://www.stroustrup.com/4th.html):\nA thorough description of the C++ language and standard libraries for experienced programmers.\n* [Tour++](https://www.stroustrup.com/Tour.html):\nAn overview of the C++ language and standard libraries for experienced programmers.\n* [Programming: Principles and Practice using C++](https://www.stroustrup.com/programming.html):\nA textbook for beginners and relative novices.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-web\"></a>RF.web: Websites",
    "content": "## <a name=\"ss-web\"></a>RF.web: Websites\n\n* [isocpp.org](https://isocpp.org)\n* [Bjarne Stroustrup's home pages](https://www.stroustrup.com)\n* [WG21](https://www.open-std.org/jtc1/sc22/wg21/)\n* [Boost](https://www.boost.org)<a name=\"Boost\"></a>\n* [Adobe open source](https://opensource.adobe.com/)\n* [Poco libraries](https://pocoproject.org/)\n* Sutter's Mill?\n* ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-vid\"></a>RS.video: Videos about \"modern C++\"",
    "content": "## <a name=\"ss-vid\"></a>RS.video: Videos about \"modern C++\"\n\n* Bjarne Stroustrup: [C++11 Style](https://learn.microsoft.com/en-us/shows/goingnative-2012/keynote-bjarne-stroustrup-cpp11-style). 2012.\n* Bjarne Stroustrup: [The Essence of C++: With Examples in C++84, C++98, C++11, andC++14](https://learn.microsoft.com/en-us/shows/goingnative-2013/opening-keynote-bjarne-stroustrup). 2013\n* All the talks from [CppCon &#8217;14](https://isocpp.org/blog/2014/11/cppcon-videos-c9)\n* Bjarne Stroustrup: [The essence of C++](https://www.youtube.com/watch?v=86xWVb4XIyE) at the University of Edinburgh. 2014.\n* Bjarne Stroustrup: [The Evolution of C++ Past, Present and Future](https://www.youtube.com/watch?v=_wzc7a3McOs). CppCon 2016 keynote.\n* Bjarne Stroustrup: [Make Simple Tasks Simple!](https://www.youtube.com/watch?v=nesCaocNjtQ). CppCon 2014 keynote.\n* Bjarne Stroustrup: [Writing Good C++14](https://www.youtube.com/watch?v=1OEu9C51K2A). CppCon 2015 keynote about the Core Guidelines.\n* Herb Sutter: [Writing Good C++14... By Default](https://www.youtube.com/watch?v=hEx5DNLWGgA). CppCon 2015 keynote about the Core Guidelines.\n* CppCon 15\n* ??? C++ Next\n* ??? Meting C++\n* ??? more ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-man\"></a>RF.man: Manuals",
    "content": "## <a name=\"ss-man\"></a>RF.man: Manuals\n\n* ISO C++ Standard C++11.\n* ISO C++ Standard C++14.\n* [ISO C++ Standard C++17](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4606.pdf). Committee Draft.\n* [Palo Alto \"Concepts\" TR](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf).\n* [ISO C++ Concepts TS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf).\n* [WG21 Ranges report](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf). Draft.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-core\"></a>RF.core: Core Guidelines materials",
    "content": "## <a name=\"ss-core\"></a>RF.core: Core Guidelines materials\n\nThis section contains materials that have been useful for presenting the core guidelines and the ideas behind them:\n\n* [Our documents directory](https://github.com/isocpp/CppCoreGuidelines/tree/master/docs)\n* Stroustrup, Sutter, and Dos Reis: [A brief introduction to C++'s model for type- and resource-safety](https://www.stroustrup.com/resource-model.pdf). A paper with lots of examples.\n* Sergey Zubkov: [a Core Guidelines talk](https://www.youtube.com/watch?v=DyLwdl_6vmU)\nand here are the [slides](https://www.slideshare.net/slideshow/c-core-guidelines-72335317/72335317). In Russian. 2017.\n* Neil MacIntosh: [The Guideline Support Library: One Year Later](https://www.youtube.com/watch?v=_GhNnCuaEjo). CppCon 2016.\n* Bjarne Stroustrup: [Writing Good C++14](https://www.youtube.com/watch?v=1OEu9C51K2A). CppCon 2015 keynote.\n* Herb Sutter: [Writing Good C++14... By Default](https://www.youtube.com/watch?v=hEx5DNLWGgA). CppCon 2015 keynote.\n* Peter Sommerlad: [C++ Core Guidelines - Modernize your C++ Code Base](https://www.youtube.com/watch?v=fQ926v4ZzAM). ACCU 2017.\n* Bjarne Stroustrup: [No Littering!](https://www.youtube.com/watch?v=01zI9kV4h8c). Bay Area ACCU 2016.\nIt gives some idea of the ambition level for the Core Guidelines.\n\nNote that slides for CppCon presentations are available (links with the posted videos).\n\nContributions to this list would be most welcome.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-ack\"></a>Acknowledgements",
    "content": "## <a name=\"ss-ack\"></a>Acknowledgements\n\nThanks to the many people who contributed rules, suggestions, supporting information, references, etc.:\n\n* Peter Juhl\n* Neil MacIntosh\n* Axel Naumann\n* Andrew Pardoe\n* Gabriel Dos Reis\n* Zhuang, Jiangang (Jeff)\n* Sergey Zubkov\n\nand see the contributor list on the github.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-profile\"></a>Pro: Profiles",
    "content": "# <a name=\"s-profile\"></a>Pro: Profiles\n\nIdeally, we would follow all of the guidelines.\nThat would give the cleanest, most regular, least error-prone, and often the fastest code.\nUnfortunately, that is usually impossible because we have to fit our code into large code bases and use existing libraries.\nOften, such code has been written over decades and does not follow these guidelines.\nWe must aim for [gradual adoption](#s-modernizing).\n\nWhatever strategy for gradual adoption we adopt, we need to be able to apply sets of related guidelines to address some set\nof problems first and leave the rest until later.\nA similar idea of \"related guidelines\" becomes important when some, but not all, guidelines are considered relevant to a code base\nor if a set of specialized guidelines is to be applied for a specialized application area.\nWe call such a set of related guidelines a \"profile\".\nWe aim for such a set of guidelines to be coherent so that they together help us reach a specific goal, such as \"absence of range errors\"\nor \"static type safety.\"\nEach profile is designed to eliminate a class of errors.\nEnforcement of \"random\" rules in isolation is more likely to be disruptive to a code base than delivering a definite improvement.\n\nA \"profile\" is a set of deterministic and portably enforceable subset of rules (i.e., restrictions) that are designed to achieve a specific guarantee.\n\"Deterministic\" means they require only local analysis and could be implemented in a compiler (though they don't need to be).\n\"Portably enforceable\" means they are like language rules, so programmers can count on different enforcement tools giving the same answer for the same code.\n\nCode written to be warning-free using such a language profile is considered to conform to the profile.\nConforming code is considered to be safe by construction with regard to the safety properties targeted by that profile.\nConforming code will not be the root cause of errors for that property,\nalthough such errors might be introduced into a program by other code, libraries or the external environment.\nA profile might also introduce additional library types to ease conformance and encourage correct code.\n\nProfiles summary:\n\n* [Pro.type: Type safety](#ss-type)\n* [Pro.bounds: Bounds safety](#ss-bounds)\n* [Pro.lifetime: Lifetime safety](#ss-lifetime)\n\nIn the future, we expect to define many more profiles and add more checks to existing profiles.\nCandidates include:\n\n* narrowing arithmetic promotions/conversions (likely part of a separate safe-arithmetic profile)\n* arithmetic cast from negative floating point to unsigned integral type (ditto)\n* selected undefined behavior: Start with Gabriel Dos Reis's UB list developed for the WG21 study group\n* selected unspecified behavior: Addressing portability concerns.\n* `const` violations: Mostly done by compilers already, but we can catch inappropriate casting and underuse of `const`.\n\nEnabling a profile is implementation defined; typically, it is set in the analysis tool used.\n\nTo suppress enforcement of a profile check, place a `suppress` annotation on a language contract. For example:\n\n    [[suppress(\"bounds\")]] char* raw_find(char* p, int n, char x)    // find x in p[0]..p[n - 1]\n    {\n        // ...\n    }\n\nNow `raw_find()` can scramble memory to its heart's content.\nObviously, suppression should be very rare.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-type\"></a>Pro.safety: Type-safety profile",
    "content": "## <a name=\"ss-type\"></a>Pro.safety: Type-safety profile\n\nThis profile makes it easier to construct code that uses types correctly and avoids inadvertent type punning.\nIt does so by focusing on removing the primary sources of type violations, including unsafe uses of casts and unions.\n\nFor the purposes of this section,\ntype-safety is defined to be the property that a variable is not used in a way that doesn't obey the rules for the type of its definition.\nMemory accessed as a type `T` should not be valid memory that actually contains an object of an unrelated type `U`.\nNote that the safety is intended to be complete when combined also with [Bounds safety](#ss-bounds) and [Lifetime safety](#ss-lifetime).\n\nAn implementation of this profile shall recognize the following patterns in source code as non-conforming and issue a diagnostic.\n\nType safety profile summary:\n\n* <a name=\"pro-type-avoidcasts\"></a>Type.1: [Avoid casts](#res-casts):\n\n  1. <a name=\"pro-type-reinterpretcast\"></a>Don't use `reinterpret_cast`; A strict version of [Avoid casts](#res-casts) and [prefer named casts](#res-casts-named).\n  2. <a name=\"pro-type-arithmeticcast\"></a>Don't use `static_cast` for arithmetic types; A strict version of [Avoid casts](#res-casts) and [prefer named casts](#res-casts-named).\n  3. <a name=\"pro-type-identitycast\"></a>Don't cast between pointer types where the source type and the target type are the same; A strict version of [Avoid casts](#res-casts).\n  4. <a name=\"pro-type-implicitpointercast\"></a>Don't cast between pointer types when the conversion could be implicit; A strict version of [Avoid casts](#res-casts).\n* <a name=\"pro-type-downcast\"></a>Type.2: Don't use `static_cast` to downcast:\n[Use `dynamic_cast` instead](#rh-dynamic_cast).\n* <a name=\"pro-type-constcast\"></a>Type.3: Don't use `const_cast` to cast away `const` (i.e., at all):\n[Don't cast away const](#res-casts-const).\n* <a name=\"pro-type-cstylecast\"></a>Type.4: Don't use C-style `(T)expression` or functional `T(expression)` casts:\nPrefer [construction](#res-construct) or [named casts](#res-casts-named) or `T{expression}`.\n* <a name=\"pro-type-init\"></a>Type.5: Don't use a variable before it has been initialized:\n[always initialize](#res-always).\n* <a name=\"pro-type-memberinit\"></a>Type.6: Always initialize a data member:\n[always initialize](#res-always),\npossibly using [default constructors](#rc-default0) or\n[default member initializers](#rc-in-class-initializer).\n* <a name=\"pro-type-union\"></a>Type.7: Avoid naked union:\n[Use `variant` instead](#ru-naked).\n* <a name=\"pro-type-varargs\"></a>Type.8: Avoid varargs:\n[Don't use `va_arg` arguments](#f-varargs).\n\n##### Impact\n\nWith the type-safety profile you can trust that every operation is applied to a valid object.\nAn exception can be thrown to indicate errors that cannot be detected statically (at compile time).\nNote that this type-safety can be complete only if we also have [Bounds safety](#ss-bounds) and [Lifetime safety](#ss-lifetime).\nWithout those guarantees, a region of memory could be accessed independent of which object, objects, or parts of objects are stored in it.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-bounds\"></a>Pro.bounds: Bounds safety profile",
    "content": "## <a name=\"ss-bounds\"></a>Pro.bounds: Bounds safety profile\n\nThis profile makes it easier to construct code that operates within the bounds of allocated blocks of memory.\nIt does so by focusing on removing the primary sources of bounds violations: pointer arithmetic and array indexing.\nOne of the core features of this profile is to restrict pointers to only refer to single objects, not arrays.\n\nWe define bounds-safety to be the property that a program does not use an object to access memory outside of the range that was allocated for it.\nBounds safety is intended to be complete only when combined with [Type safety](#ss-type) and [Lifetime safety](#ss-lifetime),\nwhich cover other unsafe operations that allow bounds violations.\n\nBounds safety profile summary:\n\n* <a name=\"pro-bounds-arithmetic\"></a>Bounds.1: Don't use pointer arithmetic. Use `span` instead:\n[Pass pointers to single objects (only)](#ri-array) and [Keep pointer arithmetic simple](#res-ptr).\n* <a name=\"pro-bounds-arrayindex\"></a>Bounds.2: Only index into arrays using constant expressions:\n[Pass pointers to single objects (only)](#ri-array) and [Keep pointer arithmetic simple](#res-ptr).\n* <a name=\"pro-bounds-decay\"></a>Bounds.3: No array-to-pointer decay:\n[Pass pointers to single objects (only)](#ri-array) and [Keep pointer arithmetic simple](#res-ptr).\n* <a name=\"pro-bounds-stdlib\"></a>Bounds.4: Don't use standard-library functions and types that are not bounds-checked:\n[Use the standard library in a type-safe manner](#rsl-bounds).\n\n##### Impact\n\nBounds safety implies that access to an object - notably arrays - does not access beyond the object's memory allocation.\nThis eliminates a large class of insidious and hard-to-find errors, including the (in)famous \"buffer overflow\" errors.\nThis closes security loopholes as well as a prominent source of memory corruption (when writing out of bounds).\nEven if an out-of-bounds access is \"just a read\", it can lead to invariant violations (when the accessed isn't of the assumed type)\nand \"mysterious values.\"\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-lifetime\"></a>Pro.lifetime: Lifetime safety profile",
    "content": "## <a name=\"ss-lifetime\"></a>Pro.lifetime: Lifetime safety profile\n\nAccessing through a pointer that doesn't point to anything is a major source of errors,\nand very hard to avoid in many traditional C or C++ styles of programming.\nFor example, a pointer might be uninitialized, the `nullptr`, point beyond the range of an array, or to a deleted object.\n\n[See the current design specification here.](https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Lifetime.pdf)\n\nLifetime safety profile summary:\n\n* <a name=\"pro-lifetime-invalid-deref\"></a>Lifetime.1: Don't dereference a possibly invalid pointer:\n[detect or avoid](#res-deref).\n\n##### Impact\n\nOnce completely enforced through a combination of style rules, static analysis, and library support, this profile\n\n* eliminates one of the major sources of nasty errors in C++\n* eliminates a major source of potential security violations\n* improves performance by eliminating redundant \"paranoia\" checks\n* increases confidence in correctness of code\n* avoids undefined behavior by enforcing a key C++ language rule\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-gsl\"></a>GSL: Guidelines support library",
    "content": "# <a name=\"s-gsl\"></a>GSL: Guidelines support library\n\nThe GSL is a small library of facilities designed to support this set of guidelines.\nWithout these facilities, the guidelines would have to be far more restrictive on language details.\n\nThe Core Guidelines support library is defined in namespace `gsl` and the names might be aliases for standard library or other well-known library names. Using the (compile-time) indirection through the `gsl` namespace allows for experimentation and for local variants of the support facilities.\n\nThe GSL is header only, and can be found at [GSL: Guidelines support library](https://github.com/Microsoft/GSL).\nThe support library facilities are designed to be extremely lightweight (zero-overhead) so that they impose no overhead compared to using conventional alternatives.\nWhere desirable, they can be \"instrumented\" with additional functionality (e.g., checks) for tasks such as debugging.\n\nThese Guidelines use types from the standard (e.g., C++17) in addition to ones from the GSL.\nFor example, we assume a `variant` type, but this is not currently in GSL.\nEventually, use [the one voted into C++17](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0088r3.html).\n\nSome of the GSL types listed below might not be supported in the library you use due to technical reasons such as limitations in the current versions of C++.\nTherefore, please consult your GSL documentation to find out more.\n\nFor each GSL type below we state an invariant for that type. That invariant holds as long as user code only changes the state of a GSL object using the type's provided member/free functions (i.e., user code does not bypass the type's interface to change the object's value/bits by violating any other Guidelines rule).\n\nSummary of GSL components:\n\n* [GSL.view: Views](#ss-views)\n* [GSL.owner: Ownership pointers](#ss-ownership)\n* [GSL.assert: Assertions](#ss-assertions)\n* [GSL.util: Utilities](#ss-utilities)\n* [GSL.concept: Concepts](#ss-gsl-concepts)\n\nWe plan for a \"ISO C++ standard style\" semi-formal specification of the GSL.\n\nWe rely on the ISO C++ Standard Library and hope for parts of the GSL to be absorbed into the standard library.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-views\"></a>GSL.view: Views",
    "content": "## <a name=\"ss-views\"></a>GSL.view: Views\n\nThese types allow the user to distinguish between owning and non-owning pointers and between pointers to a single object and pointers to the first element of a sequence.\n\nThese \"views\" are never owners.\n\nReferences are never owners (see [R.4](#rr-ref)). Note: References have many opportunities to outlive the objects they refer to (returning a local variable by reference, holding a reference to an element of a vector and doing `push_back`, binding to `std::max(x, y + 1)`, etc). The Lifetime safety profile aims to address those things, but even so `owner<T&>` does not make sense and is discouraged.\n\nThe names are mostly ISO standard-library style (lower case and underscore):\n\n* `T*`      // The `T*` is not an owner, might be null; assumed to be pointing to a single element.\n* `T&`      // The `T&` is not an owner and can never be a \"null reference\"; references are always bound to objects.\n\nThe \"raw-pointer\" notation (e.g. `int*`) is assumed to have its most common meaning; that is, a pointer points to an object, but does not own it.\nOwners should be converted to resource handles (e.g., `unique_ptr` or `vector<T>`) or marked `owner<T*>`.\n\n* `owner<T*>`   // a `T*` that owns the object pointed/referred to; might be `nullptr`.\n\n`owner` is used to mark owning pointers in code that cannot be upgraded to use proper resource handles.\nReasons for that include:\n\n* Cost of conversion.\n* The pointer is used with an ABI.\n* The pointer is part of the implementation of a resource handle.\n\nAn `owner<T>` differs from a resource handle for a `T` by still requiring an explicit `delete`.\n\nAn `owner<T>` is assumed to refer to an object on the free store (heap).\n\nIf something is not supposed to be `nullptr`, say so:\n\n* `not_null<T>`   // `T` is usually a pointer type (e.g., `not_null<int*>` and `not_null<owner<Foo*>>`) that must not be `nullptr`.\n  `T` can be any type for which `==nullptr` is meaningful.\n\n* `span<T>`       // `[p:p+n)`, constructor from `{p, q}` and `{p, n}`; `T` is the pointer type\n* `span_p<T>`     // `{p, predicate}` `[p:q)` where `q` is the first element for which `predicate(*p)` is true\n\nA `span<T>` refers to zero or more mutable `T`s unless `T` is a `const` type. All accesses to elements of the span, notably via `operator[]`, are guaranteed to be bounds-checked by default.\n\n> Note: GSL's `span` (initially called `array_view`) was proposed for inclusion in the C++ standard library, and was adopted (with changes to its name and interface) except only that `std::span` does not provide for guaranteed bounds checking. Therefore GSL changed `span`'s name and interface to track `std::span` and should be exactly the same as `std::span`, and the only difference should be that GSL `span` is fully bounds-safe by default. If bounds-safety might affect its interface, then those change proposals should be brought back via the ISO C++ committee to keep `gsl::span` interface-compatible with `std::span`. If a future evolution of `std::span` adds bounds checking, `gsl::span` can be removed.\n\n\"Pointer arithmetic\" is best done within `span`s.\nA `char*` that points to more than one `char` but is not a C-style string (e.g., a pointer into an input buffer) should be represented by a `span`.\n\n* `zstring`    // a `char*` supposed to be a C-style string; that is, a zero-terminated sequence of `char` or `nullptr`\n* `czstring`   // a `const char*` supposed to be a C-style string; that is, a zero-terminated sequence of `const` `char` or `nullptr`\n\nLogically, those last two aliases are not needed, but we are not always logical, and they make the distinction between a pointer to one `char` and a pointer to a C-style string explicit.\nA sequence of characters that is not assumed to be zero-terminated should be a `span<char>`, or if that is impossible because of ABI issues a `char*`, rather than a `zstring`.\n\n\nUse `not_null<zstring>` for C-style strings that cannot be `nullptr`. ??? Do we need a name for `not_null<zstring>`? or is its ugliness a feature?\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-ownership\"></a>GSL.owner: Ownership pointers",
    "content": "## <a name=\"ss-ownership\"></a>GSL.owner: Ownership pointers\n\n* `unique_ptr<T>`     // unique ownership: `std::unique_ptr<T>`\n* `shared_ptr<T>`     // shared ownership: `std::shared_ptr<T>` (a counted pointer)\n* `stack_array<T>`    // A stack-allocated array. The number of elements is determined at construction and fixed thereafter. The elements are mutable unless `T` is a `const` type.\n* `dyn_array<T>`      // A container, non-growing dynamically allocated array. The number of elements is determined at construction and fixed thereafter.\n  The elements are mutable unless `T` is a `const` type. Basically a `span` that allocates and owns its elements.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-assertions\"></a>GSL.assert: Assertions",
    "content": "## <a name=\"ss-assertions\"></a>GSL.assert: Assertions\n\n* `Expects`     // precondition assertion. Currently placed in function bodies. Later, should be moved to declarations.\n                // `Expects(p)` terminates the program unless `p == true`\n                // `Expects` is under control of some options (enforcement, error message, alternatives to terminate)\n* `Ensures`     // postcondition assertion. Currently placed in function bodies. Later, should be moved to declarations.\n\nThese assertions are currently macros (yuck!) and must appear in function definitions (only)\npending standard committee decisions on contracts and assertion syntax.\nSee [the contract proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf); using the attribute syntax,\nfor example, `Expects(p)` will become `[[expects: p]]`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-utilities\"></a>GSL.util: Utilities",
    "content": "## <a name=\"ss-utilities\"></a>GSL.util: Utilities\n\n* `finally`        // `finally(f)` makes a `final_action{f}` with a destructor that invokes `f`\n* `narrow_cast`    // `narrow_cast<T>(x)` is `static_cast<T>(x)`\n* `narrow`         // `narrow<T>(x)` is `static_cast<T>(x)` if `static_cast<T>(x) == x` with no signedness promotions, or it throws `narrowing_error` (e.g., `narrow<unsigned>(-42)` throws)\n* `[[implicit]]`   // \"Marker\" to put on single-argument constructors to explicitly make them non-explicit.\n* `move_owner`     // `p = move_owner(q)` means `p = q` but ???\n* `joining_thread` // a RAII style version of `std::thread` that joins.\n* `index`          // a type to use for all container and array indexing (currently an alias for `ptrdiff_t`)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-gsl-concepts\"></a>GSL.concept: Concepts",
    "content": "## <a name=\"ss-gsl-concepts\"></a>GSL.concept: Concepts\n\nThese concepts (type predicates) are borrowed from\nAndrew Sutton's Origin library,\nthe Range proposal,\nand the ISO WG21 Palo Alto TR.\nMany of them are very similar to what became part of the ISO C++ standard in C++20.\n\n* `String`\n* `Number`\n* `Boolean`\n* `Range`              // in C++20, `std::ranges::range`\n* `Sortable`           // in C++20, `std::sortable`\n* `EqualityComparable` // in C++20, `std::equality_comparable`\n* `Convertible`        // in C++20, `std::convertible_to`\n* `Common`             // in C++20, `std::common_with`\n* `Integral`           // in C++20, `std::integral`\n* `SignedIntegral`     // in C++20, `std::signed_integral`\n* `SemiRegular`        // in C++20, `std::semiregular`\n* `Regular`            // in C++20, `std::regular`\n* `TotallyOrdered`     // in C++20, `std::totally_ordered`\n* `Function`           // in C++20, `std::invocable`\n* `RegularFunction`    // in C++20, `std::regular_invocable`\n* `Predicate`          // in C++20, `std::predicate`\n* `Relation`           // in C++20, `std::relation`\n* ...\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"ss-gsl-smartptrconcepts\"></a>GSL.ptr: Smart pointer concepts",
    "content": "### <a name=\"ss-gsl-smartptrconcepts\"></a>GSL.ptr: Smart pointer concepts\n\n* `Pointer`  // A type with `*`, `->`, `==`, and default construction (default construction is assumed to set the singular \"null\" value)\n* `Unique_pointer`  // A type that matches `Pointer`, is movable, and is not copyable\n* `Shared_pointer`   // A type that matches `Pointer`, and is copyable\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-naming\"></a>NL: Naming and layout suggestions",
    "content": "# <a name=\"s-naming\"></a>NL: Naming and layout suggestions\n\nConsistent naming and layout are helpful.\nIf for no other reason because it minimizes \"my style is better than your style\" arguments.\nHowever, there are many, many, different styles around and people are passionate about them (pro and con).\nAlso, most real-world projects include code from many sources, so standardizing on a single style for all code is often impossible.\nAfter many requests for guidance from users, we present a set of rules that you might use if you have no better ideas, but the real aim is consistency, rather than any particular rule set.\nIDEs and tools can help (as well as hinder).\n\nNaming and layout rules:\n\n* [NL.1: Don't say in comments what can be clearly stated in code](#rl-comments)\n* [NL.2: State intent in comments](#rl-comments-intent)\n* [NL.3: Keep comments crisp](#rl-comments-crisp)\n* [NL.4: Maintain a consistent indentation style](#rl-indent)\n* [NL.5: Avoid encoding type information in names](#rl-name-type)\n* [NL.7: Make the length of a name roughly proportional to the length of its scope](#rl-name-length)\n* [NL.8: Use a consistent naming style](#rl-name)\n* [NL.9: Use `ALL_CAPS` for macro names only](#rl-all-caps)\n* [NL.10: Prefer `underscore_style` names](#rl-camel)\n* [NL.11: Make literals readable](#rl-literals)\n* [NL.15: Use spaces sparingly](#rl-space)\n* [NL.16: Use a conventional class member declaration order](#rl-order)\n* [NL.17: Use K&R-derived layout](#rl-knr)\n* [NL.18: Use C++-style declarator layout](#rl-ptr)\n* [NL.19: Avoid names that are easily misread](#rl-misread)\n* [NL.20: Don't place two statements on the same line](#rl-stmt)\n* [NL.21: Declare one name (only) per declaration](#rl-dcl)\n* [NL.25: Don't use `void` as an argument type](#rl-void)\n* [NL.26: Use conventional `const` notation](#rl-const)\n* [NL.27: Use a `.cpp` suffix for code files and `.h` for interface files](#rl-file-suffix)\n\nMost of these rules are aesthetic and programmers hold strong opinions.\nIDEs also tend to have defaults and a range of alternatives.\nThese rules are suggested defaults to follow unless you have reasons not to.\n\nWe have had comments to the effect that naming and layout are so personal and/or arbitrary that we should not try to \"legislate\" them.\nWe are not \"legislating\" (see the previous paragraph).\nHowever, we have had many requests for a set of naming and layout conventions to use when there are no external constraints.\n\nMore specific and detailed rules are easier to enforce.\n\nThese rules bear a strong resemblance to the recommendations in the [PPP Style Guide](https://www.stroustrup.com/Programming/PPP-style.pdf)\nwritten in support of Stroustrup's [Programming: Principles and Practice using C++](https://www.stroustrup.com/programming.html).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rl-comments\"></a>NL.1: Don't say in comments what can be clearly stated in code",
    "content": "### <a name=\"rl-comments\"></a>NL.1: Don't say in comments what can be clearly stated in code\n\n##### Reason\n\nCompilers do not read comments.\nComments are less precise than code.\nComments are not updated as consistently as code.\n\n##### Example, bad\n\n    auto x = m * v1 + vv;   // multiply m with v1 and add the result to vv\n\n##### Enforcement\n\nBuild an AI program that interprets colloquial English text and see if what is said could be better expressed in C++.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rl-comments-intent\"></a>NL.2: State intent in comments",
    "content": "### <a name=\"rl-comments-intent\"></a>NL.2: State intent in comments\n\n##### Reason\n\nCode says what is done, not what is supposed to be done. Often intent can be stated more clearly and concisely than the implementation.\n\n##### Example\n\n    void stable_sort(Sortable& c)\n        // sort c in the order determined by <, keep equal elements (as defined by ==) in\n        // their original relative order\n    {\n        // ... quite a few lines of non-trivial code ...\n    }\n\n##### Note\n\nIf the comment and the code disagree, both are likely to be wrong.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rl-comments-crisp\"></a>NL.3: Keep comments crisp",
    "content": "### <a name=\"rl-comments-crisp\"></a>NL.3: Keep comments crisp\n\n##### Reason\n\nVerbosity slows down understanding and makes the code harder to read by spreading it around in the source file.\n\n##### Note\n\nUse intelligible English.\nI might be fluent in Danish, but most programmers are not; the maintainers of my code might not be.\nAvoid SMS lingo and watch your grammar, punctuation, and capitalization.\nAim for professionalism, not \"cool.\"\n\n##### Enforcement\n\nnot possible.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rl-indent\"></a>NL.4: Maintain a consistent indentation style",
    "content": "### <a name=\"rl-indent\"></a>NL.4: Maintain a consistent indentation style\n\n##### Reason\n\nReadability. Avoidance of \"silly mistakes.\"\n\n##### Example, bad\n\n    int i;\n    for (i = 0; i < max; ++i); // bug waiting to happen\n    if (i == j)\n        return i;\n\n##### Note\n\nAlways indenting the statement after `if (...)`, `for (...)`, and `while (...)` is usually a good idea:\n\n    if (i < 0) error(\"negative argument\");\n\n    if (i < 0)\n        error(\"negative argument\");\n\n##### Enforcement\n\nUse a tool.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rl-name-type\"></a>NL.5: Avoid encoding type information in names",
    "content": "### <a name=\"rl-name-type\"></a>NL.5: Avoid encoding type information in names\n\n##### Rationale\n\nIf names reflect types rather than functionality, it becomes hard to change the types used to provide that functionality.\nAlso, if the type of a variable is changed, code using it will have to be modified.\nMinimize unintentional conversions.\n\n##### Example, bad\n\n    void print_int(int i);\n    void print_string(const char*);\n\n    print_int(1);          // repetitive, manual type matching\n    print_string(\"xyzzy\"); // repetitive, manual type matching\n\n##### Example, good\n\n    void print(int i);\n    void print(string_view);    // also works on any string-like sequence\n\n    print(1);              // clear, automatic type matching\n    print(\"xyzzy\");        // clear, automatic type matching\n\n##### Note\n\nNames with types encoded are either verbose or cryptic.\n\n    printS  // print a std::string\n    prints  // print a C-style string\n    printi  // print an int\n\nRequiring techniques like Hungarian notation to encode a type has been used in untyped languages, but is generally unnecessary and actively harmful in a strongly statically-typed language like C++, because the annotations get out of date (the warts are just like comments and rot just like them) and they interfere with good use of the language (use the same name and overload resolution instead).\n\n##### Note\n\nSome styles use very general (not type-specific) prefixes to denote the general use of a variable.\n\n    auto p = new User();\n    auto p = make_unique<User>();\n    // note: \"p\" is not being used to say \"raw pointer to type User,\"\n    //       just generally to say \"this is an indirection\"\n\n    auto cntHits = calc_total_of_hits(/*...*/);\n    // note: \"cnt\" is not being used to encode a type,\n    //       just generally to say \"this is a count of something\"\n\nThis is not harmful and does not fall under this guideline because it does not encode type information.\n\n##### Note\n\nSome styles distinguish members from local variable, and/or from global variable.\n\n    struct S {\n        int m_;\n        S(int m) : m_{abs(m)} { }\n    };\n\nThis is not harmful and does not fall under this guideline because it does not encode type information.\n\n##### Note\n\nLike C++, some styles distinguish types from non-types.\nFor example, by capitalizing type names, but not the names of functions and variables.\n\n    typename<typename T>\n    class HashTable {   // maps string to T\n        // ...\n    };\n\n    HashTable<int> index;\n\nThis is not harmful and does not fall under this guideline because it does not encode type information.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rl-name-length\"></a>NL.7: Make the length of a name roughly proportional to the length of its scope",
    "content": "### <a name=\"rl-name-length\"></a>NL.7: Make the length of a name roughly proportional to the length of its scope\n\n**Rationale**: The larger the scope the greater the chance of confusion and of an unintended name clash.\n\n##### Example\n\n    double sqrt(double x);   // return the square root of x; x must be non-negative\n\n    int length(const char* p);  // return the number of characters in a zero-terminated C-style string\n\n    int length_of_string(const char zero_terminated_array_of_char[])    // bad: verbose\n\n    int g;      // bad: global variable with a cryptic name\n\n    int open;   // bad: global variable with a short, popular name\n\nThe use of `p` for pointer and `x` for a floating-point variable is conventional and non-confusing in a restricted scope.\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rl-name\"></a>NL.8: Use a consistent naming style",
    "content": "### <a name=\"rl-name\"></a>NL.8: Use a consistent naming style\n\n**Rationale**: Consistency in naming and naming style increases readability.\n\n##### Note\n\nThere are many styles and when you use multiple libraries, you can't follow all their different conventions.\nChoose a \"house style\", but leave \"imported\" libraries with their original style.\n\n##### Example\n\nISO Standard, use lower case only and digits, separate words with underscores:\n\n* `int`\n* `vector`\n* `my_map`\n\nAvoid identifier names that contain double underscores `__` or that start with an underscore followed by a capital letter (e.g., `_Throws`).\nSuch identifiers are reserved for the C++ implementation.\n\n##### Example\n\n[Stroustrup](https://www.stroustrup.com/Programming/PPP-style.pdf):\nISO Standard, but with upper case used for your own types and concepts:\n\n* `int`\n* `vector`\n* `My_map`\n\n##### Example\n\nCamelCase: capitalize each word in a multi-word identifier:\n\n* `int`\n* `vector`\n* `MyMap`\n* `myMap`\n\nSome conventions capitalize the first letter, some don't.\n\n##### Note\n\nTry to be consistent in your use of acronyms and lengths of identifiers:\n\n    int mtbf {12};\n    int mean_time_between_failures {12}; // make up your mind\n\n##### Enforcement\n\nWould be possible except for the use of libraries with varying conventions.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rl-all-caps\"></a>NL.9: Use `ALL_CAPS` for macro names only",
    "content": "### <a name=\"rl-all-caps\"></a>NL.9: Use `ALL_CAPS` for macro names only\n\n##### Reason\n\nTo avoid confusing macros with names that obey scope and type rules.\n\n##### Example\n\n    void f()\n    {\n        const int SIZE{1000};  // Bad, use 'size' instead\n        int v[SIZE];\n    }\n\n##### Note\n\nIn particular, this avoids confusing macros with non-macro symbolic constants (see also [Enum.5: Don't use `ALL_CAPS` for enumerators](#renum-caps))\n\n    enum bad { BAD, WORSE, HORRIBLE }; // BAD\n\n##### Enforcement\n\n* Flag macros with lower-case letters\n* Flag `ALL_CAPS` non-macro names\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rl-camel\"></a>NL.10: Prefer `underscore_style` names",
    "content": "### <a name=\"rl-camel\"></a>NL.10: Prefer `underscore_style` names\n\n##### Reason\n\nThe use of underscores to separate parts of a name is the original C and C++ style and used in the C++ Standard Library.\n\n##### Note\n\nThis rule is a default to use only if you have a choice.\nOften, you don't have a choice and must follow an established style for [consistency](#rl-name).\nThe need for consistency beats personal taste.\n\nThis is a recommendation for [when you have no constraints or better ideas](#s-naming).\nThis rule was added after many requests for guidance.\n\n##### Example\n\n[Stroustrup](https://www.stroustrup.com/Programming/PPP-style.pdf):\nISO Standard, but with upper case used for your own types and concepts:\n\n* `int`\n* `vector`\n* `My_map`\n\n##### Enforcement\n\nImpossible.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rl-literals\"></a>NL.11: Make literals readable",
    "content": "### <a name=\"rl-literals\"></a>NL.11: Make literals readable\n\n##### Reason\n\nReadability.\n\n##### Example\n\nUse digit separators to avoid long strings of digits\n\n    auto c = 299'792'458; // m/s2\n    auto q2 = 0b0000'1111'0000'0000;\n    auto ss_number = 123'456'7890;\n\n##### Example\n\nUse literal suffixes where clarification is needed\n\n    auto hello = \"Hello!\"s; // a std::string\n    auto world = \"world\";   // a C-style string\n    auto interval = 100ms;  // using <chrono>\n\n##### Note\n\nLiterals should not be sprinkled all over the code as [\"magic constants\"](#res-magic),\nbut it is still a good idea to make them readable where they are defined.\nIt is easy to make a typo in a long string of integers.\n\n##### Enforcement\n\nFlag long digit sequences. The trouble is to define \"long\"; maybe 7.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rl-space\"></a>NL.15: Use spaces sparingly",
    "content": "### <a name=\"rl-space\"></a>NL.15: Use spaces sparingly\n\n##### Reason\n\nToo much space makes the text larger and distracts.\n\n##### Example, bad\n\n    #include < map >\n\n    int main(int argc, char * argv [ ])\n    {\n        // ...\n    }\n\n##### Example\n\n    #include <map>\n\n    int main(int argc, char* argv[])\n    {\n        // ...\n    }\n\n##### Note\n\nSome IDEs have their own opinions and add distracting space.\n\nThis is a recommendation for [when you have no constraints or better ideas](#s-naming).\nThis rule was added after many requests for guidance.\n\n##### Note\n\nWe value well-placed whitespace as a significant help for readability. Just don't overdo it.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rl-order\"></a>NL.16: Use a conventional class member declaration order",
    "content": "### <a name=\"rl-order\"></a>NL.16: Use a conventional class member declaration order\n\n##### Reason\n\nA conventional order of members improves readability.\n\nWhen declaring a class use the following order\n\n* types: classes, enums, and aliases (`using`)\n* constructors, assignments, destructor\n* functions\n* data\n\nUse the `public` before `protected` before `private` order.\n\nThis is a recommendation for [when you have no constraints or better ideas](#s-naming).\nThis rule was added after many requests for guidance.\n\n##### Example\n\n    class X {\n    public:\n        // interface\n    protected:\n        // unchecked function for use by derived class implementations\n    private:\n        // implementation details\n    };\n\n##### Example\n\nSometimes, the default order of members conflicts with a desire to separate the public interface from implementation details.\nIn such cases, private types and functions can be placed with private data.\n\n    class X {\n    public:\n        // interface\n    protected:\n        // unchecked function for use by derived class implementations\n    private:\n        // implementation details (types, functions, and data)\n    };\n\n##### Example, bad\n\nAvoid multiple blocks of declarations of one access (e.g., `public`) dispersed among blocks of declarations with different access (e.g. `private`).\n\n    class X {   // bad\n    public:\n        void f();\n    public:\n        int g();\n        // ...\n    };\n\nThe use of macros to declare groups of members often leads to violation of any ordering rules.\nHowever, using macros obscures what is being expressed anyway.\n\n##### Enforcement\n\nFlag departures from the suggested order. There will be a lot of old code that doesn't follow this rule.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rl-knr\"></a>NL.17: Use K&R-derived layout",
    "content": "### <a name=\"rl-knr\"></a>NL.17: Use K&R-derived layout\n\n##### Reason\n\nThis is the original C and C++ layout. It preserves vertical space well. It distinguishes different language constructs (such as functions and classes) well.\n\n##### Note\n\nIn the context of C++, this style is often called \"Stroustrup\".\n\nThis is a recommendation for [when you have no constraints or better ideas](#s-naming).\nThis rule was added after many requests for guidance.\n\n##### Example\n\n    struct Cable {\n        int x;\n        // ...\n    };\n\n    double foo(int x)\n    {\n        if (0 < x) {\n            // ...\n        }\n\n        switch (x) {\n        case 0:\n            // ...\n            break;\n        case amazing:\n            // ...\n            break;\n        default:\n            // ...\n            break;\n        }\n\n        if (0 < x)\n            ++x;\n\n        if (x < 0)\n            something();\n        else\n            something_else();\n\n        return some_value;\n    }\n\nNote the space between `if` and `(`\n\n##### Note\n\nUse separate lines for each statement, the branches of an `if`, and the body of a `for`.\n\n##### Note\n\nThe `{` for a `class` and a `struct` is *not* on a separate line, but the `{` for a function is.\n\n##### Note\n\nCapitalize the names of your user-defined types to distinguish them from standards-library types.\n\n##### Note\n\nDo not capitalize function names.\n\n##### Enforcement\n\nIf you want enforcement, use an IDE to reformat.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rl-ptr\"></a>NL.18: Use C++-style declarator layout",
    "content": "### <a name=\"rl-ptr\"></a>NL.18: Use C++-style declarator layout\n\n##### Reason\n\nThe C-style layout emphasizes use in expressions and grammar, whereas the C++-style emphasizes types.\nThe use in expressions argument doesn't hold for references.\n\n##### Example\n\n    T& operator[](size_t);   // OK\n    T &operator[](size_t);   // just strange\n    T & operator[](size_t);   // undecided\n\n##### Note\n\nThis is a recommendation for [when you have no constraints or better ideas](#s-naming).\nThis rule was added after many requests for guidance.\n\n##### Enforcement\n\nImpossible in the face of history.\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rl-misread\"></a>NL.19: Avoid names that are easily misread",
    "content": "### <a name=\"rl-misread\"></a>NL.19: Avoid names that are easily misread\n\n##### Reason\n\nReadability.\nNot everyone has screens and printers that make it easy to distinguish all characters.\nWe easily confuse similarly spelled and slightly misspelled words.\n\n##### Example\n\n    int oO01lL = 6; // bad\n\n    int splunk = 7;\n    int splonk = 8; // bad: splunk and splonk are easily confused\n\n##### Enforcement\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rl-stmt\"></a>NL.20: Don't place two statements on the same line",
    "content": "### <a name=\"rl-stmt\"></a>NL.20: Don't place two statements on the same line\n\n##### Reason\n\nReadability.\nIt is really easy to overlook a statement when there is more on a line.\n\n##### Example\n\n    int x = 7; char* p = 29;    // don't\n    int x = 7; f(x);  ++x;      // don't\n\n##### Enforcement\n\nEasy.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rl-dcl\"></a>NL.21: Declare one name (only) per declaration",
    "content": "### <a name=\"rl-dcl\"></a>NL.21: Declare one name (only) per declaration\n\n##### Reason\n\nReadability.\nMinimizing confusion with the declarator syntax.\n\n##### Note\n\nFor details, see [ES.10](#res-name-one).\n\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rl-void\"></a>NL.25: Don't use `void` as an argument type",
    "content": "### <a name=\"rl-void\"></a>NL.25: Don't use `void` as an argument type\n\n##### Reason\n\nIt's verbose and only needed where C compatibility matters.\n\n##### Example\n\n    void f(void);   // bad\n\n    void g();       // better\n\n##### Note\n\nEven Dennis Ritchie deemed `void f(void)` an abomination.\nYou can make an argument for that abomination in C when function prototypes were rare so that banning:\n\n    int f();\n    f(1, 2, \"weird but valid C89\");   // hope that f() is defined int f(a, b, c) char* c; { /* ... */ }\n\nwould have caused major problems, but not in the 21st century and in C++.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rl-const\"></a>NL.26: Use conventional `const` notation",
    "content": "### <a name=\"rl-const\"></a>NL.26: Use conventional `const` notation\n\n##### Reason\n\nConventional notation is more familiar to more programmers.\nConsistency in large code bases.\n\n##### Example\n\n    const int x = 7;    // OK\n    int const y = 9;    // bad\n\n    const int *const p = nullptr;   // OK, constant pointer to constant int\n    int const *const p = nullptr;   // bad, constant pointer to constant int\n\n##### Note\n\nWe are well aware that you could claim the \"bad\" examples are more logical than the ones marked \"OK\",\nbut they also confuse more people, especially novices relying on teaching material using the far more common, conventional OK style.\n\nAs ever, remember that the aim of these naming and layout rules is consistency and that aesthetics vary immensely.\n\nThis is a recommendation for [when you have no constraints or better ideas](#s-naming).\nThis rule was added after many requests for guidance.\n\n##### Enforcement\n\nFlag `const` used as a suffix for a type.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"rl-file-suffix\"></a>NL.27: Use a `.cpp` suffix for code files and `.h` for interface files",
    "content": "### <a name=\"rl-file-suffix\"></a>NL.27: Use a `.cpp` suffix for code files and `.h` for interface files\n\n##### Reason\n\nIt's a longstanding convention.\nBut consistency is more important, so if your project uses something else, follow that.\n\n##### Note\n\nThis convention reflects a common use pattern:\nHeaders are more often shared with C to compile as both C++ and C, which typically uses `.h`,\nand it's easier to name all headers `.h` instead of having different extensions for just those headers that are intended to be shared with C.\nOn the other hand, implementation files are rarely shared with C and so should typically be distinguished from `.c` files,\nso it's normally best to name all C++ implementation files something else (such as `.cpp`).\n\nThe specific names `.h` and `.cpp` are not required (just recommended as a default) and other names are in widespread use.\nExamples are `.hh`, `.C`, and `.cxx`. Use such names equivalently.\nIn this document, we refer to `.h` and `.cpp` as a shorthand for header and implementation files,\neven though the actual extension might be different.\n\nYour IDE (if you use one) might have strong opinions about suffixes.\n\n##### Example\n\n    // foo.h:\n    extern int a;   // a declaration\n    extern void foo();\n\n    // foo.cpp:\n    int a;   // a definition\n    void foo() { ++a; }\n\n`foo.h` provides the interface to `foo.cpp`. Global variables are best avoided.\n\n##### Example, bad\n\n    // foo.h:\n    int a;   // a definition\n    void foo() { ++a; }\n\n`#include <foo.h>` twice in a program and you get a linker error for two one-definition-rule violations.\n\n##### Enforcement\n\n* Flag non-conventional file names.\n* Check that `.h` and `.cpp` (and equivalents) follow the rules below.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-faq\"></a>FAQ: Answers to frequently asked questions",
    "content": "# <a name=\"s-faq\"></a>FAQ: Answers to frequently asked questions\n\nThis section covers answers to frequently asked questions about these guidelines.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"faq-aims\"></a>FAQ.1: What do these guidelines aim to achieve?",
    "content": "### <a name=\"faq-aims\"></a>FAQ.1: What do these guidelines aim to achieve?\n\nSee the <a href=\"#s-abstract\">top of this page</a>. This is an open-source project to maintain modern authoritative guidelines for writing C++ code using the current C++ Standard. The guidelines are designed to be modern, machine-enforceable wherever possible, and open to contributions and forking so that organizations can easily incorporate them into their own corporate coding guidelines.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"faq-announced\"></a>FAQ.2: When and where was this work first announced?",
    "content": "### <a name=\"faq-announced\"></a>FAQ.2: When and where was this work first announced?\n\nIt was announced by [Bjarne Stroustrup in his CppCon 2015 opening keynote, \"Writing Good C++14\"](https://isocpp.org/blog/2015/09/stroustrup-cppcon15-keynote). See also the [accompanying isocpp.org blog post](https://isocpp.org/blog/2015/09/bjarne-stroustrup-announces-cpp-core-guidelines), and for the rationale of the type and memory safety guidelines see [Herb Sutter's follow-up CppCon 2015 talk, \"Writing Good C++14 ... By Default\"](https://isocpp.org/blog/2015/09/sutter-cppcon15-day2plenary).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"faq-maintainers\"></a>FAQ.3: Who are the authors and maintainers of these guidelines?",
    "content": "### <a name=\"faq-maintainers\"></a>FAQ.3: Who are the authors and maintainers of these guidelines?\n\nThe initial primary authors and maintainers are Bjarne Stroustrup and Herb Sutter, and the guidelines so far were developed with contributions from experts at CERN, Microsoft, Morgan Stanley, and several other organizations. At the time of their release, the guidelines are in a \"0.6\" state, and contributions are welcome. As Stroustrup said in his announcement: \"We need help!\"\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"faq-contribute\"></a>FAQ.4: How can I contribute?",
    "content": "### <a name=\"faq-contribute\"></a>FAQ.4: How can I contribute?\n\nSee [CONTRIBUTING.md](https://github.com/isocpp/CppCoreGuidelines/blob/master/CONTRIBUTING.md). We appreciate volunteer help!\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"faq-maintainer\"></a>FAQ.5: How can I become an editor/maintainer?",
    "content": "### <a name=\"faq-maintainer\"></a>FAQ.5: How can I become an editor/maintainer?\n\nBy contributing a lot first and having the consistent quality of your contributions recognized. See [CONTRIBUTING.md](https://github.com/isocpp/CppCoreGuidelines/blob/master/CONTRIBUTING.md). We appreciate volunteer help!\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"faq-iso\"></a>FAQ.6: Have these guidelines been approved by the ISO C++ standards committee? Do they represent the consensus of the committee?",
    "content": "### <a name=\"faq-iso\"></a>FAQ.6: Have these guidelines been approved by the ISO C++ standards committee? Do they represent the consensus of the committee?\n\nNo. These guidelines are outside the standard. They are intended to serve the standard, and be maintained as current guidelines about how to use the current Standard C++ effectively. We aim to keep them in sync with the standard as that is evolved by the committee.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"faq-isocpp\"></a>FAQ.7: If these guidelines are not approved by the committee, why are they under `github.com/isocpp`?",
    "content": "### <a name=\"faq-isocpp\"></a>FAQ.7: If these guidelines are not approved by the committee, why are they under `github.com/isocpp`?\n\nBecause `isocpp` is the Standard C++ Foundation; the committee's repositories are under [github.com/*cplusplus*](https://github.com/cplusplus). Some neutral organization has to own the copyright and license to make it clear this is not being dominated by any one person or vendor. The natural entity is the Foundation, which exists to promote the use and up-to-date understanding of modern Standard C++ and the work of the committee. This follows the same pattern that isocpp.org did for the [C++ FAQ](https://isocpp.org/faq), which was initially the work of Bjarne Stroustrup, Marshall Cline, and Herb Sutter and contributed to the open project in the same way.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"faq-cpp98\"></a>FAQ.8: Will there be a C++98 version of these Guidelines? A C++11 version?",
    "content": "### <a name=\"faq-cpp98\"></a>FAQ.8: Will there be a C++98 version of these Guidelines? A C++11 version?\n\nNo. These guidelines are about how to best use modern standard C++ and write code assuming you have a modern conforming compiler.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"faq-language-extensions\"></a>FAQ.9: Do these guidelines propose new language features?",
    "content": "### <a name=\"faq-language-extensions\"></a>FAQ.9: Do these guidelines propose new language features?\n\nNo. These guidelines are about how to best use modern Standard C++, and they limit themselves to recommending only those features.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"faq-markdown\"></a>FAQ.10: What version of Markdown do these guidelines use?",
    "content": "### <a name=\"faq-markdown\"></a>FAQ.10: What version of Markdown do these guidelines use?\n\nThese coding standards are written using [CommonMark](https://commonmark.org), and `<a>` HTML anchors.\n\nWe are considering the following extensions from [GitHub Flavored Markdown (GFM)](https://help.github.com/articles/github-flavored-markdown/):\n\n* fenced code blocks (consistently using indented vs. fenced is under discussion)\n* tables (none yet but we'll likely need them, and this is a GFM extension)\n\nAvoid other HTML tags and other extensions.\n\nNote: We are not yet consistent with this style.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"faq-gsl\"></a>FAQ.50: What is the GSL (guidelines support library)?",
    "content": "### <a name=\"faq-gsl\"></a>FAQ.50: What is the GSL (guidelines support library)?\n\nThe GSL is the small set of types and aliases specified in these guidelines. As of this writing, their specification herein is too sparse; we plan to add a WG21-style interface specification to ensure that different implementations agree, and to propose as a contribution for possible standardization, subject as usual to whatever the committee decides to accept/improve/alter/reject.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"faq-msgsl\"></a>FAQ.51: Is [github.com/Microsoft/GSL](https://github.com/Microsoft/GSL) the GSL?",
    "content": "### <a name=\"faq-msgsl\"></a>FAQ.51: Is [github.com/Microsoft/GSL](https://github.com/Microsoft/GSL) the GSL?\n\nNo. That is just a first implementation contributed by Microsoft. Other implementations by other vendors are encouraged, as are forks of and contributions to that implementation. As of this writing one week into the public project, at least one GPLv3 open-source implementation already exists. We plan to produce a WG21-style interface specification to ensure that different implementations agree.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"faq-gsl-implementation\"></a>FAQ.52: Why not supply an actual GSL implementation in/with these guidelines?",
    "content": "### <a name=\"faq-gsl-implementation\"></a>FAQ.52: Why not supply an actual GSL implementation in/with these guidelines?\n\nWe are reluctant to bless one particular implementation because we do not want to make people think there is only one, and inadvertently stifle parallel implementations. And if these guidelines included an actual implementation, then whoever contributed it could be mistakenly seen as too influential. We prefer to follow the long-standing approach of the committee, namely to specify interfaces, not implementations. But at the same time we want at least one implementation available; we hope for many.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"faq-boost\"></a>FAQ.53: Why weren't the GSL types proposed through Boost?",
    "content": "### <a name=\"faq-boost\"></a>FAQ.53: Why weren't the GSL types proposed through Boost?\n\nBecause we want to use them immediately, and because they are temporary in that we want to retire them as soon as types that fill the same needs exist in the standard library.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"faq-gsl-iso\"></a>FAQ.54: Has the GSL (guidelines support library) been approved by the ISO C++ standards committee?",
    "content": "### <a name=\"faq-gsl-iso\"></a>FAQ.54: Has the GSL (guidelines support library) been approved by the ISO C++ standards committee?\n\nNo. The GSL exists only to supply a few types and aliases that are not currently in the standard library. If the committee decides on standardized versions (of these or other types that fill the same need) then they can be removed from the GSL.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"faq-gsl-string-view\"></a>FAQ.55: If you're using the standard types where available, why is the GSL `span<char>` different from the `string_view` in the Library Fundamentals 1 Technical Specification and C++17 Working Paper? Why not just use the committee-approved `string_view`?",
    "content": "### <a name=\"faq-gsl-string-view\"></a>FAQ.55: If you're using the standard types where available, why is the GSL `span<char>` different from the `string_view` in the Library Fundamentals 1 Technical Specification and C++17 Working Paper? Why not just use the committee-approved `string_view`?\n\nThe consensus on the taxonomy of views for the C++ Standard Library was that \"view\" means \"read-only\", and \"span\" means \"read/write\". If you only need a read-only view of characters that does not need guaranteed bounds-checking and you have C++17, use C++17 `std::string_view`. Otherwise, if you need a read-write view that does not need guaranteed bounds-checking and you have C++20, use C++20 `std::span<char>`. Otherwise, use `gsl::span<char>`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"faq-gsl-owner\"></a>FAQ.56: Is `owner` the same as the proposed `observer_ptr`?",
    "content": "### <a name=\"faq-gsl-owner\"></a>FAQ.56: Is `owner` the same as the proposed `observer_ptr`?\n\nNo. `owner` owns, is an alias, and can be applied to any indirection type. The main intent of `observer_ptr` is to signify a *non*-owning pointer.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"faq-gsl-stack-array\"></a>FAQ.57: Is `stack_array` the same as the standard `array`?",
    "content": "### <a name=\"faq-gsl-stack-array\"></a>FAQ.57: Is `stack_array` the same as the standard `array`?\n\nNo. `stack_array` is guaranteed to be allocated on the stack. Although a `std::array` contains its storage directly inside itself, the `array` object can be put anywhere, including the heap.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"faq-gsl-dyn-array\"></a>FAQ.58: Is `dyn_array` the same as `vector` or the proposed `dynarray`?",
    "content": "### <a name=\"faq-gsl-dyn-array\"></a>FAQ.58: Is `dyn_array` the same as `vector` or the proposed `dynarray`?\n\nNo. `dyn_array` is a container, like `vector`, but it is not resizable; its size is fixed at runtime when it is constructed.\nIt is a safe way to refer to a dynamically \"heap\"-allocated fixed-size array. Unlike `vector`, it is intended to replace array-`new[]`. Unlike the `dynarray` that has been proposed in the committee, this does not anticipate compiler/language magic to somehow allocate it on the stack when it is a member of an object that is allocated on the stack; it simply refers to a \"dynamic\" or heap-based array.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"faq-gsl-expects\"></a>FAQ.59: Is `Expects` the same as `assert`?",
    "content": "### <a name=\"faq-gsl-expects\"></a>FAQ.59: Is `Expects` the same as `assert`?\n\nNo. It is a placeholder for language support for contract preconditions.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"faq-gsl-ensures\"></a>FAQ.60: Is `Ensures` the same as `assert`?",
    "content": "### <a name=\"faq-gsl-ensures\"></a>FAQ.60: Is `Ensures` the same as `assert`?\n\nNo. It is a placeholder for language support for contract postconditions.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-libraries\"></a>Appendix A: Libraries",
    "content": "# <a name=\"s-libraries\"></a>Appendix A: Libraries\n\nThis section lists recommended libraries, and explicitly recommends a few.\n\n??? Suitable for the general guide? I think not ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-modernizing\"></a>Appendix B: Modernizing code",
    "content": "# <a name=\"s-modernizing\"></a>Appendix B: Modernizing code\n\nIdeally, we follow all rules in all code.\nRealistically, we have to deal with a lot of old code:\n\n* application code written before the guidelines were formulated or known\n* libraries written to older/different standards\n* code written under \"unusual\" constraints\n* code that we just haven't gotten around to modernizing\n\nIf we have a million lines of new code, the idea of \"just changing it all at once\" is typically unrealistic.\nThus, we need a way of gradually modernizing a code base.\n\nUpgrading older code to modern style can be a daunting task.\nOften, the old code is both a mess (hard to understand) and working correctly (for the current range of uses).\nTypically, the original programmer is not around and the test cases incomplete.\nThe fact that the code is a mess dramatically increases the effort needed to make any change and the risk of introducing errors.\nOften, messy old code runs unnecessarily slowly because it requires outdated compilers and cannot take advantage of modern hardware.\nIn many cases, automated \"modernizer\"-style tool support would be required for major upgrade efforts.\n\nThe purpose of modernizing code is to simplify adding new functionality, to ease maintenance, and to increase performance (throughput or latency), and to better utilize modern hardware.\nMaking code \"look pretty\" or \"follow modern style\" are not by themselves reasons for change.\nThere are risks implied by every change and costs (including the cost of lost opportunities) implied by having an outdated code base.\nThe cost reductions must outweigh the risks.\n\nBut how?\n\nThere is no one approach to modernizing code.\nHow best to do it depends on the code, the pressure for updates, the backgrounds of the developers, and the available tool.\nHere are some (very general) ideas:\n\n* The ideal is \"just upgrade everything.\" That gives the most benefits for the shortest total time.\n  In most circumstances, it is also impossible.\n* We could convert a code base module for module, but any rules that affects interfaces (especially ABIs), such as [use `span`](#ss-views), cannot be done on a per-module basis.\n* We could convert code \"bottom up\" starting with the rules we estimate will give the greatest benefits and/or the least trouble in a given code base.\n* We could start by focusing on the interfaces, e.g., make sure that no resources are lost and no pointer is misused.\n  This would be a set of changes across the whole code base, but would most likely have huge benefits.\n  Afterwards, code hidden behind those interfaces can be gradually modernized without affecting other code.\n\nWhichever way you choose, please note that the most advantages come with the highest conformance to the guidelines.\nThe guidelines are not a random set of unrelated rules where you can randomly pick and choose with an expectation of success.\n\nWe would dearly love to hear about experience and about tools used.\nModernization can be much faster, simpler, and safer when supported with analysis tools and even code transformation tools.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-discussion\"></a>Appendix C: Discussion",
    "content": "# <a name=\"s-discussion\"></a>Appendix C: Discussion\n\nThis section contains follow-up material on rules and sets of rules.\nIn particular, here we present further rationale, longer examples, and discussions of alternatives.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"sd-order\"></a>Discussion: Define and initialize data members in the order of member declaration",
    "content": "### <a name=\"sd-order\"></a>Discussion: Define and initialize data members in the order of member declaration\n\nData members are always initialized in the order they are declared in the class definition, so write them in that order in the constructor initialization list. Writing them in a different order just makes the code confusing because it won't run in the order you see, and that can make it hard to see order-dependent bugs.\n\n    class Employee {\n        string email, first, last;\n    public:\n        Employee(const char* firstName, const char* lastName);\n        // ...\n    };\n\n    Employee::Employee(const char* firstName, const char* lastName)\n      : first(firstName),\n        last(lastName),\n        // BAD: first and last not yet constructed\n        email(first + \".\" + last + \"@acme.com\")\n    {}\n\nIn this example, `email` will be constructed before `first` and `last` because it is declared first. That means its constructor will attempt to use `first` and `last` too soon -- not just before they are set to the desired values, but before they are constructed at all.\n\nIf the class definition and the constructor body are in separate files, the long-distance influence that the order of data member declarations has over the constructor's correctness will be even harder to spot.\n\n**References**:\n\n[\\[Cline99\\]](#Cline99) 22.03-11, [\\[Dewhurst03\\]](#Dewhurst03) 52-53, [\\[Koenig97\\]](#Koenig97) 4, [\\[Lakos96\\]](#Lakos96) 10.3.5, [\\[Meyers97\\]](#Meyers97) 13, [\\[Murray93\\]](#Murray93) 2.1.3, [\\[Sutter00\\]](#Sutter00) 47\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"sd-init\"></a>Discussion: Use of `=`, `{}`, and `()` as initializers",
    "content": "### <a name=\"sd-init\"></a>Discussion: Use of `=`, `{}`, and `()` as initializers\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"sd-factory\"></a>Discussion: Use a factory function if you need \"virtual behavior\" during initialization",
    "content": "### <a name=\"sd-factory\"></a>Discussion: Use a factory function if you need \"virtual behavior\" during initialization\n\nIf your design wants virtual dispatch into a derived class from a base class constructor or destructor for functions like `f` and `g`, you need other techniques, such as a post-constructor -- a separate member function the caller must invoke to complete initialization, which can safely call `f` and `g` because in member functions virtual calls behave normally. Some techniques for this are shown in the References. Here's a non-exhaustive list of options:\n\n* *Pass the buck:* Just document that user code must call the post-initialization function right after constructing an object.\n* *Post-initialize lazily:* Do it during the first call of a member function. A Boolean flag in the base class tells whether or not post-construction has taken place yet.\n* *Use virtual base class semantics:* Language rules dictate that the constructor of the most-derived class decides which base constructor will be invoked; you can use that to your advantage. (See [\\[Taligent94\\]](#Taligent94).)\n* *Use a factory function:* This way, you can easily force a mandatory invocation of a post-constructor function.\n\nHere is an example of the last option:\n\n    class B {\n    public:\n        B()\n        {\n            /* ... */\n            f(); // BAD: C.82: Don't call virtual functions in constructors and destructors\n            /* ... */\n        }\n\n        virtual void f() = 0;\n    };\n\n    class B {\n    protected:\n        class Token {};\n\n    public:\n        // constructor needs to be public so that make_shared can access it.\n        // protected access level is gained by requiring a Token.\n        explicit B(Token) { /* ... */ }  // create an imperfectly initialized object\n        virtual void f() = 0;\n\n        template<class T>\n        static shared_ptr<T> create()    // interface for creating shared objects\n        {\n            auto p = make_shared<T>(typename T::Token{});\n            p->post_initialize();\n            return p;\n        }\n\n    protected:\n        virtual void post_initialize()   // called right after construction\n            { /* ... */ f(); /* ... */ } // GOOD: virtual dispatch is safe\n        }\n    };\n\n\n    class D : public B {                 // some derived class\n    protected:\n        class Token {};\n\n    public:\n        // constructor needs to be public so that make_shared can access it.\n        // protected access level is gained by requiring a Token.\n        explicit D(Token) : B{ B::Token{} } {}\n        void f() override { /* ...  */ };\n\n    protected:\n        template<class T>\n        friend shared_ptr<T> B::create();\n    };\n\n    shared_ptr<D> p = D::create<D>();    // creating a D object\n\nThis design requires the following discipline:\n\n* Derived classes such as `D` must not expose a publicly callable constructor. Otherwise, `D`'s users could create `D` objects that don't invoke `post_initialize`.\n* Allocation is limited to `operator new`. `B` can, however, override `new` (see Items 45 and 46 in [SuttAlex05](#SuttAlex05)).\n* `D` must define a constructor with the same parameters that `B` selected. Defining several overloads of `create` can assuage this problem, however; and the overloads can even be templated on the argument types.\n\nIf the requirements above are met, the design guarantees that `post_initialize` has been called for any fully constructed `B`-derived object. `post_initialize` doesn't need to be virtual; it can, however, invoke virtual functions freely.\n\nIn summary, no post-construction technique is perfect. The worst techniques dodge the whole issue by simply asking the caller to invoke the post-constructor manually. Even the best require a different syntax for constructing objects (easy to check at compile time) and/or cooperation from derived class authors (impossible to check at compile time).\n\n**References**: [\\[Alexandrescu01\\]](#Alexandrescu01) 3, [\\[Boost\\]](#Boost), [\\[Dewhurst03\\]](#Dewhurst03) 75, [\\[Meyers97\\]](#Meyers97) 46, [\\[Stroustrup00\\]](#Stroustrup00) 15.4.3, [\\[Taligent94\\]](#Taligent94)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"sd-dtor\"></a>Discussion: Make base class destructors public and virtual, or protected and non-virtual",
    "content": "### <a name=\"sd-dtor\"></a>Discussion: Make base class destructors public and virtual, or protected and non-virtual\n\nShould destruction behave virtually? That is, should destruction through a pointer to a `base` class be allowed? If yes, then `base`'s destructor must be public in order to be callable, and virtual, otherwise calling it results in undefined behavior. Otherwise, it should be protected so that only derived classes can invoke it in their own destructors, and non-virtual since it doesn't need to behave virtually.\n\n##### Example\n\nThe common case for a base class is that it's intended to have publicly derived classes, and so calling code is just about sure to use something like a `shared_ptr<base>`:\n\n    class Base {\n    public:\n        ~Base();                   // BAD, not virtual\n        virtual ~Base();           // GOOD\n        // ...\n    };\n\n    class Derived : public Base { /* ... */ };\n\n    {\n        unique_ptr<Base> pb = make_unique<Derived>();\n        // ...\n    } // ~pb invokes correct destructor only when ~Base is virtual\n\nIn rarer cases, such as policy classes, the class is used as a base class for convenience, not for polymorphic behavior. It is recommended to make those destructors protected and non-virtual:\n\n    class My_policy {\n    public:\n        virtual ~My_policy();      // BAD, public and virtual\n    protected:\n        ~My_policy();              // GOOD\n        // ...\n    };\n\n    template<class Policy>\n    class customizable : Policy { /* ... */ }; // note: private inheritance\n\n##### Note\n\nThis simple guideline illustrates a subtle issue and reflects modern uses of inheritance and object-oriented design principles.\n\nFor a base class `Base`, calling code might try to destroy derived objects through pointers to `Base`, such as when using a `unique_ptr<Base>`. If `Base`'s destructor is public and non-virtual (the default), it can be accidentally called on a pointer that actually points to a derived object, in which case the behavior of the attempted deletion is undefined. This state of affairs has led older coding standards to impose a blanket requirement that all base class destructors must be virtual. This is overkill (even if it is the common case); instead, the rule should be to make base class destructors virtual if and only if they are public.\n\nTo write a base class is to define an abstraction (see Items 35 through 37). Recall that for each member function participating in that abstraction, you need to decide:\n\n* Whether it should behave virtually or not.\n* Whether it should be publicly available to all callers using a pointer to `Base` or else be a hidden internal implementation detail.\n\nAs described in Item 39, for a normal member function, the choice is between allowing it to be called via a pointer to `Base` non-virtually (but possibly with virtual behavior if it invokes virtual functions, such as in the NVI or Template Method patterns), virtually, or not at all. The NVI pattern is a technique to avoid public virtual functions.\n\nDestruction can be viewed as just another operation, albeit with special semantics that make non-virtual calls dangerous or wrong. For a base class destructor, therefore, the choice is between allowing it to be called via a pointer to `Base` virtually or not at all; \"non-virtually\" is not an option. Hence, a base class destructor is virtual if it can be called (i.e., is public), and non-virtual otherwise.\n\nNote that the NVI pattern cannot be applied to the destructor because constructors and destructors cannot make deep virtual calls. (See Items 39 and 55.)\n\nCorollary: When writing a base class, always write a destructor explicitly, because the implicitly generated one is public and non-virtual. You can always `=default` the implementation if the default body is fine and you're just writing the function to give it the proper visibility and virtuality.\n\n##### Exception\n\nSome component architectures (e.g., COM and CORBA) don't use a standard deletion mechanism, and foster different protocols for object disposal. Follow the local patterns and idioms, and adapt this guideline as appropriate.\n\nConsider also this rare case:\n\n* `B` is both a base class and a concrete class that can be instantiated by itself, and so the destructor must be public for `B` objects to be created and destroyed.\n* Yet `B` also has no virtual functions and is not meant to be used polymorphically, and so although the destructor is public it does not need to be virtual.\n\nThen, even though the destructor has to be public, there can be great pressure to not make it virtual because as the first virtual function it would incur all the run-time type overhead when the added functionality should never be needed.\n\nIn this rare case, you could make the destructor public and non-virtual but clearly document that further-derived objects must not be used polymorphically as `B`'s. This is what was done with `std::unary_function`.\n\nIn general, however, avoid concrete base classes (see Item 35). For example, `unary_function` is a bundle-of-typedefs that was never intended to be instantiated standalone. It really makes no sense to give it a public destructor; a better design would be to follow this Item's advice and give it a protected non-virtual destructor.\n\n**References**: [\\[SuttAlex05\\]](#SuttAlex05) Item 50, [\\[Cargill92\\]](#Cargill92) pp. 77-79, 207, [\\[Cline99\\]](#Cline99) 21.06, 21.12-13, [\\[Henricson97\\]](#Henricson97) pp. 110-114, [\\[Koenig97\\]](#Koenig97) Chapters 4, 11, [\\[Meyers97\\]](#Meyers97) 14, [\\[Stroustrup00\\]](#Stroustrup00) 12.4.2, [\\[Sutter02\\]](#Sutter02) 27, [\\[Sutter04\\]](#Sutter04) 18\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"sd-noexcept\"></a>Discussion: Usage of noexcept",
    "content": "### <a name=\"sd-noexcept\"></a>Discussion: Usage of noexcept\n\n???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"sd-never-fail\"></a>Discussion: Destructors, deallocation, and swap must never fail",
    "content": "### <a name=\"sd-never-fail\"></a>Discussion: Destructors, deallocation, and swap must never fail\n\nNever allow an error to be reported from a destructor, a resource deallocation function (e.g., `operator delete`), or a `swap` function using `throw`. It is nearly impossible to write useful code if these operations can fail, and even if something does go wrong it nearly never makes any sense to retry. Specifically, types whose destructors might throw an exception are flatly forbidden from use with the C++ Standard Library. Most destructors are now implicitly `noexcept` by default.\n\n##### Example\n\n    class Nefarious {\n    public:\n        Nefarious() { /* code that could throw */ }    // ok\n        ~Nefarious() { /* code that could throw */ }   // BAD, should not throw\n        // ...\n    };\n\n1. `Nefarious` objects are hard to use safely even as local variables:\n\n\n        void test(string& s)\n        {\n            Nefarious n;          // trouble brewing\n            string copy = s;      // copy the string\n        } // destroy copy and then n\n\n    Here, copying `s` could throw, and if that throws and if `n`'s destructor then also throws, the program will exit via `std::terminate` because two exceptions can't be propagated simultaneously.\n\n2. Classes with `Nefarious` members or bases are also hard to use safely, because their destructors must invoke `Nefarious`' destructor, and are similarly poisoned by its bad behavior:\n\n\n        class Innocent_bystander {\n            Nefarious member;     // oops, poisons the enclosing class's destructor\n            // ...\n        };\n\n        void test(string& s)\n        {\n            Innocent_bystander i;  // more trouble brewing\n            string copy2 = s;      // copy the string\n        } // destroy copy and then i\n\n    Here, if constructing `copy2` throws, we have the same problem because `i`'s destructor now also can throw, and if so we'll invoke `std::terminate`.\n\n3. You can't reliably create global or static `Nefarious` objects either:\n\n\n        static Nefarious n;       // oops, any destructor exception can't be caught\n\n4. You can't reliably create arrays of `Nefarious`:\n\n\n        void test()\n        {\n            std::array<Nefarious, 10> arr; // this line can std::terminate()\n        }\n\n    The behavior of arrays is undefined in the presence of destructors that throw because there is no reasonable rollback behavior that could ever be devised. Just think: What code can the compiler generate for constructing an `arr` where, if the fourth object's constructor throws, the code has to give up and in its cleanup mode tries to call the destructors of the already-constructed objects ... and one or more of those destructors throws? There is no satisfactory answer.\n\n5. You can't use `Nefarious` objects in standard containers:\n\n\n        std::vector<Nefarious> vec(10);   // this line can std::terminate()\n\n    The standard library forbids all destructors used with it from throwing. You can't store `Nefarious` objects in standard containers or use them with any other part of the standard library.\n\n##### Note\n\nThese are key functions that must not fail because they are necessary for the two key operations in transactional programming: to back out work if problems are encountered during processing, and to commit work if no problems occur. If there's no way to safely back out using no-fail operations, then no-fail rollback is impossible to implement. If there's no way to safely commit state changes using a no-fail operation (notably, but not limited to, `swap`), then no-fail commit is impossible to implement.\n\nConsider the following advice and requirements found in the C++ Standard:\n\n> If a destructor called during stack unwinding exits with an exception, terminate is called (15.5.1). So destructors should generally catch exceptions and not let them propagate out of the destructor. --[\\[C++03\\]](#Cplusplus03) 15.2(3)\n>\n> No destructor operation defined in the C++ Standard Library (including the destructor of any type that is used to instantiate a standard-library template) will throw an exception. --[\\[C++03\\]](#Cplusplus03) 17.4.4.8(3)\n\nDeallocation functions, including specifically overloaded `operator delete` and `operator delete[]`, fall into the same category, because they too are used during cleanup in general, and during exception handling in particular, to back out of partial work that needs to be undone.\nBesides destructors and deallocation functions, common error-safety techniques rely also on `swap` operations never failing -- in this case, not because they are used to implement a guaranteed rollback, but because they are used to implement a guaranteed commit. For example, here is an idiomatic implementation of `operator=` for a type `T` that performs copy construction followed by a call to a no-fail `swap`:\n\n    T& T::operator=(const T& other)\n    {\n        auto temp = other;\n        swap(temp);\n        return *this;\n    }\n\n(See also Item 56. ???)\n\nFortunately, when releasing a resource, the scope for failure is definitely smaller. If using exceptions as the error reporting mechanism, make sure such functions handle all exceptions and other errors that their internal processing might generate. (For exceptions, simply wrap everything sensitive that your destructor does in a `try/catch(...)` block.) This is particularly important because a destructor might be called in a crisis situation, such as failure to allocate a system resource (e.g., memory, files, locks, ports, windows, or other system objects).\n\nWhen using exceptions as your error handling mechanism, always document this behavior by declaring these functions `noexcept`. (See Item 75.)\n\n**References**: [\\[SuttAlex05\\]](#SuttAlex05) Item 51; [\\[C++03\\]](#Cplusplus03) 15.2(3), 17.4.4.8(3), [\\[Meyers96\\]](#Meyers96) 11, [\\[Stroustrup00\\]](#Stroustrup00) 14.4.7, E.2-4, [\\[Sutter00\\]](#Sutter00) 8, 16, [\\[Sutter02\\]](#Sutter02) 18-19\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"sd-consistent\"></a>Define Copy, move, and destroy consistently",
    "content": "## <a name=\"sd-consistent\"></a>Define Copy, move, and destroy consistently\n\n##### Reason\n\n ???\n\n##### Note\n\nIf you define a copy constructor, you must also define a copy assignment operator.\n\n##### Note\n\nIf you define a move constructor, you must also define a move assignment operator.\n\n##### Example\n\n    class X {\n    public:\n        X(const X&) { /* stuff */ }\n\n        // BAD: failed to also define a copy assignment operator\n\n        X(x&&) noexcept { /* stuff */ }\n\n        // BAD: failed to also define a move assignment operator\n\n        // ...\n    };\n\n    X x1;\n    X x2 = x1; // ok\n    x2 = x1;   // pitfall: either fails to compile, or does something suspicious\n\nIf you define a destructor, you should not use the compiler-generated copy or move operation; you probably need to define or suppress copy and/or move.\n\n    class X {\n        HANDLE hnd;\n        // ...\n    public:\n        ~X() { /* custom stuff, such as closing hnd */ }\n        // suspicious: no mention of copying or moving -- what happens to hnd?\n    };\n\n    X x1;\n    X x2 = x1; // pitfall: either fails to compile, or does something suspicious\n    x2 = x1;   // pitfall: either fails to compile, or does something suspicious\n\nIf you define copying, and any base or member has a type that defines a move operation, you should also define a move operation.\n\n    class X {\n        string s; // defines more efficient move operations\n        // ... other data members ...\n    public:\n        X(const X&) { /* stuff */ }\n        X& operator=(const X&) { /* stuff */ }\n\n        // BAD: failed to also define a move construction and move assignment\n        // (why wasn't the custom \"stuff\" repeated here?)\n    };\n\n    X test()\n    {\n        X local;\n        // ...\n        return local;  // pitfall: will be inefficient and/or do the wrong thing\n    }\n\nIf you define any of the copy constructor, copy assignment operator, or destructor, you probably should define the others.\n\n##### Note\n\nIf you need to define any of these five functions, it means you need it to do more than its default behavior -- and the five are asymmetrically interrelated. Here's how:\n\n* If you write/disable either of the copy constructor or the copy assignment operator, you probably need to do the same for the other: If one does \"special\" work, probably so should the other because the two functions should have similar effects. (See Item 53, which expands on this point in isolation.)\n* If you explicitly write the copying functions, you probably need to write the destructor: If the \"special\" work in the copy constructor is to allocate or duplicate some resource (e.g., memory, file, socket), you need to deallocate it in the destructor.\n* If you explicitly write the destructor, you probably need to explicitly write or disable copying: If you have to write a non-trivial destructor, it's often because you need to manually release a resource that the object held. If so, it is likely that those resources require careful duplication, and then you need to pay attention to the way objects are copied and assigned, or disable copying completely.\n\nIn many cases, holding properly encapsulated resources using RAII \"owning\" objects can eliminate the need to write these operations yourself. (See Item 13.)\n\nPrefer compiler-generated (including `=default`) special members; only these can be classified as \"trivial\", and at least one major standard library vendor heavily optimizes for classes having trivial special members. This is likely to become common practice.\n\n**Exceptions**: When any of the special functions are declared only to make them non-public or virtual, but without special semantics, it doesn't imply that the others are needed.\nIn rare cases, classes that have members of strange types (such as reference members) are an exception because they have peculiar copy semantics.\nIn a class holding a reference, you likely need to write the copy constructor and the assignment operator, but the default destructor already does the right thing. (Note that using a reference member is almost always wrong.)\n\n**References**: [\\[SuttAlex05\\]](#SuttAlex05) Item 52; [\\[Cline99\\]](#Cline99) 30.01-14, [\\[Koenig97\\]](#Koenig97) 4, [\\[Stroustrup00\\]](#Stroustrup00) 5.5, 10.4, [\\[SuttHysl04b\\]](#SuttHysl04b)\n\nResource management rule summary:\n\n* [Provide strong resource safety; that is, never leak anything that you think of as a resource](#cr-safety)\n* [Never return or throw while holding a resource not owned by a handle](#cr-never)\n* [A \"raw\" pointer or reference is never a resource handle](#cr-raw)\n* [Never let a pointer outlive the object it points to](#cr-outlive)\n* [Use templates to express containers (and other resource handles)](#cr-templates)\n* [Return containers by value (relying on move or copy elision for efficiency)](#cr-value-return)\n* [If a class is a resource handle, it needs a constructor, a destructor, and copy and/or move operations](#cr-handle)\n* [If a class is a container, give it an initializer-list constructor](#cr-list)\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"cr-safety\"></a>Discussion: Provide strong resource safety; that is, never leak anything that you think of as a resource",
    "content": "### <a name=\"cr-safety\"></a>Discussion: Provide strong resource safety; that is, never leak anything that you think of as a resource\n\n##### Reason\n\nPrevent leaks. Leaks can lead to performance degradation, mysterious error, system crashes, and security violations.\n\n**Alternative formulation**: Have every resource represented as an object of some class managing its lifetime.\n\n##### Example\n\n    template<class T>\n    class Vector {\n    private:\n        T* elem;   // sz elements on the free store, owned by the class object\n        int sz;\n        // ...\n    };\n\nThis class is a resource handle. It manages the lifetime of the `T`s. To do so, `Vector` must define or delete [the copy, move, and destruction operations](#rc-five).\n\n##### Example\n\n    ??? \"odd\" non-memory resource ???\n\n##### Enforcement\n\nThe basic technique for preventing leaks is to have every resource owned by a resource handle with a suitable destructor. A checker can find \"naked `new`s\". Given a list of C-style allocation functions (e.g., `fopen()`), a checker can also find uses that are not managed by a resource handle. In general, \"naked pointers\" can be viewed with suspicion, flagged, and/or analyzed. A complete list of resources cannot be generated without human input (the definition of \"a resource\" is necessarily too general), but a tool can be \"parameterized\" with a resource list.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"cr-never\"></a>Discussion: Never return or throw while holding a resource not owned by a handle",
    "content": "### <a name=\"cr-never\"></a>Discussion: Never return or throw while holding a resource not owned by a handle\n\n##### Reason\n\nThat would be a leak.\n\n##### Example\n\n    void f(int i)\n    {\n        FILE* f = fopen(\"a file\", \"r\");\n        ifstream is { \"another file\" };\n        // ...\n        if (i == 0) return;\n        // ...\n        fclose(f);\n    }\n\nIf `i == 0` the file handle for `a file` is leaked. On the other hand, the `ifstream` for `another file` will correctly close its file (upon destruction). If you must use an explicit pointer, rather than a resource handle with specific semantics, use a `unique_ptr` or a `shared_ptr` with a custom deleter:\n\n    void f(int i)\n    {\n        unique_ptr<FILE, int(*)(FILE*)> f(fopen(\"a file\", \"r\"), fclose);\n        // ...\n        if (i == 0) return;\n        // ...\n    }\n\nBetter:\n\n    void f(int i)\n    {\n        ifstream input {\"a file\"};\n        // ...\n        if (i == 0) return;\n        // ...\n    }\n\n##### Enforcement\n\nA checker must consider all \"naked pointers\" suspicious.\nA checker probably must rely on a human-provided list of resources.\nFor starters, we know about the standard-library containers, `string`, and smart pointers.\nThe use of `span` and `string_view` should help a lot (they are not resource handles).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"cr-raw\"></a>Discussion: A \"raw\" pointer or reference is never a resource handle",
    "content": "### <a name=\"cr-raw\"></a>Discussion: A \"raw\" pointer or reference is never a resource handle\n\n##### Reason\n\nTo be able to distinguish owners from views.\n\n##### Note\n\nThis is independent of how you \"spell\" pointer: `T*`, `T&`, `Ptr<T>` and `Range<T>` are not owners.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"cr-outlive\"></a>Discussion: Never let a pointer outlive the object it points to",
    "content": "### <a name=\"cr-outlive\"></a>Discussion: Never let a pointer outlive the object it points to\n\n##### Reason\n\nTo avoid extremely hard-to-find errors. Dereferencing such a pointer is undefined behavior and could lead to violations of the type system.\n\n##### Example\n\n    string* bad()   // really bad\n    {\n        vector<string> v = { \"This\", \"will\", \"cause\", \"trouble\", \"!\" };\n        // leaking a pointer into a destroyed member of a destroyed object (v)\n        return &v[0];\n    }\n\n    void use()\n    {\n        string* p = bad();\n        vector<int> xx = {7, 8, 9};\n        // undefined behavior: x might not be the string \"This\"\n        string x = *p;\n        // undefined behavior: we don't know what (if anything) is allocated a location p\n        *p = \"Evil!\";\n    }\n\nThe `string`s of `v` are destroyed upon exit from `bad()` and so is `v` itself. The returned pointer points to unallocated memory on the free store. This memory (pointed into by `p`) might have been reallocated by the time `*p` is executed. There might be no `string` to read and a write through `p` could easily corrupt objects of unrelated types.\n\n##### Enforcement\n\nMost compilers already warn about simple cases and have the information to do more. Consider any pointer returned from a function suspect. Use containers, resource handles, and views (e.g., `span` known not to be resource handles) to lower the number of cases to be examined. For starters, consider every class with a destructor as resource handle.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"cr-templates\"></a>Discussion: Use templates to express containers (and other resource handles)",
    "content": "### <a name=\"cr-templates\"></a>Discussion: Use templates to express containers (and other resource handles)\n\n##### Reason\n\nTo provide statically type-safe manipulation of elements.\n\n##### Example\n\n    template<typename T> class Vector {\n        // ...\n        T* elem;   // point to sz elements of type T\n        int sz;\n    };\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"cr-value-return\"></a>Discussion: Return containers by value (relying on move or copy elision for efficiency)",
    "content": "### <a name=\"cr-value-return\"></a>Discussion: Return containers by value (relying on move or copy elision for efficiency)\n\n##### Reason\n\nTo simplify code and eliminate a need for explicit memory management. To bring an object into a surrounding scope, thereby extending its lifetime.\n\n**See also**: [F.20, the general item about \"out\" output values](#rf-out)\n\n##### Example\n\n    vector<int> get_large_vector()\n    {\n        return ...;\n    }\n\n    auto v = get_large_vector(); //  return by value is ok, most modern compilers will do copy elision\n\n##### Exception\n\nSee the Exceptions in [F.20](#rf-out).\n\n##### Enforcement\n\nCheck for pointers and references returned from functions and see if they are assigned to resource handles (e.g., to a `unique_ptr`).\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"cr-handle\"></a>Discussion: If a class is a resource handle, it needs a constructor, a destructor, and copy and/or move operations",
    "content": "### <a name=\"cr-handle\"></a>Discussion: If a class is a resource handle, it needs a constructor, a destructor, and copy and/or move operations\n\n##### Reason\n\nTo provide complete control of the lifetime of the resource. To provide a coherent set of operations on the resource.\n\n##### Example\n\n    ??? Messing with pointers\n\n##### Note\n\nIf all members are resource handles, rely on the compiler-generated operations where possible.\n\n    template<typename T> struct Named {\n        string name;\n        T value;\n    };\n\nNow `Named` has a default constructor, a destructor, and efficient copy and move operations, provided `T` has.\n\n##### Enforcement\n\nIn general, a tool cannot know if a class is a resource handle. However, if a class has some of [the default operations](#ss-ctor), it should have all, and if a class has a member that is a resource handle, it should be considered as resource handle.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"cr-list\"></a>Discussion: If a class is a container, give it an initializer-list constructor",
    "content": "### <a name=\"cr-list\"></a>Discussion: If a class is a container, give it an initializer-list constructor\n\n##### Reason\n\nIt is common to need an initial set of elements.\n\n##### Example\n\n    template<typename T> class Vector {\n    public:\n        Vector(std::initializer_list<T>);\n        // ...\n    };\n\n    Vector<string> vs { \"Nygaard\", \"Ritchie\" };\n\n##### Enforcement\n\nWhen is a class a container? ???\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-tools\"></a>Appendix D: Supporting tools",
    "content": "# <a name=\"s-tools\"></a>Appendix D: Supporting tools\n\nThis section contains a list of tools that directly support adoption of the C++ Core Guidelines. This list is not intended to be an exhaustive list of tools\nthat are helpful in writing good C++ code. If a tool is designed specifically to support and links to the C++ Core Guidelines it is a candidate for inclusion.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"St-clangtidy\"></a>Tools: [Clang-tidy](https://clang.llvm.org/extra/clang-tidy/checks/list.html)",
    "content": "### <a name=\"St-clangtidy\"></a>Tools: [Clang-tidy](https://clang.llvm.org/extra/clang-tidy/checks/list.html)\n\nClang-tidy has a set of rules that specifically enforce the C++ Core Guidelines. These rules are named in the pattern `cppcoreguidelines-*`.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"St-cppcorecheck\"></a>Tools: [CppCoreCheck](https://docs.microsoft.com/en-us/visualstudio/code-quality/using-the-cpp-core-guidelines-checkers)",
    "content": "### <a name=\"St-cppcorecheck\"></a>Tools: [CppCoreCheck](https://docs.microsoft.com/en-us/visualstudio/code-quality/using-the-cpp-core-guidelines-checkers)\n\nThe Microsoft compiler's C++ code analysis contains a set of rules specifically aimed at enforcement of the C++ Core Guidelines.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-glossary\"></a>Glossary",
    "content": "# <a name=\"s-glossary\"></a>Glossary\n\nA relatively informal definition of terms used in the guidelines\n(based off the glossary in [Programming: Principles and Practice using C++](https://www.stroustrup.com/programming.html))\n\nMore information on many topics about C++ can be found on the [Standard C++ Foundation](https://isocpp.org)'s site.\n\n* *ABI*: Application Binary Interface, a specification for a specific hardware platform combined with the operating system. Contrast with API.\n* *abstract class*: a class that cannot be directly used to create objects; often used to define an interface to derived classes.\n  A class is made abstract by having a pure virtual function or only protected constructors.\n* *abstraction*: a description of something that selectively and deliberately ignores (hides) details (e.g., implementation details); selective ignorance.\n* *address*: a value that allows us to find an object in a computer's memory.\n* *algorithm*: a procedure or formula for solving a problem; a finite series of computational steps to produce a result.\n* *alias*: an alternative way of referring to an object; often a name, pointer, or reference.\n* *API*: Application Programming Interface, a set of functions that form the communication between various software components. Contrast with ABI.\n* *application*: a program or a collection of programs that is considered an entity by its users.\n* *approximation*: something (e.g., a value or a design) that is close to the perfect or ideal (value or design).\n  Often an approximation is a result of trade-offs among ideals.\n* *argument*: a value passed to a function or a template, in which it is accessed through a parameter.\n* *array*: a homogeneous sequence of elements, usually numbered, e.g., `[0:max)`.\n* *assertion*: a statement inserted into a program to state (assert) that something must always be true at this point in the program.\n* *base class*: a type that is intended to be derived from (e.g., has a non-`final` virtual function), and objects of the type are intended to be used only indirectly (e.g., by pointer). \\[In strict terms, \"base class\" could be defined as \"something we derived from\" but we are specifying in terms of the class designer's intent.\\] Typically a base class has one or more virtual functions.\n* *bit*: the basic unit of information in a computer. A bit can have the value 0 or the value 1.\n* *bug*: an error in a program.\n* *byte*: the basic unit of addressing in most computers. Typically, a byte holds 8 bits.\n* *class*: a user-defined type that can contain data members, function members, and member types.\n* *code*: a program or a part of a program; ambiguously used for both source code and object code.\n* *compiler*: a program that turns source code into object code.\n* *complexity*: a hard-to-precisely-define notion or measure of the difficulty of constructing a solution to a problem or of the solution itself.\n  Sometimes complexity is used to (simply) mean an estimate of the number of operations needed to execute an algorithm.\n* *computation*: the execution of some code, usually taking some input and producing some output.\n* *concept*: (1) a notion, and idea; (2) a set of requirements, usually for a template argument.\n* *concrete type*: a type that is not a base class, and objects of the type are intended to be used directly (not only by pointer/indirection), its size is known, it can typically be allocated anywhere the programmer wants (e.g., stack or statically).\n* *constant*: a value that cannot be changed (in a given scope); not mutable.\n* *constructor*: an operation that initializes (\"constructs\") an object.\n  Typically a constructor establishes an invariant and often acquires resources needed for an object to be used (which are then typically released by a destructor).\n* *container*: an object that holds elements (other objects).\n* *copy*: an operation that makes two objects have values that compare equal. See also move.\n* *correctness*: a program or a piece of a program is correct if it meets its specification.\n  Unfortunately, a specification can be incomplete or inconsistent, or can fail to meet users' reasonable expectations.\n  Thus, to produce acceptable code, we sometimes have to do more than just follow the formal specification.\n* *cost*: the expense (e.g., in programmer time, run time, or space) of producing a program or of executing it.\n  Ideally, cost should be a function of complexity.\n* *customization point*: ???\n* *data*: values used in a computation.\n* *debugging*: the act of searching for and removing errors from a program; usually far less systematic than testing.\n* *declaration*: the specification of a name with its type in a program.\n* *definition*: a declaration of an entity that supplies all information necessary to complete a program using the entity.\n  Simplified definition: a declaration that allocates memory.\n* *derived class*: a class derived from one or more base classes.\n* *design*: an overall description of how a piece of software should operate to meet its specification.\n* *destructor*: an operation that is implicitly invoked (called) when an object is destroyed (e.g., at the end of a scope). Often, it releases resources.\n* *encapsulation*: protecting something meant to be private (e.g., implementation details) from unauthorized access.\n* *error*: a mismatch between reasonable expectations of program behavior (often expressed as a requirement or a users' guide) and what a program actually does.\n* *executable*: a program ready to be run (executed) on a computer.\n* *feature creep*: a tendency to add excess functionality to a program \"just in case.\"\n* *file*: a container of permanent information in a computer.\n* *floating-point number*: a computer's approximation of a real number, such as 7.93 and 10.78e-3.\n* *function*: a named unit of code that can be invoked (called) from different parts of a program; a logical unit of computation.\n* *generic programming*: a style of programming focused on the design and efficient implementation of algorithms.\n  A generic algorithm will work for all argument types that meet its requirements. In C++, generic programming typically uses templates.\n* *global variable*: technically, a named object in namespace scope.\n* *handle*: a class that allows access to another through a member pointer or reference. See also resource, copy, move.\n* *header*: a file containing declarations used to share interfaces between parts of a program.\n* *hiding*: the act of preventing a piece of information from being directly seen or accessed.\n  For example, a name from a nested (inner) scope can prevent that same name from an outer (enclosing) scope from being directly used.\n* *ideal*: the perfect version of something we are striving for. Usually we have to make trade-offs and settle for an approximation.\n* *implementation*: (1) the act of writing and testing code; (2) the code that implements a program.\n* *infinite loop*: a loop where the termination condition never becomes true. See iteration.\n* *infinite recursion*: a recursion that doesn't end until the machine runs out of memory to hold the calls.\n  In reality, such recursion is never infinite but is terminated by some hardware error.\n* *information hiding*: the act of separating interface and implementation, thus hiding implementation details not meant for the user's attention and providing an abstraction.\n* *initialize*: giving an object its first (initial) value.\n* *input*: values used by a computation (e.g., function arguments and characters typed on a keyboard).\n* *integer*: a whole number, such as 42 and -99.\n* *interface*: a declaration or a set of declarations specifying how a piece of code (such as a function or a class) can be called.\n* *invariant*: something that must be always true at a given point (or points) of a program; typically used to describe the state (set of values) of an object or the state of a loop before entry into the repeated statement.\n* *iteration*: the act of repeatedly executing a piece of code; see recursion.\n* *iterator*: an object that identifies an element of a sequence.\n* *ISO*: International Organization for Standardization. The C++ language is an ISO standard, ISO/IEC 14882. More information at [iso.org](https://iso.org).\n* *library*: a collection of types, functions, classes, etc. implementing a set of facilities (abstractions) meant to be potentially used as part of more than one program.\n* *lifetime*: the time from the initialization of an object until it becomes unusable (goes out of scope, is deleted, or the program terminates).\n* *linker*: a program that combines object code files and libraries into an executable program.\n* *literal*: a notation that directly specifies a value, such as 12 specifying the integer value \"twelve.\"\n* *loop*: a piece of code executed repeatedly; in C++, typically a for-statement or a `while`-statement.\n* *move*: an operation that transfers a value from one object to another leaving behind a value representing \"empty.\" See also copy.\n* *move-only type*: a concrete type that is movable but not copyable.\n* *mutable*: changeable; the opposite of immutable, constant, and invariable.\n* *object*: (1) an initialized region of memory of a known type which holds a value of that type; (2) a region of memory.\n* *object code*: output from a compiler intended as input for a linker (for the linker to produce executable code).\n* *object file*: a file containing object code.\n* *object-oriented programming*: (OOP) a style of programming focused on the design and use of classes and class hierarchies.\n* *operation*: something that can perform some action, such as a function and an operator.\n* *output*: values produced by a computation (e.g., a function result or lines of characters written on a screen).\n* *overflow*: producing a value that cannot be stored in its intended target.\n* *overload*: defining two functions or operators with the same name but different argument (operand) types.\n* *override*: defining a function in a derived class with the same name and argument types as a virtual function in the base class, thus making the function callable through the interface defined by the base class.\n* *owner*: an object responsible for releasing a resource.\n* *paradigm*: a somewhat pretentious term for design or programming style; often used with the (erroneous) implication that there exists a paradigm that is superior to all others.\n* *parameter*: a declaration of an explicit input to a function or a template. When called, a function can access the arguments passed through the names of its parameters.\n* *pointer*: (1) a value used to identify a typed object in memory; (2) a variable holding such a value.\n* *post-condition*: a condition that must hold upon exit from a piece of code, such as a function or a loop.\n* *pre-condition*: a condition that must hold upon entry into a piece of code, such as a function or a loop.\n* *program*: code (possibly with associated data) that is sufficiently complete to be executed by a computer.\n* *programming*: the art of expressing solutions to problems as code.\n* *programming language*: a language for expressing programs.\n* *pseudo code*: a description of a computation written in an informal notation rather than a programming language.\n* *pure virtual function*: a virtual function that must be overridden in a derived class.\n* *RAII*: (\"Resource Acquisition Is Initialization\") a basic technique for resource management based on scopes.\n* *range*: a sequence of values that can be described by a start point and an end point. For example, `[0:5)` means the values 0, 1, 2, 3, and 4.\n* *recursion*: the act of a function calling itself; see also iteration.\n* *reference*: (1) a value describing the location of a typed value in memory; (2) a variable holding such a value.\n* *regular expression*: a notation for patterns in character strings.\n* *regular*: a semiregular type that is equality-comparable (see `std::regular` concept). After a copy, the copied object compares equal to the original object. A regular type behaves similarly to built-in types like `int` and can be compared with `==`.\nIn particular, an object of a regular type can be copied and the result of a copy is a separate object that compares equal to the original. See also *semiregular type*.\n* *requirement*: (1) a description of the desired behavior of a program or part of a program; (2) a description of the assumptions a function or template makes of its arguments.\n* *resource*: something that is acquired and must later be released, such as a file handle, a lock, or memory. See also handle, owner.\n* *rounding*: conversion of a value to the mathematically nearest value of a less precise type.\n* *RTTI*: Run-Time Type Information. ???\n* *scope*: the region of program text (source code) in which a name can be referred to.\n* *semiregular*: a concrete type that is copyable (including movable) and default-constructible (see `std::semiregular` concept). The result of a copy is an independent object with the same value as the original. A semiregular type behaves roughly like a built-in type like `int`, but possibly without a `==` operator. See also *regular type*.\n* *sequence*: elements that can be visited in a linear order.\n* *software*: a collection of pieces of code and associated data; often used interchangeably with program.\n* *source code*: code as produced by a programmer and (in principle) readable by other programmers.\n* *source file*: a file containing source code.\n* *specification*: a description of what a piece of code should do.\n* *standard*: an officially agreed upon definition of something, such as a programming language.\n* *state*: a set of values.\n* *STL*: the containers, iterators, and algorithms part of the standard library.\n* *string*: a sequence of characters.\n* *style*: a set of techniques for programming leading to a consistent use of language features; sometimes used in a very restricted sense to refer just to low-level rules for naming and appearance of code.\n* *subtype*: derived type; a type that has all the properties of a type and possibly more.\n* *supertype*: base type; a type that has a subset of the properties of a type.\n* *system*: (1) a program or a set of programs for performing a task on a computer; (2) a shorthand for \"operating system\", that is, the fundamental execution environment and tools for a computer.\n* *TS*: [Technical Specification](https://www.iso.org/deliverables-all.html?type=ts), A Technical Specification addresses work still under technical development, or where it is believed that there will be a future, but not immediate, possibility of agreement on an International Standard. A Technical Specification is published for immediate use, but it also provides a means to obtain feedback. The aim is that it will eventually be transformed and republished as an International Standard.\n* *template*: a class or a function parameterized by one or more types or (compile-time) values; the basic C++ language construct supporting generic programming.\n* *testing*: a systematic search for errors in a program.\n* *trade-off*: the result of balancing several design and implementation criteria.\n* *truncation*: loss of information in a conversion from a type into another that cannot exactly represent the value to be converted.\n* *type*: something that defines a set of possible values and a set of operations for an object.\n* *uninitialized*: the (undefined) state of an object before it is initialized.\n* *unit*: (1) a standard measure that gives meaning to a value (e.g., km for a distance); (2) a distinguished (e.g., named) part of a larger whole.\n* *use case*: a specific (typically simple) use of a program meant to test its functionality and demonstrate its purpose.\n* *value*: a set of bits in memory interpreted according to a type.\n* *value type*: a term some people use to mean a regular or semiregular type.\n* *variable*: a named object of a given type; contains a value unless uninitialized.\n* *virtual function*: a member function that can be overridden in a derived class.\n* *word*: a basic unit of memory in a computer, often the unit used to hold an integer.\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "<a name=\"s-unclassified\"></a>To-do: Unclassified proto-rules",
    "content": "# <a name=\"s-unclassified\"></a>To-do: Unclassified proto-rules\n\nThis is our to-do list.\nEventually, the entries will become rules or parts of rules.\nAlternatively, we will decide that no change is needed and delete the entry.\n\n* No long-distance friendship\n* Should physical design (what's in a file) and large-scale design (libraries, groups of libraries) be addressed?\n* Namespaces\n* Avoid using directives in the global scope (except for std, and other \"fundamental\" namespaces (e.g. experimental))\n* How granular should namespaces be? All classes/functions designed to work together and released together (as defined in Sutter/Alexandrescu) or something narrower or wider?\n* Should there be inline namespaces ( la `std::literals::*_literals`)?\n* Avoid implicit conversions\n* Const member functions should be thread safe ... aka, but I don't really change the variable, just assign it a value the first time it's called ... argh\n* Always initialize variables, use initialization lists for data members.\n* Anyone writing a public interface which takes or returns `void*` should have their toes set on fire. That one has been a personal favorite of mine for a number of years. :)\n* Use `const`-ness wherever possible: member functions, variables and (yippee) `const_iterators`\n* Use `auto`\n* `(size)` vs. `{initializers}` vs. `{Extent{size}}`\n* Don't overabstract\n* Never pass a pointer down the call stack\n* falling through a function bottom\n* Should there be guidelines to choose between polymorphisms? YES. classic (virtual functions, reference semantics) vs. Sean Parent style (value semantics, type-erased, kind of like `std::function`)  vs. CRTP/static? YES Perhaps even vs. tag dispatch?\n* should virtual calls be banned from ctors/dtors in your guidelines? YES. A lot of people ban them, even though I think it's a big strength of C++ that they are ??? -preserving (D disappointed me so much when it went the Java way). WHAT WOULD BE A GOOD EXAMPLE?\n* Speaking of lambdas, what would weigh in on the decision between lambdas and (local?) classes in algorithm calls and other callback scenarios?\n* And speaking of `std::bind`, Stephen T. Lavavej criticizes it so much I'm starting to wonder if it is indeed going to fade away in future. Should lambdas be recommended instead?\n* What to do with leaks out of temporaries? : `p = (s1 + s2).c_str();`\n* pointer/iterator invalidation leading to dangling pointers:\n\n        void bad()\n        {\n            int* p = new int[700];\n            int* q = &p[7];\n            delete p;\n\n            vector<int> v(700);\n            int* q2 = &v[7];\n            v.resize(900);\n\n            // ... use q and q2 ...\n        }\n\n* LSP\n* private inheritance vs/and membership\n* avoid static class members variables (race conditions, almost-global variables)\n\n* Use RAII lock guards (`lock_guard`, `unique_lock`, `shared_lock`), never call `mutex.lock` and `mutex.unlock` directly (RAII)\n* Prefer non-recursive locks (often used to work around bad reasoning, overhead)\n* Join your threads! (because of `std::terminate` in destructor if not joined or detached ... is there a good reason to detach threads?) -- ??? could support library provide a RAII wrapper for `std::thread`?\n* If two or more mutexes must be acquired at the same time, use `std::lock` (or another deadlock avoidance algorithm?)\n* When using a `condition_variable`, always protect the condition by a mutex (atomic bool whose value is set outside of the mutex is wrong!), and use the same mutex for the condition variable itself.\n* Never use `atomic_compare_exchange_strong` with `std::atomic<user-defined-struct>` (differences in padding matter, while `compare_exchange_weak` in a loop converges to stable padding)\n* individual `shared_future` objects are not thread-safe: two threads cannot wait on the same `shared_future` object (they can wait on copies of a `shared_future` that refer to the same shared state)\n* individual `shared_ptr` objects are not thread-safe: different threads can call non-`const` member functions on *different* `shared_ptr`s that refer to the same shared object, but one thread cannot call a non-`const` member function of a `shared_ptr` object while another thread accesses that same `shared_ptr` object (if you need that, consider `atomic_shared_ptr` instead)\n\n* rules for arithmetic\n\n"
  },
  {
    "source": "C++ Core Guidelines",
    "title": "Bibliography",
    "content": "# Bibliography\n\n* <a name=\"Abrahams01\"></a>\n  \\[Abrahams01]:  D. Abrahams. [Exception-Safety in Generic Components](https://www.boost.org/community/exception_safety.html).\n* <a name=\"Alexandrescu01\"></a>\n  \\[Alexandrescu01]:  A. Alexandrescu. Modern C++ Design (Addison-Wesley, 2001).\n* <a name=\"Cplusplus03\"></a>\n  \\[C++03]:           ISO/IEC 14882:2003(E), Programming Languages  C++ (updated ISO and ANSI C++ Standard including the contents of (C++98) plus errata corrections).\n* <a name=\"Cargill92\"></a>\n  \\[Cargill92]:       T. Cargill. C++ Programming Style (Addison-Wesley, 1992).\n* <a name=\"Cline99\"></a>\n  \\[Cline99]:         M. Cline, G. Lomow, and M. Girou. C++ FAQs (2ndEdition) (Addison-Wesley, 1999).\n* <a name=\"Dewhurst03\"></a>\n  \\[Dewhurst03]:      S. Dewhurst. C++ Gotchas (Addison-Wesley, 2003).\n* <a name=\"Henricson97\"></a>\n  \\[Henricson97]:     M. Henricson and E. Nyquist. Industrial Strength C++ (Prentice Hall, 1997).\n* <a name=\"Koenig97\"></a>\n  \\[Koenig97]:        A. Koenig and B. Moo. Ruminations on C++ (Addison-Wesley, 1997).\n* <a name=\"Lakos96\"></a>\n  \\[Lakos96]:         J. Lakos. Large-Scale C++ Software Design (Addison-Wesley, 1996).\n* <a name=\"Meyers96\"></a>\n  \\[Meyers96]:        S. Meyers. More Effective C++ (Addison-Wesley, 1996).\n* <a name=\"Meyers97\"></a>\n  \\[Meyers97]:        S. Meyers. Effective C++ (2nd Edition) (Addison-Wesley, 1997).\n* <a name=\"Meyers01\"></a>\n  \\[Meyers01]:        S. Meyers. Effective STL (Addison-Wesley, 2001).\n* <a name=\"Meyers05\"></a>\n  \\[Meyers05]:        S. Meyers. Effective C++ (3rd Edition) (Addison-Wesley, 2005).\n* <a name=\"Meyers15\"></a>\n  \\[Meyers15]:        S. Meyers. Effective Modern C++ (O'Reilly, 2015).\n* <a name=\"Murray93\"></a>\n  \\[Murray93]:        R. Murray. C++ Strategies and Tactics (Addison-Wesley, 1993).\n* <a name=\"Stroustrup94\"></a>\n  \\[Stroustrup94]:    B. Stroustrup. The Design and Evolution of C++ (Addison-Wesley, 1994).\n* <a name=\"Stroustrup00\"></a>\n  \\[Stroustrup00]:    B. Stroustrup. The C++ Programming Language (Special 3rdEdition) (Addison-Wesley, 2000).\n* <a name=\"Stroustrup05\"></a>\n  \\[Stroustrup05]:    B. Stroustrup. [A rationale for semantically enhanced library languages](https://www.stroustrup.com/SELLrationale.pdf).\n* <a name=\"Stroustrup13\"></a>\n  \\[Stroustrup13]:    B. Stroustrup. [The C++ Programming Language (4th Edition)](https://www.stroustrup.com/4th.html). Addison-Wesley 2013.\n* <a name=\"Stroustrup14\"></a>\n  \\[Stroustrup14]:    B. Stroustrup. [A Tour of C++](https://www.stroustrup.com/Tour.html).\n  Addison-Wesley 2014.\n* <a name=\"Stroustrup15\"></a>\n  \\[Stroustrup15]:    B. Stroustrup, Herb Sutter, and G. Dos Reis: [A brief introduction to C++'s model for type- and resource-safety](https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Introduction%20to%20type%20and%20resource%20safety.pdf).\n* <a name=\"SuttHysl04b\"></a>\n  \\[SuttHysl04b]:     H. Sutter and J. Hyslop. [Collecting Shared Objects](https://web.archive.org/web/20120926011837/http://www.drdobbs.com/collecting-shared-objects/184401839) (C/C++ Users Journal, 22(8), August 2004).\n* <a name=\"SuttAlex05\"></a>\n  \\[SuttAlex05]:      H. Sutter and  A. Alexandrescu. C++ Coding Standards. Addison-Wesley 2005.\n* <a name=\"Sutter00\"></a>\n  \\[Sutter00]:        H. Sutter. Exceptional C++ (Addison-Wesley, 2000).\n* <a name=\"Sutter02\"></a>\n  \\[Sutter02]:        H. Sutter. More Exceptional C++ (Addison-Wesley, 2002).\n* <a name=\"Sutter04\"></a>\n  \\[Sutter04]:        H. Sutter. Exceptional C++ Style (Addison-Wesley, 2004).\n* <a name=\"Taligent94\"></a>\n  \\[Taligent94]: Taligent's Guide to Designing Programs (Addison-Wesley, 1994).\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 10-cpp20.md",
    "title": "Introduction",
    "content": "---\ntitle: \"Chapter 10 Outlook: Introduction of C++20\"\ntype: book-en-us\norder: 10\n---\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 10-cpp20.md",
    "title": "Chapter 10 Outlook: Introduction of C++20",
    "content": "# Chapter 10 Outlook: Introduction of C++20\n\n[TOC]\n\nC++20 seems to be an exciting update.\nFor example, as early as C++11, the `Concept`,\nwhich was eager to call for high-altitude but ultimately lost, is now on the line.\nThe C++ Organizing Committee decided to vote to finalize C++20 with many proposals,\nsuch as **Concepts**/**Module**/**Coroutine**/**Ranges**/ and so on.\nIn this chapter, we'll take a look at some of the important features that\nC++20 will introduce.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 10-cpp20.md",
    "title": "Concept",
    "content": "## Concept\n\nThe concept is a further enhancement to C++ template programming.\nIn simple terms, the concept is a compile-time feature.\nIt allows the compiler to evaluate template parameters at compile-time,\ngreatly enhancing our experience with template programming in C++.\nWhen programming with templates, we often encounter a variety of heinous errors.\nThis is because we have so far been unable to check and limit template parameters.\nFor example, the following two lines of code can cause a lot of\nalmost unreadable compilation errors:\n\n```cpp\n#include <list>\n#include <algorithm>\nint main() {\n    std::list<int> l = {1, 2, 3};\n    std::sort(l.begin(), l.end());\n    return 0;\n}\n```\n\nThe root cause of this code error is that `std::sort` must provide\na random iterator for the sorting container, otherwise it will not be used,\nand we know that `std::list` does not support random access.\nIn the conceptual language, the iterator in `std::list` does not satisfy\nthe constraint of the concept of random iterators in `std::sort`.\nAfter introducing the concept, we can constrain the template parameters\nlike this:\n\n```cpp\ntemplate <typename T>\nrequires Sortable<T> // Sortable is a concept\nvoid sort(T& c);\n```\n\nabbreviate as:\n\n```cpp\ntemplate<Sortable T> // T is a Sortable typename\nvoid sort(T& c)\n```\n\nEven use it directly as a type:\n\n```cpp\nvoid sort(Sortable& c); // c is a Sortable type object\n```\n\nLet's look at a practical example.\n\nTODO:\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 10-cpp20.md",
    "title": "Module",
    "content": "## Module\n\nTODO:\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 10-cpp20.md",
    "title": "Contract",
    "content": "## Contract\n\nTODO:\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 10-cpp20.md",
    "title": "Range",
    "content": "## Range\n\nTODO:\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 10-cpp20.md",
    "title": "Coroutine",
    "content": "## Coroutine\n\nTODO:\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 10-cpp20.md",
    "title": "Conclusion",
    "content": "## Conclusion\n\nIn general, I finally saw the exciting features of Concepts/Ranges/Modules in C++20.\nThis is still full of charm for a programming language that is already in its thirties.\n\n[Table of Content](./toc.md) | [Previous Chapter](./09-others.md) | [Next Chapter](./appendix1.md)\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 10-cpp20.md",
    "title": "Further Readings",
    "content": "## Further Readings\n\n- [Why Concepts didn't make C++17](http://honermann.net/blog/2016/03/06/why-concepts-didnt-make-cxx17/)\n- [C++11/14/17/20 Compiler Support](https://en.cppreference.com/w/cpp/compiler_support)\n- [C++ History](https://en.cppreference.com/w/cpp/language/history)\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 10-cpp20.md",
    "title": "Licenses",
    "content": "## Licenses\n\n<a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png\" /></a><br />This work was written by [Ou Changkun](https://changkun.de) and licensed under a <a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>. The code of this repository is open sourced under the [MIT license](../../LICENSE).\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 09-others.md",
    "title": "Introduction",
    "content": "---\ntitle: Chapter 09 Minor Features\ntype: book-en-us\norder: 9\n---\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 09-others.md",
    "title": "Chapter 09 Minor Features",
    "content": "# Chapter 09 Minor Features\n\n[TOC]\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 09-others.md",
    "title": "9.1 New Type",
    "content": "## 9.1 New Type\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 09-others.md",
    "title": "`long long int`",
    "content": "### `long long int`\n\n`long long int` is not the first to be introduced in C++11.\nAs early as C99, `long long int` has been included in the C standard,\nso most compilers already support it.\nC++11 now formally incorporate it into the standard library,\nspecifying a `long long int` type with at least 64 bits.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 09-others.md",
    "title": "9.2 `noexcept` and Its Operations",
    "content": "## 9.2 `noexcept` and Its Operations\n\nOne of the big advantages of C++ over C is that\nC++ itself defines a complete set of exception handling mechanisms.\nHowever, before C++11, almost no one used to write an exception declaration expression after the function name.\nStarting from C++11, this mechanism was deprecated,\nso we will not discuss or introduce the previous mechanism.\nHow to work and how to use it, you should not take the initiative to understand it.\n\nC++11 simplifies exception declarations into two cases:\n\n1. The function may throw any exceptions\n2. The function can't throw any exceptions\n\nAnd use `noexcept` to limit these two behaviors, for example:\n\n```cpp\nvoid may_throw();           // May throw any exception\nvoid no_throw() noexcept;   // Cannot throw any exception\n```\n\nIf a function modified with `noexcept` is thrown,\nthe compiler will use `std::terminate()` to\nimmediately terminate the program.\n\n`noexcept` can also be used as an operator to manipulate an expression.\nWhen the expression has no exception, it returns `true`,\notherwise, it returns `false`.\n\n```cpp\n#include <iostream>\nvoid may_throw() {\n    throw true;\n}\nauto non_block_throw = []{\n    may_throw();\n};\nvoid no_throw() noexcept {\n    return;\n}\n\nauto block_throw = []() noexcept {\n    no_throw();\n};\nint main()\n{\n    std::cout << std::boolalpha\n        << \"may_throw() noexcept? \" << noexcept(may_throw()) << std::endl\n        << \"no_throw() noexcept? \" << noexcept(no_throw()) << std::endl\n        << \"lmay_throw() noexcept? \" << noexcept(non_block_throw()) << std::endl\n        << \"lno_throw() noexcept? \" << noexcept(block_throw()) << std::endl;\n    return 0;\n}\n```\n\n`noexcept` can modify the function of blocking exceptions\nafter modifying a function. If an exception is generated internally,\nthe external will not trigger. For instance:\n\n```cpp\ntry {\n    may_throw();\n} catch (...) {\n    std::cout << \"exception captured from may_throw()\" << std::endl;\n}\ntry {\n    non_block_throw();\n} catch (...) {\n    std::cout << \"exception captured from non_block_throw()\" << std::endl;\n}\ntry {\n    block_throw();\n} catch (...) {\n    std::cout << \"exception captured from block_throw()\" << std::endl;\n}\n```\n\nThe final output is:\n\n```\nexception captured, from may_throw()\nexception captured, from non_block_throw()\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 09-others.md",
    "title": "9.3 Literal",
    "content": "## 9.3 Literal\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 09-others.md",
    "title": "Raw String Literal",
    "content": "### Raw String Literal\n\nIn traditional C++, it is very painful to write a string full of\nspecial characters. For example, a string containing HTML ontology\nneeds to add a large number of escape characters.\nFor example, a file path on Windows often as: `C:\\\\Path\\\\To\\\\File`.\n\nC++11 provides the original string literals,\nwhich can be decorated with `R` in front of a string,\nand the original string is wrapped in parentheses, for example:\n\n```cpp\n#include <iostream>\n#include <string>\n\nint main() {\n    std::string str = R\"(C:\\Path\\To\\File)\";\n    std::cout << str << std::endl;\n    return 0;\n}\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 09-others.md",
    "title": "Custom Literal",
    "content": "### Custom Literal\n\nC++11 introduces the ability to customize literals by\noverloading the double quotes suffix operator:\n\n```cpp\n// String literal customization must be set to the following parameter list\nstd::string operator\"\" _wow1(const char *wow1, size_t len) {\n    return std::string(wow1)+\"woooooooooow, amazing\";\n}\n\nstd::string operator\"\" _wow2 (unsigned long long i) {\n    return std::to_string(i)+\"woooooooooow, amazing\";\n}\n\nint main() {\n    auto str = \"abc\"_wow1;\n    auto num = 1_wow2;\n    std::cout << str << std::endl;\n    std::cout << num << std::endl;\n    return 0;\n}\n```\n\nCustom literals support four literals:\n\n1. Integer literal: When overloading, you must use `unsigned long long`, `const char *`, and template literal operator parameters. The former is used in the above code;\n2. Floating-point literals: You must use `long double`, `const char *`, and template literals when overloading;\n3. String literals: A parameter table of the form `(const char *, size_t)` must be used;\n4. Character literals: Parameters can only be `char`, `wchar_t`, `char16_t`, `char32_t`.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 09-others.md",
    "title": "9.4 Memory Alignment",
    "content": "## 9.4 Memory Alignment\n\nC++ 11 introduces two new keywords, `alignof` and `alignas`, to support control of memory alignment.\nThe `alignof` keyword can get a platform-dependent value of type `std::size_t` to query the alignment of the platform.\nOf course, we are sometimes not satisfied with this, and even want to customize the alignment of the structure. Similarly, C++ 11 introduces `alignas`.\nTo reshape the alignment of a structure. Let's look at two examples:\n\n```cpp\n#include <iostream>\n\nstruct Storage {\n    char      a;\n    int       b;\n    double    c;\n    long long d;\n};\n\nstruct alignas(std::max_align_t) AlignasStorage {\n    char      a;\n    int       b;\n    double    c;\n    long long d;\n};\n\nint main() {\n    std::cout << alignof(Storage) << std::endl;\n    std::cout << alignof(AlignasStorage) << std::endl;\n    return 0;\n}\n```\n\nwhere `std::max_align_t` requires the same alignment for each scalar type, so it has almost no difference in maximum scalars.\nIn turn, the result on most platforms is `long double`, so the alignment requirement for `AlignasStorage` we get here is 8 or 16.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 09-others.md",
    "title": "Conclusion",
    "content": "## Conclusion\n\nSeveral of the features introduced in this section are those that\nuse more frequent features from modern C++ features that\nhave not yet been introduced. `noexcept` is the most important feature.\nOne of its features is to prevent the spread of anomalies,\neffective Let the compiler optimize our code to the maximum extent possible.\n\n[Table of Content](./toc.md) | [Previous Chapter](./08-filesystem.md) | [Next Chapter: Outlook: Introduction of C++20](./10-cpp20.md)\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 09-others.md",
    "title": "Licenses",
    "content": "## Licenses\n\n<a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png\" /></a><br />This work was written by [Ou Changkun](https://changkun.de) and licensed under a <a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>. The code of this repository is open sourced under the [MIT license](../../LICENSE).\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 04-containers.md",
    "title": "Introduction",
    "content": "---\ntitle: \"Chapter 04 Containers\"\ntype: book-en-us\norder: 4\n---\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 04-containers.md",
    "title": "Chapter 04 Containers",
    "content": "# Chapter 04 Containers\n\n[TOC]\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 04-containers.md",
    "title": "4.1 Linear Container",
    "content": "## 4.1 Linear Container\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 04-containers.md",
    "title": "`std::array`",
    "content": "### `std::array`\n\nWhen you see this container, you will have this problem:\n\n1. Why introduce `std::array` instead of `std::vector` directly?\n2. Already have a traditional array, why use `std::array`?\n\nFirst, answer the first question. Unlike `std::vector`, the size of the `std::array` object is fixed. If the container size is fixed, then the `std::array` container can be used first.\nAlso, since `std::vector` is automatically expanded, when a large amount of data is stored, and the container is deleted,\nThe container does not automatically return the corresponding memory of the deleted element. In this case, you need to manually run `shrink_to_fit()` to release this part of the memory.\n\n```cpp\nstd::vector<int> v;\nstd::cout << \"size:\" << v.size() << std::endl;         // output 0\nstd::cout << \"capacity:\" << v.capacity() << std::endl; // output 0\n\n// As you can see, the storage of std::vector is automatically managed and\n// automatically expanded as needed.\n// But if there is not enough space, you need to redistribute more memory,\n// and reallocating memory is usually a performance-intensive operation.\nv.push_back(1);\nv.push_back(2);\nv.push_back(3);\nstd::cout << \"size:\" << v.size() << std::endl;         // output 3\nstd::cout << \"capacity:\" << v.capacity() << std::endl; // output 4\n\n// The auto-expansion logic here is very similar to Golang's slice.\nv.push_back(4);\nv.push_back(5);\nstd::cout << \"size:\" << v.size() << std::endl;         // output 5\nstd::cout << \"capacity:\" << v.capacity() << std::endl; // output 8\n\n// As can be seen below, although the container empties the element,\n// the memory of the emptied element is not returned.\nv.clear();\nstd::cout << \"size:\" << v.size() << std::endl;         // output 0\nstd::cout << \"capacity:\" << v.capacity() << std::endl; // output 8\n\n// Additional memory can be returned to the system via the shrink_to_fit() call\nv.shrink_to_fit();\nstd::cout << \"size:\" << v.size() << std::endl;         // output 0\nstd::cout << \"capacity:\" << v.capacity() << std::endl; // output 0\n```\n\nThe second problem is much simpler. Using `std::array` can make the code more \"modern\" and encapsulate some manipulation functions, such as getting the array size and checking if it is not empty, and also using the standard friendly. Container algorithms in the library, such as `std::sort`.\n\nUsing `std::array` is as simple as specifying its type and size:\n\n```cpp\nstd::array<int, 4> arr = {1, 2, 3, 4};\n\narr.empty(); // check if container is empty\narr.size();  // return the size of the container\n\n// iterator support\nfor (auto &i : arr)\n{\n    // ...\n}\n\n// use lambda expression for sort\nstd::sort(arr.begin(), arr.end(), [](int a, int b) {\n    return b < a;\n});\n\n// array size must be constexpr\nconstexpr int len = 4;\nstd::array<int, len> arr = {1, 2, 3, 4};\n\n// illegal, different than C-style array, std::array will not deduce to T*\n// int *arr_p = arr;\n```\n\nWhen we started using `std::array`, it was inevitable that we would encounter a C-style compatible interface. There are three ways to do this:\n\n```cpp\nvoid foo(int *p, int len) {\n    return;\n}\n\nstd::array<int, 4> arr = {1,2,3,4};\n\n// C-stype parameter passing\n// foo(arr, arr.size()); // illegal, cannot convert implicitly\nfoo(&arr[0], arr.size());\nfoo(arr.data(), arr.size());\n\n// use `std::sort`\nstd::sort(arr.begin(), arr.end());\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 04-containers.md",
    "title": "`std::forward_list`",
    "content": "### `std::forward_list`\n\n`std::forward_list` is a list container, and the usage is similar to `std::list`, so we don't spend a lot of time introducing it.\n\nNeed to know is that, unlike the implementation of the doubly linked list of `std::list`, `std::forward_list` is implemented using a singly linked list.\nProvides element insertion of `O(1)` complexity, does not support fast random access (this is also a feature of linked lists),\nIt is also the only container in the standard library container that does not provide the `size()` method. Has a higher space utilization than `std::list` when bidirectional iteration is not required.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 04-containers.md",
    "title": "4.2 Unordered Container",
    "content": "## 4.2 Unordered Container\n\nWe are already familiar with the ordered container `std::map`/`std::set` in traditional C++. These elements are internally implemented by red-black trees.\nThe average complexity of inserts and searches is `O(log(size))`. When inserting an element, the element size is compared according to the `<` operator and the element is determined to be the same.\nAnd select the appropriate location to insert into the container. When traversing the elements in this container, the output will be traversed one by one in the order of the `<` operator.\n\nThe elements in the unordered container are not sorted, and the internals is implemented by the Hash table. The average complexity of inserting and searching for elements is `O(constant)`,\nSignificant performance gains can be achieved without concern for the order of the elements inside the container.\n\nC++11 introduces two unordered containers: `std::unordered_map`/`std::unordered_multimap` and\n`std::unordered_set`/`std::unordered_multiset`.\n\nTheir usage is basically similar to the original `std::map`/`std::multimap`/`std::set`/`set::multiset`\nSince these containers are already familiar to us, we will not compare them one by one. Let's compare `std::map` and `std::unordered_map` directly:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <map>\n\nint main() {\n    // initialized in same order\n    std::unordered_map<int, std::string> u = {\n        {1, \"1\"},\n        {3, \"3\"},\n        {2, \"2\"}\n    };\n    std::map<int, std::string> v = {\n        {1, \"1\"},\n        {3, \"3\"},\n        {2, \"2\"}\n    };\n\n    // iterates in the same way\n    std::cout << \"std::unordered_map\" << std::endl;\n    for( const auto & n : u)\n        std::cout << \"Key:[\" << n.first << \"] Value:[\" << n.second << \"]\\n\";\n\n    std::cout << std::endl;\n    std::cout << \"std::map\" << std::endl;\n    for( const auto & n : v)\n        std::cout << \"Key:[\" << n.first << \"] Value:[\" << n.second << \"]\\n\";\n}\n```\n\nThe final output is:\n\n```txt\nstd::unordered_map\nKey:[2] Value:[2]\nKey:[3] Value:[3]\nKey:[1] Value:[1]\n\nstd::map\nKey:[1] Value:[1]\nKey:[2] Value:[2]\nKey:[3] Value:[3]\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 04-containers.md",
    "title": "4.3 Tuples",
    "content": "## 4.3 Tuples\n\nProgrammers who have known Python should be aware of the concept of tuples. Looking at the containers in traditional C++, except for `std::pair`\nthere seems to be no ready-made structure to store different types of data (usually we will define the structure ourselves).\nBut the flaw of `std::pair` is obvious, only two elements can be saved.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 04-containers.md",
    "title": "Basic Operations",
    "content": "### Basic Operations\n\nThere are three core functions for the use of tuples:\n\n1. `std::make_tuple`: construct tuple\n2. `std::get`: Get the value of a position in the tuple\n3. `std::tie`: tuple unpacking\n\n```cpp\n#include <tuple>\n#include <iostream>\n\nauto get_student(int id) {\n    if (id == 0)\n        return std::make_tuple(3.8, 'A', \"John\");\n    if (id == 1)\n        return std::make_tuple(2.9, 'C', \"Jack\");\n    if (id == 2)\n        return std::make_tuple(1.7, 'D', \"Ive\");\n\n    // it is not allowed to return 0 directly\n    // return type is std::tuple<double, char, std::string>\n    return std::make_tuple(0.0, 'D', \"null\");\n}\n\nint main() {\n    auto student = get_student(0);\n    std::cout << \"ID: 0, \"\n              << \"GPA: \"   << std::get<0>(student) << \", \"\n              << \"Grade: \" << std::get<1>(student) << \", \"\n              << \"Name: \"  << std::get<2>(student) << '\\n';\n\n    double gpa;\n    char grade;\n    std::string name;\n\n    // unpack tuples\n    std::tie(gpa, grade, name) = get_student(1);\n    std::cout << \"ID: 1, \"\n              << \"GPA: \"   << gpa << \", \"\n              << \"Grade: \" << grade << \", \"\n              << \"Name: \"  << name << '\\n';\n}\n```\n\n`std::get` In addition to using constants to get tuple objects, C++14 adds usage types to get objects in tuples:\n\n```cpp\nstd::tuple<std::string, double, double, int> t(\"123\", 4.5, 6.7, 8);\nstd::cout << std::get<std::string>(t) << std::endl;\nstd::cout << std::get<double>(t) << std::endl; // illegal, runtime error\nstd::cout << std::get<3>(t) << std::endl;\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 04-containers.md",
    "title": "Runtime Indexing",
    "content": "### Runtime Indexing\n\nIf you think about it, you might find the problem with the above code. `std::get<>` depends on a compile-time constant, so the following is not legal:\n\n```cpp\nint index = 1;\nstd::get<index>(t);\n```\n\nSo what do you do? The answer is to use `std::variant<>` (introduced by C++ 17) to provide type template parameters for `variant<>`\nYou can have a `variant<>` to accommodate several types of variables provided (in other languages, such as Python/JavaScript, etc., as dynamic types):\n\n```cpp\n#include <variant>\ntemplate <size_t n, typename... T>\nconstexpr std::variant<T...> _tuple_index(const std::tuple<T...>& tpl, size_t i) {\n    if constexpr (n >= sizeof...(T))\n        throw std::out_of_range(\".\");\n    if (i == n)\n        return std::variant<T...>{ std::in_place_index<n>, std::get<n>(tpl) };\n    return _tuple_index<(n < sizeof...(T)-1 ? n+1 : 0)>(tpl, i);\n}\ntemplate <typename... T>\nconstexpr std::variant<T...> tuple_index(const std::tuple<T...>& tpl, size_t i) {\n    return _tuple_index<0>(tpl, i);\n}\ntemplate <typename T0, typename ... Ts>\nstd::ostream & operator<< (std::ostream & s, std::variant<T0, Ts...> const & v) {\n    std::visit([&](auto && x){ s << x;}, v);\n    return s;\n}\n```\n\nSo we can:\n\n```cpp\nint i = 1;\nstd::cout << tuple_index(t, i) << std::endl;\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 04-containers.md",
    "title": "Merge and Iteration",
    "content": "### Merge and Iteration\n\nAnother common requirement is to merge two tuples, which can be done with `std::tuple_cat`:\n\n```cpp\nauto new_tuple = std::tuple_cat(get_student(1), std::move(t));\n```\n\nYou can immediately see how quickly you can traverse a tuple? But we just introduced how to index a `tuple` by a very number at runtime, then the traversal becomes simpler.\nFirst, we need to know the length of a tuple, which can:\n\n```cpp\ntemplate <typename T>\nauto tuple_len(T &tpl) {\n    return std::tuple_size<T>::value;\n}\n```\n\nThis will iterate over the tuple:\n\n```cpp\nfor(int i = 0; i != tuple_len(new_tuple); ++i)\n    // runtime indexing\n    std::cout << tuple_index(new_tuple, i) << std::endl;\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 04-containers.md",
    "title": "Conclusion",
    "content": "## Conclusion\n\nThis chapter briefly introduces the new containers in modern C++. Their usage is similar to that of the existing containers in C++. It is relatively simple, and you can choose the containers you need to use according to the actual scene, to get better performance.\n\nAlthough `std::tuple` is effective, the standard library provides limited functionality and there is no way to meet the requirements of runtime indexing and iteration. Fortunately, we have other methods that we can implement on our own.\n\n[Table of Content](./toc.md) | [Previous Chapter](./03-runtime.md) | [Next Chapter: Smart Pointers and Memory Management](./05-pointers.md)\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 04-containers.md",
    "title": "Licenses",
    "content": "## Licenses\n\n<a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png\" /></a><br />This work was written by [Ou Changkun](https://changkun.de) and licensed under a <a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>. The code of this repository is open sourced under the [MIT license](../../LICENSE).\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 05-pointers.md",
    "title": "Introduction",
    "content": "---\ntitle: \"Chapter 05 Smart Pointers and Memory Management\"\ntype: book-en-us\norder: 5\n---\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 05-pointers.md",
    "title": "Chapter 05 Smart Pointers and Memory Management",
    "content": "# Chapter 05 Smart Pointers and Memory Management\n\n[TOC]\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 05-pointers.md",
    "title": "5.1 RAII and Reference Counting",
    "content": "## 5.1 RAII and Reference Counting\n\nProgrammers who understand `Objective-C`/`Swift`/`JavaScript` should know the concept of reference counting. The reference count is counted to prevent memory leaks.\nThe basic idea is to count the number of dynamically allocated objects. Whenever you add a reference to the same object, the reference count of the referenced object is incremented once.\nEach time a reference is deleted, the reference count is decremented by one. When the reference count of an object is reduced to zero, the pointed heap memory is automatically deleted.\n\nIn traditional C++, \"remembering\" to manually release resources is not always a best practice. Because we are likely to forget to release resources and lead to leakage.\nSo the usual practice is that for an object, we apply for space when constructor, and free space when the destructor (called when leaving the scope).\nThat is, we often say that the RAII resource acquisition is the initialization technology.\n\nThere are exceptions to everything, we always need to allocate objects on free storage. In traditional C++ we have to use `new` and `delete` to \"remember\" to release resources. C++11 introduces the concept of smart pointers, using the idea of reference counting so that programmers no longer need to care about manually releasing memory.\nThese smart pointers include `std::shared_ptr`/`std::unique_ptr`/`std::weak_ptr`, which need to include the header file `<memory>`.\n\n> Note: The reference count is not garbage collection. The reference count can recover the objects that are no longer used as soon as possible, and will not cause long waits during the recycling process.\n> More clearly and indicate the life cycle of resources.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 05-pointers.md",
    "title": "5.2 `std::shared_ptr`",
    "content": "## 5.2 `std::shared_ptr`\n\n`std::shared_ptr` is a smart pointer that records how many `shared_ptr` points to an object, eliminating to call `delete`, which automatically deletes the object when the reference count becomes zero.\n\nBut not enough, because using `std::shared_ptr` still needs to be called with `new`, which makes the code a certain degree of asymmetry.\n\n`std::make_shared` can be used to eliminate the explicit use of `new`, so `std::make_shared` will allocate the objects in the generated parameters.\nAnd return the `std::shared_ptr` pointer of this object type. For example:\n\n```cpp\n#include <iostream>\n#include <memory>\nvoid foo(std::shared_ptr<int> i) {\n    (*i)++;\n}\nint main() {\n    // auto pointer = new int(10); // illegal, no direct assignment\n    // Constructed a std::shared_ptr\n    auto pointer = std::make_shared<int>(10);\n    foo(pointer);\n    std::cout << *pointer << std::endl; // 11\n    // The shared_ptr will be destructed before leaving the scope\n    return 0;\n}\n```\n\n`std::shared_ptr` can get the raw pointer through the `get()` method and reduce the reference count by `reset()`.\nAnd see the reference count of an object by `use_count()`. E.g:\n\n```cpp\nauto pointer = std::make_shared<int>(10);\nauto pointer2 = pointer; // reference count+1\nauto pointer3 = pointer; // reference count+1\nint *p = pointer.get();  // no increase of reference count\n\nstd::cout << \"pointer.use_count() = \" << pointer.use_count() << std::endl;   // 3\nstd::cout << \"pointer2.use_count() = \" << pointer2.use_count() << std::endl; // 3\nstd::cout << \"pointer3.use_count() = \" << pointer3.use_count() << std::endl; // 3\n\npointer2.reset();\nstd::cout << \"reset pointer2:\" << std::endl;\n\nstd::cout << \"pointer.use_count() = \" << pointer.use_count() << std::endl;   // 2\nstd::cout << \"pointer2.use_count() = \" \n    << pointer2.use_count() << std::endl;                // pointer2 has reset, 0\nstd::cout << \"pointer3.use_count() = \" << pointer3.use_count() << std::endl; // 2\n\npointer3.reset();\nstd::cout << \"reset pointer3:\" << std::endl;\n\nstd::cout << \"pointer.use_count() = \" << pointer.use_count() << std::endl;   // 1\nstd::cout << \"pointer2.use_count() = \" << pointer2.use_count() << std::endl; // 0\nstd::cout << \"pointer3.use_count() = \" \n    << pointer3.use_count() << std::endl;                // pointer3 has reset, 0\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 05-pointers.md",
    "title": "5.3 `std::unique_ptr`",
    "content": "## 5.3 `std::unique_ptr`\n\n`std::unique_ptr` is an exclusive smart pointer that prohibits other smart pointers from sharing the same object, thus keeping the code safe:\n\n```cpp\nstd::unique_ptr<int> pointer = std::make_unique<int>(10); // make_unique, from C++14\nstd::unique_ptr<int> pointer2 = pointer; // illegal\n```\n\n> `make_unique` is not complicated. C++11 does not provide `std::make_unique`, which can be implemented by itself:\n>\n> ```cpp\n> template<typename T, typename ...Args>\n> std::unique_ptr<T> make_unique( Args&& ...args ) {\n>   return std::unique_ptr<T>( new T( std::forward<Args>(args)... ) );\n> }\n> ```\n>\n> As for why it wasn't provided, Herb Sutter, chairman of the C++ Standards Committee, mentioned in his [blog](https://herbsutter.com/gotw/_102/) that it was because they were forgotten.\n\nSince it is monopolized, in other words, it cannot be copied. However, we can use `std::move` to transfer it to other `unique_ptr`, for example:\n\n```cpp\n#include <iostream>\n#include <memory>\n\nstruct Foo {\n    Foo()      { std::cout << \"Foo::Foo\" << std::endl;  }\n    ~Foo()     { std::cout << \"Foo::~Foo\" << std::endl; }\n    void foo() { std::cout << \"Foo::foo\" << std::endl;  }\n};\n\nvoid f(const Foo &) {\n    std::cout << \"f(const Foo&)\" << std::endl;\n}\n\nint main() {\n    std::unique_ptr<Foo> p1(std::make_unique<Foo>());\n\n    // p1 is not empty, prints\n    if (p1) p1->foo();\n    {\n        std::unique_ptr<Foo> p2(std::move(p1));\n\n        // p2 is not empty, prints\n        f(*p2);\n\n        // p2 is not empty, prints\n        if(p2) p2->foo();\n\n        // p1 is empty, no prints\n        if(p1) p1->foo();\n\n        p1 = std::move(p2);\n\n        // p2 is empty, no prints\n        if(p2) p2->foo();\n        std::cout << \"p2 was destroyed\" << std::endl;\n    }\n    // p1 is not empty, prints\n    if (p1) p1->foo();\n\n    // Foo instance will be destroyed when leaving the scope\n}\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 05-pointers.md",
    "title": "5.4 `std::weak_ptr`",
    "content": "## 5.4 `std::weak_ptr`\n\nIf you think about `std::shared_ptr` carefully, you will still find that there is still a problem that resources cannot be released. Look at the following example:\n\n```cpp\n#include <iostream>\n#include <memory>\n\nclass A;\nclass B;\n\nclass A {\npublic:\n    std::shared_ptr<B> pointer;\n    ~A() {\n        std::cout << \"A was destroyed\" << std::endl;\n    }\n};\nclass B {\npublic:\n    std::shared_ptr<A> pointer;\n    ~B() {\n        std::cout << \"B was destroyed\" << std::endl;\n    }\n};\nint main() {\n    std::shared_ptr<A> a = std::make_shared<A>();\n    std::shared_ptr<B> b = std::make_shared<B>();\n    a->pointer = b;\n    b->pointer = a;\n\n    return 0;\n}\n```\n\nThe result is that A and B will not be destroyed. This is because the pointer inside a, b also references `a, b`, which makes the reference count of `a, b` becomes 2, leaving the scope. When the `a, b` smart pointer is destructed, it can only cause the reference count of this area to be decremented by one. This causes the memory area reference count pointed to by the `a, b` object to be non-zero, but the external has no way to find this area, it also caused a memory leak, as shown in Figure 5.1:\n\n![Figure 5.1](../../assets/figures/pointers1_en.png)\n\nThe solution to this problem is to use the weak reference pointer `std::weak_ptr`, which is a weak reference (compared to `std::shared_ptr` is a strong reference). A weak reference does not cause an increase in the reference count. When a weak reference is used, the final release process is shown in Figure 5.2:\n\n![Figure 5.2](../../assets/figures/pointers2.png)\n\nIn the above figure, only B is left in the last step, and B does not have any smart pointers to reference it, so this memory resource will also be released.\n\n`std::weak_ptr` has no implemented `*` and `->` operators, therefore it cannot operate on resources. `std::weak_ptr` allows us to check if a `std::shared_ptr` exists or not. The `expired()` method of a `std::weak_ptr` returns `false` when the resource is not released; Otherwise, it returns `true`.\nFurthermore, it can also be used for the purpose of obtaining `std::shared_ptr`, which points to the original object. The `lock()` method returns a `std::shared_ptr` to the original object when the resource is not released, or `nullptr` otherwise.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 05-pointers.md",
    "title": "Conclusion",
    "content": "## Conclusion\n\nThe technology of smart pointers is not novel. It is a common technology in many languages. Modern C++ introduces this technology, which eliminates the abuse of `new`/`delete` to a certain extent. It is a more mature technology. Programming paradigm.\n\n[Table of Content](./toc.md) | [Previous Chapter](./04-containers.md) | [Next Chapter: Regular Expression](./06-regex.md)\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 05-pointers.md",
    "title": "Further Readings",
    "content": "## Further Readings\n\n- [Why does C++11 have `make_shared` but not `make_unique`](https://stackoverflow.com/questions/12580432/why-does-c11-have-make-shared-but-not-make-unique)\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 05-pointers.md",
    "title": "Licenses",
    "content": "## Licenses\n\n<a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png\" /></a><br />This work was written by [Ou Changkun](https://changkun.de) and licensed under a <a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>. The code of this repository is open sourced under the [MIT license](../../LICENSE).\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 06-regex.md",
    "title": "Introduction",
    "content": "---\ntitle: \"Chapter 06 Regular Expression\"\ntype: book-en-us\norder: 6\n---\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 06-regex.md",
    "title": "Chapter 06 Regular Expression",
    "content": "# Chapter 06 Regular Expression\n\n[TOC]\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 06-regex.md",
    "title": "6.1 Introduction",
    "content": "## 6.1 Introduction\n\nRegular expressions are not part of the C++ language and therefore we only briefly\nintroduced it here.\n\nRegular expressions describe a pattern of string matching.\nThe general use of regular expressions is mainly to achieve\nthe following three requirements:\n\n1. Check if a string contains some form of substring;\n2. Replace the matching substrings;\n3. Take the eligible substring from a string.\n\nRegular expressions are text patterns consisting of ordinary characters (such as a to z)\nand special characters. A pattern describes one or more strings to match when searching for text.\nRegular expressions act as a template to match a character pattern to the string being searched.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 06-regex.md",
    "title": "Ordinary characters",
    "content": "### Ordinary characters\n\nNormal characters include all printable and unprintable characters that are not explicitly specified as metacharacters. This includes all uppercase\nand lowercase letters, all numbers, all punctuation, and some other symbols.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 06-regex.md",
    "title": "Special characters",
    "content": "### Special characters\n\nA special character is a character with special meaning in a regular expression and is also the core matching syntax of a regular expression. See the table below:\n\n| Symbol | Description |\n|:----------------:|:---|\n| `$` | Matches the end position of the input string.|\n| `(`,`)` | Marks the start and end of a subexpression. Subexpressions can be obtained for later use.|\n| `*` | Matches the previous subexpression zero or more times. |\n| `+` | Matches the previous subexpression one or more times.|\n| `.` | Matches any single character except the newline character `\\n`.|\n| `[` | Marks the beginning of a bracket expression.|\n| `?` | Matches the previous subexpression zero or one time, or indicates a non-greedy qualifier.|\n| `\\` | Marks the next character as either a special character, or a literal character, or a backward reference, or an octal escape character. For example, `n` Matches the character `n`. `\\n` matches newline characters. The sequence `\\\\` Matches the `'\\'` character, while `\\(` matches the `'('` character. |\n| `^` | Matches the beginning of the input string, unless it is used in a square bracket expression, at which point it indicates that the set of characters is not accepted.|\n| `{` | Marks the beginning of a qualifier expression.|\n| `\\|` | Indicates a choice between the two.|\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 06-regex.md",
    "title": "Quantifiers",
    "content": "### Quantifiers\n\nThe qualifier is used to specify how many times a given component of a regular expression must appear to satisfy the match. See the table below:\n\n| Symbol | Description |\n|:-------:|:-----|\n| `*` | matches the previous subexpression zero or more times. For example, `foo*` matches `fo` and `foooo`. `*` is equivalent to `{0,}`.|\n| `+` | matches the previous subexpression one or more times. For example, `foo+` matches `foo` and `foooo` but does not match `fo`. `+` is equivalent to `{1,}`.|\n| `?` | matches the previous subexpression zero or one time. For example, `Your(s)?` can match `Your` in `Your` or `Yours`. `?` is equivalent to `{0,1}`.|\n| `{n}` | `n` is a non-negative integer. Matches the determined `n` times. For example, `o{2}` cannot match `o` in `for`, but can match two `o` in `foo`.|\n| `{n,}` | `n` is a non-negative integer. Match at least `n` times. For example, `o{2,}` cannot match `o` in `for`, but matches all `o` in `foooooo`. `o{1,}` is equivalent to `o+`. `o{0,}` is equivalent to `o*`.|\n| `{n,m}` | `m` and `n` are non-negative integers, where `n` is less than or equal to `m`. Matches at least `n` times and matches up to `m` times. For example, `o{1,3}` will match the first three `o` in `foooooo`. `o{0,1}` is equivalent to `o?`. Note that there can be no spaces between the comma and the two numbers. |\n\nWith these two tables, we can usually read almost all regular expressions.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 06-regex.md",
    "title": "6.2 `std::regex` and Its Related",
    "content": "## 6.2 `std::regex` and Its Related\n\nThe most common way to match string content is to use regular expressions. Unfortunately, in traditional C++, regular expressions have not been supported by the language level, and are not included in the standard library. C++ is a high-performance language. In the development of background services, the use of regular expressions is also used when judging URL resource links. The most mature and common practice in the industry.\n\nThe general solution is to use the regular expression library of `boost`. C++11 officially incorporates the processing of regular expressions into the standard library, providing standard support from the language level and no longer relying on third parties.\n\nThe regular expression library provided by C++11 operates on the `std::string` object, and the pattern `std::regex` (essentially `std::basic_regex`) is initialized and matched by `std::regex_match` Produces `std::smatch` (essentially the `std::match_results` object).\n\nWe use a simple example to briefly introduce the use of this library. Consider the following regular expression:\n\n- `[az]+\\.txt`: In this regular expression, `[az]` means matching a lowercase letter, `+` can match the previous expression multiple times, so `[az]+` can Matches a string of lowercase letters. In the regular expression, a `.` means to match any character, and `\\.` means to match the character `.`, and the last `txt` means to match `txt` exactly three letters. So the content of this regular expression to match is a text file consisting of pure lowercase letters.\n\n`std::regex_match` is used to match strings and regular expressions, and there are many different overloaded forms. The simplest form is to pass `std::string` and a `std::regex` to match. When the match is successful, it will return `true`, otherwise, it will return `false`. For example:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <regex>\n\nint main() {\n    std::string fnames[] = {\"foo.txt\", \"bar.txt\", \"test\", \"a0.txt\", \"AAA.txt\"};\n    // In C++, `\\` will be used as an escape character in the string.\n    // In order for `\\.` to be passed as a regular expression,\n    // it is necessary to perform second escaping of `\\`, thus we have `\\\\.`\n    std::regex txt_regex(\"[a-z]+\\\\.txt\");\n    for (const auto &fname: fnames)\n        std::cout << fname << \": \" << std::regex_match(fname, txt_regex) << std::endl;\n}\n```\n\nAnother common form is to pass in the three arguments `std::string`/`std::smatch`/`std::regex`.\nThe essence of `std::smatch` is actually `std::match_results`.\nIn the standard library, `std::smatch` is defined as `std::match_results<std::string::const_iterator>`,\nwhich means `match_results` of a substring iterator type.\nUse `std::smatch` to easily get the matching results, for example:\n\n```cpp\nstd::regex base_regex(\"([a-z]+)\\\\.txt\");\nstd::smatch base_match;\nfor(const auto &fname: fnames) {\n    if (std::regex_match(fname, base_match, base_regex)) {\n        // the first element of std::smatch matches the entire string\n        // the second element of std::smatch matches the first expression\n        // with brackets\n        if (base_match.size() == 2) {\n            std::string base = base_match[1].str();\n            std::cout << \"sub-match[0]: \" << base_match[0].str() << std::endl;\n            std::cout << fname << \" sub-match[1]: \" << base << std::endl;\n        }\n    }\n}\n```\n\nThe output of the above two code snippets is:\n\n```\nfoo.txt: 1\nbar.txt: 1\ntest: 0\na0.txt: 0\nAAA.txt: 0\nsub-match[0]: foo.txt\nfoo.txt sub-match[1]: foo\nsub-match[0]: bar.txt\nbar.txt sub-match[1]: bar\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 06-regex.md",
    "title": "Conclusion",
    "content": "## Conclusion\n\nThis section briefly introduces the regular expression itself,\nand then introduces the use of the regular expression library\nthrough a practical example based on the main requirements of\nusing regular expressions.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 06-regex.md",
    "title": "Exercise",
    "content": "## Exercise\n\nIn web server development, we usually want to serve some routes that satisfy a certain condition.\nRegular expressions are one of the tools to accomplish this.\nGiven the following request structure:\n\n```cpp\nstruct Request {\n    // request method, POST, GET; path; HTTP version\n    std::string method, path, http_version;\n    // use smart pointer for reference counting of content\n    std::shared_ptr<std::istream> content;\n    // hash container, key-value dict\n    std::unordered_map<std::string, std::string> header;\n    // use regular expression for path match\n    std::smatch path_match;\n};\n```\n\nRequested resource type:\n\n```cpp\ntypedef std::map<\n    std::string, std::unordered_map<\n        std::string,std::function<void(std::ostream&, Request&)>>> resource_type;\n```\n\nAnd server template:\n\n```cpp\ntemplate <typename socket_type>\nclass ServerBase {\npublic:\n    resource_type resource;\n    resource_type default_resource;\n\n    void start() {\n        // TODO\n    }\nprotected:\n    Request parse_request(std::istream& stream) const {\n        // TODO\n    }\n}\n```\n\nPlease implement the member functions `start()` and `parse_request`. Enable server template users to specify routes as follows:\n\n```cpp\ntemplate<typename SERVER_TYPE>\nvoid start_server(SERVER_TYPE &server) {\n\n    // process GET request for /match/[digit+numbers],\n    // e.g. GET request is /match/abc123, will return abc123\n    server.resource[\"fill_your_reg_ex\"][\"GET\"] =\n        [](ostream& response, Request& request)\n    {\n        string number=request.path_match[1];\n        response << \"HTTP/1.1 200 OK\\r\\nContent-Length: \" << number.length()\n            << \"\\r\\n\\r\\n\" << number;\n    };\n\n    // peocess default GET request;\n    // anonymous function will be called\n    // if no other matches response files in folder web/\n    // default: index.html\n    server.default_resource[\"fill_your_reg_ex\"][\"GET\"] =\n        [](ostream& response, Request& request)\n    {\n        string filename = \"www/\";\n\n        string path = request.path_match[1];\n\n        // forbidden use `..` access content outside folder web/\n        size_t last_pos = path.rfind(\".\");\n        size_t current_pos = 0;\n        size_t pos;\n        while((pos=path.find('.', current_pos)) != string::npos && pos != last_pos) {\n            current_pos = pos;\n            path.erase(pos, 1);\n            last_pos--;\n        }\n\n        // (...)\n    };\n\n    server.start();\n}\n```\n\nAn suggested solution can be found [here](../../exercises/6).\n\n[Table of Content](./toc.md) | [Previous Chapter](./05-pointers.md) | [Next Chapter: Threads and Concurrency](./07-thread.md)\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 06-regex.md",
    "title": "Further Readings",
    "content": "## Further Readings\n\n1. [Comments from `std::regex`'s author](https://zhihu.com/question/23070203/answer/84248248)\n2. [Library document of Regular Expression](https://en.cppreference.com/w/cpp/regex)\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 06-regex.md",
    "title": "Licenses",
    "content": "## Licenses\n\n<a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png\" /></a><br />This work was written by [Ou Changkun](https://changkun.de) and licensed under a <a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>. The code of this repository is open sourced under the [MIT license](../../LICENSE).\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "Introduction",
    "content": "---\ntitle: \"Chapter 02: Language Usability Enhancements\"\ntype: book-en-us\norder: 2\n---\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "Chapter 02: Language Usability Enhancements",
    "content": "# Chapter 02: Language Usability Enhancements\n\n[TOC]\n\nWhen we declare, define a variable or constant, and control the flow of code,\nobject-oriented functions, template programming, etc., before the runtime,\nit may happen when writing code or compiler compiling code.\nTo this end, we usually talk about **language usability**,\nwhich refers to the language behavior that occurred before the runtime.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "2.1 Constants",
    "content": "## 2.1 Constants\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "nullptr",
    "content": "### nullptr\n\nThe purpose of `nullptr` appears to replace `NULL`. There are **null pointer constants** in the C and C++ languages,\nwhich can be implicitly converted to null pointer value of any pointer type,\nor null member pointer value of any pointer-to-member type in C++.\n`NULL` is provided by the standard library implementation and defined as an implementation-defined null pointer constant.\nIn C, some standard libraries defines `NULL` as `((void*)0)` and some define it as `0`.\n\nC++ **does not allow** to implicitly convert `void *` to other types, and thus `((void*)0)` is not a valid implementation\nof `NULL`. If the standard library tries to define `NULL` as `((void*)0)`, then compilation error would occur in the following code:\n\n```cpp\nchar *ch = NULL;\n```\n\nC++ without the `void *` implicit conversion has to define `NULL` as `0`.\nThis still creates a new problem. Defining `NULL` to `0` will cause the overloading feature in `C++` to be confusing.\nConsider the following two `foo` functions:\n\n```cpp\nvoid foo(char*);\nvoid foo(int);\n```\n\nThen the `foo(NULL);` statement will call `foo(int)`, which will cause the code to be counterintuitive.\n\nTo solve this problem, C++11 introduced the `nullptr` keyword, which is specifically used to distinguish null pointers, `0`. The type of `nullptr` is `nullptr_t`, which can be implicitly converted to any pointer or member pointer type, and can be compared equally or unequally with them.\n\nYou can try to compile the following code using clang++:\n\n```cpp\n#include <iostream>\n#include <type_traits>\n\nvoid foo(char *);\nvoid foo(int);\n\nint main() {\n    if (std::is_same<decltype(NULL), decltype(0)>::value)\n        std::cout << \"NULL == 0\" << std::endl;\n    if (std::is_same<decltype(NULL), decltype((void*)0)>::value)\n        std::cout << \"NULL == (void *)0\" << std::endl;\n    if (std::is_same<decltype(NULL), std::nullptr_t>::value)\n        std::cout << \"NULL == nullptr\" << std::endl;\n\n    foo(0);          // will call foo(int)\n    // foo(NULL);    // doesn't compile\n    foo(nullptr);    // will call foo(char*)\n    return 0;\n}\n\nvoid foo(char *) {\n    std::cout << \"foo(char*) is called\" << std::endl;\n}\nvoid foo(int i) {\n    std::cout << \"foo(int) is called\" << std::endl;\n}\n```\n\nThe outputs are:\n\n```bash\nfoo(int) is called\nfoo(char*) is called\n```\n\nFrom the output we can see that `NULL` is different from `0` and `nullptr`.\nSo, develop the habit of using `nullptr` directly.\n\nIn addition, in the above code, we used `decltype` and\n`std::is_same` which are modern C++ syntax.\nIn simple terms, `decltype` is used for type derivation,\nand `std::is_same` is used to compare the equality of the two types.\nWe will discuss them in detail later in the [decltype](#decltype) section.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "constexpr",
    "content": "### constexpr\n\nC++ itself already has the concept of constant expressions, such as 1+2,\n3\\*4. Such expressions always produce the same result without any side effects.\nIf the compiler can directly optimize and embed these expressions into the program at\ncompile-time, it will increase the performance of the program. A very obvious example\nis in the definition phase of an array:\n\n```cpp\n#include <iostream>\n#define LEN 10\n\nint len_foo() {\n    int i = 2;\n    return i;\n}\nconstexpr int len_foo_constexpr() {\n    return 5;\n}\n\nconstexpr int fibonacci(const int n) {\n    return n == 1 || n == 2 ? 1 : fibonacci(n-1) + fibonacci(n-2);\n}\n\n\nint main() {\n    char arr_1[10];                      // legal\n    char arr_2[LEN];                     // legal\n\n    int len = 10;\n    // char arr_3[len];                  // illegal\n\n    const int len_2 = len + 1;\n    constexpr int len_2_constexpr = 1 + 2 + 3;\n    // char arr_4[len_2];                // illegal, but ok for most of the compilers\n    char arr_4[len_2_constexpr];         // legal\n\n    // char arr_5[len_foo()+5];          // illegal\n    char arr_6[len_foo_constexpr() + 1]; // legal\n\n    // 1, 1, 2, 3, 5, 8, 13, 21, 34, 55\n    std::cout << fibonacci(10) << std::endl;\n\n    return 0;\n}\n```\n\nIn the above example, `char arr_4[len_2]` may be confusing because `len_2` has been defined as a constant.\nWhy is `char arr_4[len_2]` still illegal?\nThis is because the length of the array in the C++ standard must be a constant expression,\nand for `len_2`, this is a `const` constant, not a constant expression,\nso even if this behavior is supported by most compilers, but it is an illegal behavior,\nwe need to use the `constexpr` feature introduced in C++11, which will be introduced next,\nto solve this problem; for `arr_5`, before C++98 The compiler cannot know that `len_foo()`\nactually returns a constant at runtime, which causes illegal production.\n\n> Note that most compilers now have their compiler optimizations.\n> Many illegal behaviors become legal under the compiler's optimization.\n> If you need to reproduce the error, you need to use the old version of the compiler.\n\nC++11 provides `constexpr` to let the user explicitly declare that the function or\nobject constructor will become a constant expression at compile time.\nThis keyword explicitly tells the compiler that it should verify that `len_foo`\nshould be a compile-time constant expression.\n\nIn addition, the function of `constexpr` can use recursion:\n\n```cpp\nconstexpr int fibonacci(const int n) {\n    return n == 1 || n == 2 ? 1 : fibonacci(n-1) + fibonacci(n-2);\n}\n```\n\nStarting with C++14,\nthe constexpr function can use simple statements such as local variables,\nloops, and branches internally.\nFor example, the following code cannot be compiled under the C++11 standard:\n\n```cpp\nconstexpr int fibonacci(const int n) {\n    if(n == 1) return 1;\n    if(n == 2) return 1;\n    return fibonacci(n-1) + fibonacci(n-2);\n}\n```\n\nTo do this, we can write a simplified version like this\nto make the function available from C++11:\n\n```cpp\nconstexpr int fibonacci(const int n) {\n    return n == 1 || n == 2 ? 1 : fibonacci(n-1) + fibonacci(n-2);\n}\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "2.2 Variables and initialization",
    "content": "## 2.2 Variables and initialization\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "if-switch",
    "content": "### if-switch\n\nIn traditional C++, the declaration of a variable can declare a temporary variable `int`\neven though it can be located anywhere, even within a `for` statement,\nbut there is always no way to declare a temporary variable in the `if` and `switch` statements.\nE.g:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> vec = {1, 2, 3, 4};\n\n    // since c++17, can be simplified by using `auto`\n    const std::vector<int>::iterator itr = std::find(vec.begin(), vec.end(), 2);\n    if (itr != vec.end()) {\n        *itr = 3;\n    }\n\n    if (const std::vector<int>::iterator itr = std::find(vec.begin(), vec.end(), 3);\n        itr != vec.end()) {\n        *itr = 4;\n    }\n\n    // should output: 1, 4, 3, 4. can be simplified using `auto`\n    for (std::vector<int>::iterator element = vec.begin(); element != vec.end(); \n        ++element)\n        std::cout << *element << std::endl;\n}\n```\n\nIn the above code, we can see that the `itr` variable is defined in the scope of\nthe entire `main()`, which causes us to rename the other when a variable need to traverse\nthe entire `std::vector` again. C++17 eliminates this limitation so that\nwe can do this in if(or switch):\n\n```cpp\nif (const std::vector<int>::iterator itr = std::find(vec.begin(), vec.end(), 3);\n    itr != vec.end()) {\n    *itr = 4;\n}\n```\n\nIs it similar to the Go?\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "Initializer list",
    "content": "### Initializer list\n\nInitialization is a very important language feature,\nthe most common one is when the object is initialized.\nIn traditional C++, different objects have different initialization methods,\nsuch as ordinary arrays, PODs (**P**lain **O**ld **D**ata,\ni.e. classes without constructs, destructors, and virtual functions)\nOr struct type can be initialized with `{}`,\nwhich is what we call the initialization list.\nFor the initialization of the class object,\nyou need to use the copy construct,\nor you need to use `()`.\nThese different methods are specific to each other and cannot be generic.\nE.g:\n\n```cpp\n#include <iostream>\n#include <vector>\n\nclass Foo {\npublic:\n    int value_a;\n    int value_b;\n    Foo(int a, int b) : value_a(a), value_b(b) {}\n};\n\nint main() {\n    // before C++11\n    int arr[3] = {1, 2, 3};\n    Foo foo(1, 2);\n    std::vector<int> vec = {1, 2, 3, 4, 5};\n\n    std::cout << \"arr[0]: \" << arr[0] << std::endl;\n    std::cout << \"foo:\" << foo.value_a << \", \" << foo.value_b << std::endl;\n    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {\n        std::cout << *it << std::endl;\n    }\n    return 0;\n}\n```\n\nTo solve this problem,\nC++11 first binds the concept of the initialization list to the type\nand calls it `std::initializer_list`,\nallowing the constructor or other function to use the initialization list\nlike a parameter, which is the initialization of class objects provides\na unified bridge between normal arrays and POD initialization methods,\nsuch as:\n\n```cpp\n#include <initializer_list>\n#include <vector>\n#include <iostream>\n\nclass MagicFoo {\npublic:\n    std::vector<int> vec;\n    MagicFoo(std::initializer_list<int> list) {\n        for (std::initializer_list<int>::iterator it = list.begin();\n             it != list.end(); ++it)\n            vec.push_back(*it);\n    }\n};\nint main() {\n    // after C++11\n    MagicFoo magicFoo = {1, 2, 3, 4, 5};\n\n    std::cout << \"magicFoo: \";\n    for (std::vector<int>::iterator it = magicFoo.vec.begin(); \n        it != magicFoo.vec.end(); ++it) \n        std::cout << *it << std::endl;\n}\n```\n\nThis constructor is called the initialize list constructor, and the type with\nthis constructor will be specially taken care of during initialization.\n\nIn addition to the object construction, the initialization list can also\nbe used as a formal parameter of a normal function, for example:\n\n```Cpp\npublic:\n    void foo(std::initializer_list<int> list) {\n        for (std::initializer_list<int>::iterator it = list.begin();\n            it != list.end(); ++it) vec.push_back(*it);\n    }\n\nmagicFoo.foo({6,7,8,9});\n```\n\nSecond, C++11 also provides a uniform syntax for initializing arbitrary objects, such as:\n\n```cpp\nFoo foo2 {3, 4};\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "Structured binding",
    "content": "### Structured binding\n\nStructured bindings provide functionality similar to the multiple return values\nprovided in other languages. In the chapter on containers,\nwe will learn that C++11 has added a `std::tuple` container for\nconstructing a tuple that encloses multiple return values. But the flaw\nis that C++11/14 does not provide a simple way to get and define\nthe elements in the tuple from the tuple,\nalthough we can unpack the tuple using `std::tie`\nBut we still have to be very clear about how many objects this tuple contains,\nwhat type of each object is, very troublesome.\n\nC++17 completes this setting,\nand the structured bindings let us write code like this:\n\n```cpp\n#include <iostream>\n#include <tuple>\n\nstd::tuple<int, double, std::string> f() {\n    return std::make_tuple(1, 2.3, \"456\");\n}\n\nint main() {\n    auto [x, y, z] = f();\n    std::cout << x << \", \" << y << \", \" << z << std::endl;\n    return 0;\n}\n```\n\nThe `auto` type derivation is described in the\n[auto type inference](#auto) section.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "2.3 Type inference",
    "content": "## 2.3 Type inference\n\nIn traditional C and C++, the types of parameters must be clearly defined, which does not help us to quickly encode, especially when we are faced with a large number of complex template types, we must indicate the type of variables to proceed. Subsequent coding, which not only slows down our development efficiency but also makes the code stinking and long.\n\nC++11 introduces the two keywords `auto` and `decltype` to implement type derivation, letting the compiler worry about the type of the variable. This makes C++ the same as other modern programming languages, in a way that provides the habit of not having to worry about variable types.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "auto",
    "content": "### auto\n\n`auto` has been in C++ for a long time, but it always exists as an indicator of a storage type, coexisting with `register`. In traditional C++, if a variable is not declared as a `register` variable, it is automatically treated as an `auto` variable. And with `register` being deprecated (used as a reserved keyword in C++17 and later used, it doesn't currently make sense), the semantic change to `auto` is very natural.\n\nOne of the most common and notable examples of type derivation using `auto` is the iterator. You should see the lengthy iterative writing in traditional C++ in the previous section:\n\n```cpp\n// before C++11\n// cbegin() returns vector<int>::const_iterator\n// and therefore it is type vector<int>::const_iterator\nfor(vector<int>::const_iterator it = vec.cbegin(); it != vec.cend(); ++it)\n```\n\nWhen we have `auto`:\n\n```cpp\n#include <initializer_list>\n#include <vector>\n#include <iostream>\n\nclass MagicFoo {\npublic:\n    std::vector<int> vec;\n    MagicFoo(std::initializer_list<int> list) {\n        for (auto it = list.begin(); it != list.end(); ++it) {\n            vec.push_back(*it);\n        }\n    }\n};\n\nint main() {\n    MagicFoo magicFoo = {1, 2, 3, 4, 5};\n    std::cout << \"magicFoo: \";\n    for (auto it = magicFoo.vec.begin(); it != magicFoo.vec.end(); ++it) {\n        std::cout << *it << \", \";\n    }\n    std::cout << std::endl;\n    return 0;\n}\n```\n\nSome other common usages:\n\n```cpp\nauto i = 5;              // i as int\nauto arr = new auto(10); // arr as int *\n```\n\nSince C++ 14, `auto` can even be used as function arguments in generic lambda expressions,\nand such functionality is generalized to normal functions in C++ 20.\nConsider the following example:\n\n```cpp\nauto add14 = [](auto x, auto y) -> int {\n    return x+y;\n}\n\nint add20(auto x, auto y) {\n    return x+y;\n}\n\nauto i = 5; // type int\nauto j = 6; // type int\nstd::cout << add14(i, j) << std::endl;\nstd::cout << add20(i, j) << std::endl;\n```\n\n> **Note**: `auto` cannot be used to derive array types yet:\n>\n> ```cpp\n> auto auto_arr2[10] = {arr};   // illegal, can't infer array type\n>\n> 2.6.auto.cpp:30:19: error: 'auto_arr2' declared as array of 'auto'\n>     auto auto_arr2[10] = {arr};\n> ```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "decltype",
    "content": "### decltype\n\nThe `decltype` keyword is used to solve the defect that the auto keyword\ncan only type the variable. Its usage is very similar to `typeof`:\n\n```cpp\ndecltype(expression)\n```\n\nSometimes we may need to calculate the type of an expression, for example:\n\n```cpp\nauto x = 1;\nauto y = 2;\ndecltype(x+y) z;\n```\n\nYou have seen in the previous example that\n`decltype` is used to infer the usage of the type.\nThe following example is to determine\nif the above variables `x, y, z` are of the same type:\n\n```cpp\nif (std::is_same<decltype(x), int>::value)\n    std::cout << \"type x == int\" << std::endl;\nif (std::is_same<decltype(x), float>::value)\n    std::cout << \"type x == float\" << std::endl;\nif (std::is_same<decltype(x), decltype(z)>::value)\n    std::cout << \"type z == type x\" << std::endl;\n```\n\nAmong them, `std::is_same<T, U>` is used to determine whether\nthe two types `T` and `U` are equal. The output is:\n\n```\ntype x == int\ntype z == type x\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "tail type inference",
    "content": "### tail type inference\n\nYou may think that whether `auto` can be used to deduce the return type of a function. Still consider an example of an add function, which we have to write in traditional C++:\n\n```cpp\ntemplate<typename R, typename T, typename U>\nR add(T x, U y) {\n    return x+y;\n}\n```\n\n> Note: There is no difference between typename and class in the template parameter list. Before the keyword typename appears, class is used to define the template parameters. However, when defining a variable with [nested dependency type](https://en.cppreference.com/w/cpp/language/dependent_name#The_typename_disambiguator_for_dependent_names) in the template, you need to use typename to eliminate ambiguity.\n\nSuch code is very ugly because the programmer must explicitly\nindicate the return type when using this template function.\nBut in fact, we don't know what kind of operation\nthe `add()` function will do, and what kind of return type to get.\n\nThis problem was solved in C++11. Although you may immediately\nreact to using `decltype` to derive the type of `x+y`,\nwrite something like this:\n\n```cpp\ndecltype(x+y) add(T x, U y)\n```\n\nBut in fact, this way of writing can not be compiled.\nThis is because `x` and `y` have not been defined\nwhen the compiler reads decltype(x+y).\nTo solve this problem, C++11 also introduces a trailing return type,\nwhich uses the auto keyword to post the return type:\n\n```cpp\ntemplate<typename T, typename U>\nauto add2(T x, U y) -> decltype(x+y){\n    return x + y;\n}\n```\n\nThe good news is that from C++14 it is possible to directly derive the return value of\na normal function, so the following way becomes legal:\n\n```cpp\ntemplate<typename T, typename U>\nauto add3(T x, U y){\n    return x + y;\n}\n```\n\nYou can check if the type derivation is correct:\n\n```cpp\n// after c++11\nauto w = add2<int, double>(1, 2.0);\nif (std::is_same<decltype(w), double>::value) {\n    std::cout << \"w is double: \";\n}\nstd::cout << w << std::endl;\n\n// after c++14\nauto q = add3<double, int>(1.0, 2);\nstd::cout << \"q: \" << q << std::endl;\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "decltype(auto)",
    "content": "### decltype(auto)\n\n`decltype(auto)` is a slightly more complicated use of C++14.\n\n> To understand it you need to know the concept of parameter forwarding\n> in C++, which we will cover in detail in the\n> [Language Runtime Enhancements](./03-runtime.md) chapter,\n> and you can come back to the contents of this section later.\n\nIn simple terms, `decltype(auto)` is mainly used to derive\nthe return type of a forwarding function or package,\nwhich does not require us to explicitly specify\nthe parameter expression of `decltype`.\nConsider the following example, when we need to wrap the following\ntwo functions:\n\n```cpp\nstd::string  lookup1();\nstd::string& lookup2();\n```\n\nIn C++11:\n\n```cpp\nstd::string look_up_a_string_1() {\n    return lookup1();\n}\nstd::string& look_up_a_string_2() {\n    return lookup2();\n}\n```\n\nWith `decltype(auto)`, we can let the compiler do this annoying parameter forwarding:\n\n```cpp\ndecltype(auto) look_up_a_string_1() {\n    return lookup1();\n}\ndecltype(auto) look_up_a_string_2() {\n    return lookup2();\n}\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "2.4 Control flow",
    "content": "## 2.4 Control flow\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "if constexpr",
    "content": "### if constexpr\n\nAs we saw at the beginning of this chapter, we know that C++11 introduces the `constexpr` keyword, which compiles expressions or functions into constant results. A natural idea is that if we introduce this feature into the conditional judgment, let the code complete the branch judgment at compile-time, can it make the program more efficient? C++17 introduces the `constexpr` keyword into the `if` statement, allowing you to declare the condition of a constant expression in your code. Consider the following code:\n\n```cpp\n#include <iostream>\n\ntemplate<typename T>\nauto print_type_info(const T& t) {\n    if constexpr (std::is_integral<T>::value) {\n        return t + 1;\n    } else {\n        return t + 0.001;\n    }\n}\nint main() {\n    std::cout << print_type_info(5) << std::endl;\n    std::cout << print_type_info(3.14) << std::endl;\n}\n```\n\nAt compile time, the actual code will behave as follows:\n\n```cpp\nint print_type_info(const int& t) {\n    return t + 1;\n}\ndouble print_type_info(const double& t) {\n    return t + 0.001;\n}\nint main() {\n    std::cout << print_type_info(5) << std::endl;\n    std::cout << print_type_info(3.14) << std::endl;\n}\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "Range-based for loop",
    "content": "### Range-based for loop\n\nFinally, C++11 introduces a range-based iterative method, and we can write loops that are as concise\nas Python, and we can further simplify the previous example:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> vec = {1, 2, 3, 4};\n    if (auto itr = std::find(vec.begin(), vec.end(), 3); itr != vec.end()) *itr = 4;\n    for (auto element : vec)\n        std::cout << element << std::endl; // read only\n    for (auto &element : vec) {\n        element += 1;                      // writeable\n    }\n    for (auto element : vec)\n        std::cout << element << std::endl; // read only\n}\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "2.5 Templates",
    "content": "## 2.5 Templates\n\nC++ templates have always been a special art of the language, and templates can even be used independently as a new language. The philosophy of the template is to throw all the problems that can be processed at compile time into the compile time, and only deal with those core dynamic services at runtime, to greatly optimize the performance of the runtime. Therefore, templates are also regarded by many as one of the black magic of C++.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "Extern templates",
    "content": "### Extern templates\n\nIn traditional C++, templates are instantiated by the compiler only when they are used. In other words, as long as a fully defined template is encountered in the code compiled in each compilation unit (file), it will be instantiated. This results in an increase in compile time due to repeated instantiations. Also, we have no way to tell the compiler not to trigger the instantiation of the template.\n\nTo this end, C++11 introduces an external template that extends the syntax of the original mandatory compiler to instantiate a template at a specific location, allowing us to explicitly tell the compiler when to instantiate the template:\n\n```cpp\ntemplate class std::vector<bool>;          // force instantiation\nextern template class std::vector<double>; // should not instantiation in current file\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "The \">\"",
    "content": "### The \">\"\n\nIn the traditional C++ compiler, `>>` is always treated as a right shift operator. But actually we can easily write the code for the nested template:\n\n```cpp\nstd::vector<std::vector<int>> matrix;\n```\n\nThis is not compiled under the traditional C++ compiler,\nand C++11 starts with continuous right angle brackets that become legal\nand can be compiled successfully.\nEven the following writing can be compiled by:\n\n```cpp\ntemplate<bool T>\nclass MagicType {\n    bool magic = T;\n};\n\n// in main function:\nstd::vector<MagicType<(1>2)>> magic; // legal, but not recommended\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "Type alias templates",
    "content": "### Type alias templates\n\nBefore you understand the type alias template, you need to understand the difference between \"template\" and \"type\". Carefully understand this sentence: **Templates are used to generate types.** In traditional C++, `typedef` can define a new name for the type, but there is no way to define a new name for the template. Because the template is not a type. E.g:\n\n```cpp\ntemplate<typename T, typename U>\nclass MagicType {\npublic:\n    T dark;\n    U magic;\n};\n\n// not allowed\ntemplate<typename T>\ntypedef MagicType<std::vector<T>, std::string> FakeDarkMagic;\n```\n\nC++11 uses `using` to introduce the following form of writing, and at the same time supports the same effect as the traditional `typedef`:\n\n> Usually, we use `typedef` to define the alias syntax: `typedef original name new name; `, but the definition syntax for aliases such as function pointers is different, which usually causes a certain degree of difficulty for direct reading.\n\n```cpp\ntypedef int (*process)(void *);\nusing NewProcess = int(*)(void *);\ntemplate<typename T>\nusing TrueDarkMagic = MagicType<std::vector<T>, std::string>;\n\nint main() {\n    TrueDarkMagic<bool> you;\n}\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "Variadic templates",
    "content": "### Variadic templates\n\nThe template has always been one of C++'s unique **Black Magic**.\nIn traditional C++,\nboth a class template and a function template could only accept\na fixed set of template parameters as specified;\nC++11 added a new representation, allowing any number,\ntemplate parameters of any category,\nand there is no need to fix the number of parameters when defining.\n\n```cpp\ntemplate<typename... Ts> class Magic;\n```\n\nThe template class Magic object can accept an unrestricted number of typename as\na formal parameter of the template, such as the following definition:\n\n```cpp\nclass Magic<int,\n            std::vector<int>,\n            std::map<std::string,\n            std::vector<int>>> darkMagic;\n```\n\nSince it is arbitrary, a template parameter with a number of 0 is also possible: `class Magic<> nothing;`.\n\nIf you do not want to generate 0 template parameters, you can manually define at least one template parameter:\n\n```cpp\ntemplate<typename Require, typename... Args> class Magic;\n```\n\nThe variable length parameter template can also be directly adjusted to the template function.\nThe `printf` function in the traditional C, although it can also reach the call of an indefinite number of formal parameters, is not class safe. In addition to the variable-length parameter functions that define class safety, C++11 can also make printf-like functions naturally handle objects that are not self-contained. In addition to the use of `...` in the template parameters to indicate the indefinite length of the template parameters, the function parameters also use the same representation to represent the indefinite length parameters, which provides a convenient means for us to simply write variable length parameter functions, such as:\n\n```cpp\ntemplate<typename... Args> void printf(const std::string &str, Args... args);\n```\n\nThen we define variable length template parameters,\nhow to unpack the parameters?\n\nFirst, we can use `sizeof...` to calculate the number of arguments:\n\n```cpp\n#include <iostream>\ntemplate<typename... Ts>\nvoid magic(Ts... args) {\n    std::cout << sizeof...(args) << std::endl;\n}\n```\n\nWe can pass any number of arguments to the `magic` function:\n\n```cpp\nmagic();      // 0\nmagic(1);     // 1\nmagic(1, \"\"); // 2\n```\n\nSecond, the parameters are unpacked. So far there is no simple way to process\nthe parameter package, but there are two classic processing methods:\n\n**1. Recursive template function**\n\nRecursion is a very easy way to think of and the most classic approach. This method continually recursively passes template parameters to the function, thereby achieving the purpose of recursively traversing all template parameters:\n\n```cpp\n#include <iostream>\ntemplate<typename T0>\nvoid printf1(T0 value) {\n    std::cout << value << std::endl;\n}\ntemplate<typename T, typename... Ts>\nvoid printf1(T value, Ts... args) {\n    std::cout << value << std::endl;\n    printf1(args...);\n}\nint main() {\n    printf1(1, 2, \"123\", 1.1);\n    return 0;\n}\n```\n\n**2. Variable parameter template expansion**\n\nYou should feel that this is very cumbersome. Added support for variable parameter template expansion in C++17, so you can write `printf` in a function:\n\n```cpp\ntemplate<typename T0, typename... T>\nvoid printf2(T0 t0, T... t) {\n    std::cout << t0 << std::endl;\n    if constexpr (sizeof...(t) > 0) printf2(t...);\n}\n```\n\n> In fact, sometimes we use variable parameter templates, but we don't necessarily need to traverse the parameters one by one. We can use the features of `std::bind` and perfect forwarding to achieve the binding of functions and parameters, thus achieving success. The purpose of the call.\n\n**3. Initialize list expansion**\n\nRecursive template functions are standard practice, but the obvious drawback is that you must define a function that terminates recursion.\n\nHere is a description of the black magic that is expanded using the initialization list:\n\n```cpp\ntemplate<typename T, typename... Ts>\nauto printf3(T value, Ts... args) {\n    std::cout << value << std::endl;\n    (void) std::initializer_list<T>{([&args] {\n        std::cout << args << std::endl;\n    }(), value)...};\n}\n```\n\nIn this code, the initialization list provided in C++11 and the properties of the Lambda expression (mentioned in the next section) are additionally used.\n\nBy initializing the list, `(lambda expression, value)...` will be expanded. Due to the appearance of the comma expression, the previous lambda expression is executed first, and the output of the parameter is completed.\nTo avoid compiler warnings, we can explicitly convert `std::initializer_list` to `void`.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "Fold expression",
    "content": "### Fold expression\n\nIn C++ 17, this feature of the variable length parameter is further brought to the expression, consider the following example:\n\n```cpp\n#include <iostream>\ntemplate<typename ... T>\nauto sum(T ... t) {\n    return (t + ...);\n}\nint main() {\n    std::cout << sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) << std::endl;\n}\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "Non-type template parameter deduction",
    "content": "### Non-type template parameter deduction\n\nWhat we mainly mentioned above is a form of template parameters: type template parameters.\n\n```cpp\ntemplate <typename T, typename U>\nauto add(T t, U u) {\n    return t+u;\n}\n```\n\nThe parameters of the template `T` and `U` are specific types.\nBut there is also a common form of template parameter that allows different literals\nto be template parameters, i.e. non-type template parameters:\n\n```cpp\ntemplate <typename T, int BufSize>\nclass buffer_t {\npublic:\n    T& alloc();\n    void free(T& item);\nprivate:\n    T data[BufSize];\n}\n\nbuffer_t<int, 100> buf; // 100 as template parameter\n```\n\nIn this form of template parameters, we can pass `100` as a parameter to the template.\nAfter C++11 introduced the feature of type derivation, we will naturally ask, since the template parameters here.\nPassing with a specific literal, can the compiler assist us in type derivation,\nBy using the placeholder `auto`, there is no longer a need to explicitly specify the type?\nFortunately, C++17 introduces this feature, and we can indeed use the `auto` keyword to let the compiler assist in the completion of specific types of derivation.\nE.g:\n\n```cpp\ntemplate <auto value> void foo() {\n    std::cout << value << std::endl;\n    return;\n}\n\nint main() {\n    foo<10>();  // value as int\n}\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "2.6 Object-oriented",
    "content": "## 2.6 Object-oriented\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "Delegate constructor",
    "content": "### Delegate constructor\n\nC++11 introduces the concept of a delegate construct, which allows a constructor to call another constructor\nin a constructor in the same class, thus simplifying the code:\n\n```cpp\n#include <iostream>\nclass Base {\npublic:\n    int value1;\n    int value2;\n    Base() {\n        value1 = 1;\n    }\n    Base(int value) : Base() { // delegate Base() constructor\n        value2 = value;\n    }\n};\n\nint main() {\n    Base b(2);\n    std::cout << b.value1 << std::endl;\n    std::cout << b.value2 << std::endl;\n}\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "Inheritance constructor",
    "content": "### Inheritance constructor\n\nIn traditional C++, constructors need to pass arguments one by one if they need inheritance, which leads to inefficiency. C++11 introduces the concept of inheritance constructors using the keyword using:\n\n```cpp\n#include <iostream>\nclass Base {\npublic:\n    int value1;\n    int value2;\n    Base() {\n        value1 = 1;\n    }\n    Base(int value) : Base() { // delegate Base() constructor\n        value2 = value;\n    }\n};\nclass Subclass : public Base {\npublic:\n    using Base::Base; // inheritance constructor\n};\nint main() {\n    Subclass s(3);\n    std::cout << s.value1 << std::endl;\n    std::cout << s.value2 << std::endl;\n}\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "Explicit virtual function overwrite",
    "content": "### Explicit virtual function overwrite\n\nIn traditional C++, it is often prone to accidentally overloading virtual functions. E.g:\n\n```cpp\nstruct Base {\n    virtual void foo();\n};\nstruct SubClass: Base {\n    void foo();\n};\n```\n\n`SubClass::foo` may not be a programmer trying to overload a virtual function, just adding a function with the same name. Another possible scenario is that when the virtual function of the base class is deleted, the subclass owns the old function and no longer overloads the virtual function and turns it into a normal class method, which has catastrophic consequences.\n\nC++11 introduces the two keywords `override` and `final` to prevent this from happening.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "override",
    "content": "### override\n\nWhen overriding a virtual function, introducing the `override` keyword will explicitly tell the compiler to overload, and the compiler will check if the base function has such a virtual function with consistent function signature, otherwise it will not compile:\n\n```cpp\nstruct Base {\n    virtual void foo(int);\n};\nstruct SubClass: Base {\n    virtual void foo(int) override; // legal\n    virtual void foo(float) override; // illegal, no virtual function in super class\n};\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "final",
    "content": "### final\n\n`final` is to prevent the class from being continued to inherit and to terminate\nthe virtual function to continue to be overloaded.\n\n```cpp\nstruct Base {\n    virtual void foo() final;\n};\nstruct SubClass1 final: Base {\n}; // legal\n\nstruct SubClass2 : SubClass1 {\n}; // illegal, SubClass1 has final\n\nstruct SubClass3: Base {\n    void foo(); // illegal, foo has final\n};\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "Explicit delete default function",
    "content": "### Explicit delete default function\n\nIn traditional C++, if the programmer does not provide it, the compiler will default to generating default constructors, copy constructs, assignment operators, and destructors for the object. Besides, C++ also defines operators such as `new` `delete` for all classes. This part of the function can be overridden when the programmer needs it.\n\nThis raises some requirements: the ability to accurately control the generation of default functions cannot be controlled. For example, when copying a class is prohibited, the copy constructor and the assignment operator must be declared as `private`. Trying to use these undefined functions will result in compilation or link errors, which is a very unconventional way.\n\nAlso, the default constructor generated by the compiler cannot exist at the same time as the user-defined constructor. If the user defines any constructor, the compiler will no longer generate the default constructor, but sometimes we want to have both constructors at the same time, which is awkward.\n\nC++11 provides a solution to the above requirements, allowing explicit declarations to take or reject functions that come with the compiler. E.g:\n\n```cpp\nclass Magic {\n    public:\n    Magic() = default; // explicit let compiler use default constructor\n    Magic& operator=(const Magic&) = delete; // explicit declare refuse constructor\n    Magic(int magic_number);\n}\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "Strongly typed enumerations",
    "content": "### Strongly typed enumerations\n\nIn traditional C++, enumerated types are not type-safe, and enumerated types are treated as integers, which allows two completely different enumerated types to be directly compared (although the compiler gives the check, but not all), ** Even the enumeration value names of different enum types in the same namespace cannot be the same**, which is usually not what we want to see.\n\nC++11 introduces an enumeration class and declares it using the syntax of `enum class`:\n\n```cpp\nenum class new_enum : unsigned int {\n    value1,\n    value2,\n    value3 = 100,\n    value4 = 100\n};\n```\n\nThe enumeration thus defined implements type safety. First, it cannot be implicitly converted to an integer, nor can it be compared to integer numbers, and it is even less likely to compare enumerated values of different enumerated types. But if the values specified are the same between the same enumerated values, then you can compare:\n\n```cpp\nif (new_enum::value3 == new_enum::value4) { // true\n    std::cout << \"new_enum::value3 == new_enum::value4\" << std::endl;\n}\n```\n\nIn this syntax, the enumeration type is followed by a colon and a type keyword to specify the type of the enumeration value in the enumeration, which allows us to assign a value to the enumeration (int is used by default when not specified).\n\nAnd we want to get the value of the enumeration value, we will have to explicitly type conversion, but we can overload the `<<` operator to output, you can collect the following code snippet:\n\n```cpp\n#include <iostream>\ntemplate<typename T>\nstd::ostream& operator<<(\n    typename std::enable_if<std::is_enum<T>::value,\n        std::ostream>::type& stream, const T& e)\n{\n    return stream << static_cast<typename std::underlying_type<T>::type>(e);\n}\n```\n\nAt this point, the following code will be able to be compiled:\n\n```cpp\nstd::cout << new_enum::value3 << std::endl\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "Conclusion",
    "content": "## Conclusion\n\nThis section introduces the enhancements to language usability in modern C++, which I believe are the most important features that almost everyone needs to know and use:\n\n1. Auto type derivation\n2. Scope for iteration\n3. Initialization list\n4. Variable parameter template\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "Exercises",
    "content": "## Exercises\n\n1. Using structured binding, implement the following functions with just one line of function code:\n\n   ```cpp\n   #include <string>\n   #include <map>\n   #include <iostream>\n\n   template <typename Key, typename Value, typename F>\n   void update(std::map<Key, Value>& m, F foo) {\n       // TODO:\n   }\n   int main() {\n       std::map<std::string, long long int> m {\n           {\"a\", 1},\n           {\"b\", 2},\n           {\"c\", 3}\n       };\n       update(m, [](std::string key) {\n           return std::hash<std::string>{}(key);\n       });\n       for (auto&& [key, value] : m)\n           std::cout << key << \":\" << value << std::endl;\n   }\n   ```\n\n2. Try to implement a function for calculating the mean with [Fold Expression](#Fold-expression), allowing any arguments to be passed in.\n\n> Refer to the answer [see this](../../exercises/2).\n\n[Table of Content](./toc.md) | [Previous Chapter](./01-intro.md) | [Next Chapter: Language Runtime Enhancements](./03-runtime.md)\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 02-usability.md",
    "title": "Licenses",
    "content": "## Licenses\n\n<a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png\" /></a><br />This work was written by [Ou Changkun](https://changkun.de) and licensed under a <a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>. The code of this repository is open sourced under the [MIT license](../../LICENSE).\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 01-intro.md",
    "title": "Introduction",
    "content": "---\ntitle: \"Chapter 01: Towards Modern C++\"\ntype: book-en-us\norder: 1\n---\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 01-intro.md",
    "title": "Chapter 01: Towards Modern C++",
    "content": "# Chapter 01: Towards Modern C++\n\n[TOC]\n\n**Compilation Environment**: This book will use `clang++` as the only compiler used,\nand always use the `-std=c++2a` compilation flag in your code.\n\n```bash\n> clang++ -v\nApple LLVM version 10.0.1 (clang-1001.0.46.4)\nTarget: x86_64-apple-darwin18.6.0\nThread model: posix\nInstalledDir: /Library/Developer/CommandLineTools/usr/bin\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 01-intro.md",
    "title": "1.1 Deprecated Features",
    "content": "## 1.1 Deprecated Features\n\nBefore learning modern C++, let's take a look at the main features that have deprecated since C++11:\n\n> **Note**: Deprecation is not completely unusable, it is only intended to imply that features will disappear from future standards and should be avoided. But, the deprecated features are still part of the standard library, and most of the features are actually \"permanently\" reserved for compatibility reasons.\n\n- **The string literal constant is no longer allowed to be assigned to a `char *`. If you need to assign and initialize a `char *` with a string literal constant, you should use `const char *` or `auto`.**\n\n  ```cpp\n  char *str = \"hello world!\"; // A deprecation warning will appear\n  ```\n\n- **C++98 exception description, `unexpected_handler`, `set_unexpected()` and other related features are deprecated and should use `noexcept`.**\n\n- **`auto_ptr` is deprecated and `unique_ptr` should be used.**\n\n- **`register` keyword is deprecated and can be used but no longer has any practical meaning.**\n\n- **The `++` operation of the `bool` type is deprecated.**\n\n- **If a class has a destructor, the properties for which it generates copy constructors and copy assignment operators are deprecated.**\n\n- **C language style type conversion is deprecated (ie using `(convert_type)`) before variables, and `static_cast`, `reinterpret_cast`, `const_cast` should be used for type conversion.**\n\n- **In particular, some of the C standard libraries that can be used are deprecated in the latest C++17 standard, such as `<ccomplex>`, `<cstdalign>`, `<cstdbool>` and `<ctgmath>` etc.**\n\n- ... and many more\n\nThere are also other features such as parameter binding (C++11 provides `std::bind` and `std::function`), `export` etc. are also deprecated. These features mentioned above **If you have never used or heard of it, please don't try to understand them. You should move closer to the new standard and learn new features directly**. After all, technology is moving forward.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 01-intro.md",
    "title": "1.2 Compatibilities with C",
    "content": "## 1.2 Compatibilities with C\n\nFor some force majeure and historical reasons, we had to use some C code (even old C code) in C++, for example, Linux system calls. Before the advent of modern C++, most people talked about \"what is the difference between C and C++\". Generally speaking, in addition to answering the object-oriented class features and the template features of generic programming, there is no other opinion or even a direct answer. \"Almost\" is also a lot of people. The Venn diagram in Figure 1.2 roughly answers the C and C++ related compatibility.\n\n![Figure 1.2: Compatabilities between ISO C and ISO C++](../../assets/figures/comparison.png)\n\nFrom now on, you should have the idea that \"C++ is **not** a superset of C\" in your mind (and not from the beginning, later [References for further reading](#further-readings) The difference between C++98 and C99 is given). When writing C++, you should also avoid using program styles such as `void*` whenever possible. When you have to use C, you should pay attention to the use of `extern \"C\"`, separate the C language code from the C++ code, and then unify the link, for instance:\n\n```cpp\n// foo.h\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint add(int x, int y);\n\n#ifdef __cplusplus\n}\n#endif\n\n// foo.c\nint add(int x, int y) {\n    return x+y;\n}\n\n// 1.1.cpp\n#include \"foo.h\"\n#include <iostream>\n#include <functional>\n\nint main() {\n    [out = std::ref(std::cout << \"Result from C code: \" << add(1, 2))](){\n        out.get() << \".\\n\";\n    }();\n    return 0;\n}\n```\n\nYou should first compile the C code with `gcc`:\n\n```bash\ngcc -c foo.c\n```\n\nCompile and output the `foo.o` file, and link the C++ code to the `.o` file using `clang++` (or both compile to `.o` and then link them together):\n\n```bash\nclang++ 1.1.cpp foo.o -std=c++2a -o 1.1\n```\n\nOf course, you can use `Makefile` to compile the above code:\n\n```makefile\nC = gcc\nCXX = clang++\n\nSOURCE_C = foo.c\nOBJECTS_C = foo.o\n\nSOURCE_CXX = 1.1.cpp\n\nTARGET = 1.1\nLDFLAGS_COMMON = -std=c++2a\n\nall:\n\t$(C) -c $(SOURCE_C)\n\t$(CXX) $(SOURCE_CXX) $(OBJECTS_C) $(LDFLAGS_COMMON) -o $(TARGET)\n\nclean:\n\trm -rf *.o $(TARGET)\n```\n\n> **Note**: Indentation in `Makefile` is a tab instead of a space character. If you copy this code directly into your editor, the tab may be automatically replaced. Please ensure the indentation in the `Makefile` is done by tabs.\n>\n> If you don't know the use of `Makefile`, it doesn't matter. In this tutorial, you won't build code that is written too complicated. You can also read this book by simply using `clang++ -std=c++2a` on the command line.\n\nIf you are new to modern C++, you probably still don't understand the following small piece of code above, namely:\n\n```cpp\n[out = std::ref(std::cout << \"Result from C code: \" << add(1, 2))](){\n    out.get() << \".\\n\";\n}();\n```\n\nDon't worry at the moment, we will come to meet them in our later chapters.\n\n[Table of Content](./toc.md) | [Previous Chapter](./00-preface.md) | [Next Chapter: Language Usability Enhancements](./02-usability.md)\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 01-intro.md",
    "title": "Further Readings",
    "content": "## Further Readings\n\n- [A Tour of C++ (2nd Edition) Bjarne Stroustrup](https://www.amazon.com/dp/0134997832/ref=cm_sw_em_r_mt_dp_U_GogjDbHE2H53B)\n  [History of C++](http://en.cppreference.com/w/cpp/language/history)\n- [C++ compiler support](https://en.cppreference.com/w/cpp/compiler_support)\n- [Incompatibilities Between ISO C and ISO C++](http://david.tribble.com/text/cdiffs.htm#C99-vs-CPP98)\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 01-intro.md",
    "title": "Licenses",
    "content": "## Licenses\n\n<a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png\" /></a><br />This work was written by [Ou Changkun](https://changkun.de) and licensed under a <a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>. The code of this repository is open sourced under the [MIT license](../../LICENSE).\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 03-runtime.md",
    "title": "Introduction",
    "content": "---\ntitle: \"Chapter 03: Language Runtime Enhancements\"\ntype: book-en-us\norder: 3\n---\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 03-runtime.md",
    "title": "Chapter 03: Language Runtime Enhancements",
    "content": "# Chapter 03: Language Runtime Enhancements\n\n[TOC]\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 03-runtime.md",
    "title": "3.1 Lambda Expression",
    "content": "## 3.1 Lambda Expression\n\nLambda expressions are one of the most important features in modern C++, and Lambda expressions provide a feature like anonymous functions.\nAnonymous functions are used when a function is needed, but you dont want to use a name to call a function. There are many, many scenes like this.\nSo anonymous functions are almost standard in modern programming languages.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 03-runtime.md",
    "title": "Basics",
    "content": "### Basics\n\nThe basic syntax of a Lambda expression is as follows:\n\n```\n[capture list] (parameter list) mutable(optional) exception attribute -> return type {\n// function body\n}\n```\n\nThe above grammar rules are well understood except for the things in `[capture list]`,\nexcept that the function name of the general function is omitted.\nThe return value is in the form of a `->`\n(we have already mentioned this in the tail return type earlier in the previous section).\n\nThe so-called capture list can be understood as a type of parameter.\nThe internal function body of a lambda expression cannot use variables outside\nthe body of the function by default.\nAt this time, the capture list can serve to transfer external data.\nAccording to the behavior passed,\nthe capture list is also divided into the following types:\n\n#### 1. Value capture\n\nSimilar to parameter passing, the value capture is based on the fact that\nthe variable can be copied, except that the captured variable is copied\nwhen the lambda expression is created, not when it is called:\n\n```cpp\nvoid lambda_value_capture() {\n    int value = 1;\n    auto copy_value = [value] {\n        return value;\n    };\n    value = 100;\n    auto stored_value = copy_value();\n    std::cout << \"stored_value = \" << stored_value << std::endl;\n    // At this moment, stored_value == 1, and value == 100.\n    // Because copy_value has copied when its was created.\n}\n```\n\n#### 2. Reference capture\n\nSimilar to a reference pass, the reference capture saves the reference and the value changes.\n\n```cpp\nvoid lambda_reference_capture() {\n    int value = 1;\n    auto copy_value = [&value] {\n        return value;\n    };\n    value = 100;\n    auto stored_value = copy_value();\n    std::cout << \"stored_value = \" << stored_value << std::endl;\n    // At this moment, stored_value == 100, value == 100.\n    // Because copy_value stores reference\n}\n```\n\n#### 3. Implicit capture\n\nManually writing a capture list is sometimes very complicated.\nThis mechanical work can be handled by the compiler.\nAt this point, you can write a `&` or `=` to the compiler to\ndeclare the reference or value capture.\n\nTo summarize, capture provides the ability for lambda expressions\nto use external values. The four most common forms of\ncapture lists can be:\n\n- \\[\\] empty capture list\n- \\[name1, name2, ...\\] captures a series of variables\n- \\[&\\] reference capture, determine the reference capture list from the uses the in function body\n- \\[=\\] value capture, determine the value capture list from the uses in the function body\n\n#### 4. Expression capture\n\n> This section needs to understand the rvalue references and smart pointers that\n> will be mentioned later.\n\nThe value captures and reference captures mentioned above are variables that have been\ndeclared in the outer scope, so these capture methods capture the lvalue\nand not capture the rvalue.\n\nC++14 gives us the convenience of allowing the captured members to be initialized\nwith arbitrary expressions, which allows the capture of rvalues.\nThe type of the captured variable being declared is judged according to the expression,\nand the judgment is the same as using `auto`:\n\n```cpp\n#include <iostream>\n#include <memory>  // std::make_unique\n#include <utility> // std::move\n\nvoid lambda_expression_capture() {\n    auto important = std::make_unique<int>(1);\n    auto add = [v1 = 1, v2 = std::move(important)](int x, int y) -> int {\n        return x+y+v1+(*v2);\n    };\n    std::cout << add(3,4) << std::endl;\n}\n```\n\nIn the above code, `important` is an exclusive pointer that cannot be caught by value capture using `=`.\nAt this time we need to transfer it to the rvalue and\ninitialize it in the expression.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 03-runtime.md",
    "title": "Generic Lambda",
    "content": "### Generic Lambda\n\nIn the previous section, we mentioned that the `auto` keyword cannot be used\nin the parameter list because it would conflict with the functionality of the template.\nBut lambda expressions are not regular functions, without further specification on the typed parameter list, lambda expressions cannot utilize templates. Fortunately, this trouble\nonly exists in C++11, starting with C++14. The formal parameters of the lambda function\ncan use the `auto` keyword to utilize template generics:\n\n```cpp\nvoid lambda_generic() {\n    auto generic = [](auto x, auto y) {\n        return x+y;\n    };\n\n    std::cout << generic(1, 2) << std::endl;\n    std::cout << generic(1.1, 2.2) << std::endl;\n}\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 03-runtime.md",
    "title": "3.2 Function Object Wrapper",
    "content": "## 3.2 Function Object Wrapper\n\nAlthough the features are part of the standard library and not found in runtime,\nit enhances the runtime capabilities of the C++ language.\nThis part of the content is also very important, so put it here for the introduction.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 03-runtime.md",
    "title": "`std::function`",
    "content": "### `std::function`\n\nThe essence of a Lambda expression is an object of a class type (called a closure type)\nthat is similar to a function object type (called a closure object).\nWhen the capture list of a Lambda expression is empty, the closure object\ncan also be converted to a function pointer value for delivery, for example:\n\n```cpp\n#include <iostream>\nusing foo = void(int);  // function pointer\nvoid functional(foo f) {\n    f(1);\n}\nint main() {\n    auto f = [](int value) {\n        std::cout << value << std::endl;\n    };\n    functional(f);  // call by function pointer\n    f(1);           // call by lambda expression\n    return 0;\n}\n```\n\nThe above code gives two different forms of invocation, one is to call Lambda\nas a function type, and the other is to directly call a Lambda expression.\nIn C++11, these concepts are unified.\nThe type of object that can be called is collectively called the callable type.\nThis type is introduced by `std::function`.\n\nC++11 `std::function` is a generic, polymorphic function wrapper\nwhose instances can store, copy, and call any target entity that can be called.\nIt is also an existing callable to C++. A type-safe package of entities (relatively,\nthe call to a function pointer is not type-safe), in other words,\na container of functions. When we have a container for functions,\nwe can more easily handle functions and function pointers as objects. e.g:\n\n```cpp\n#include <functional>\n#include <iostream>\n\nint foo(int para) {\n    return para;\n}\n\nint main() {\n    // std::function wraps a function that take int paremeter and returns int value\n    std::function<int(int)> func = foo;\n\n    int important = 10;\n    std::function<int(int)> func2 = [&](int value) -> int {\n        return 1+value+important;\n    };\n    std::cout << func(10) << std::endl;\n    std::cout << func2(10) << std::endl;\n}\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 03-runtime.md",
    "title": "`std::bind` and `std::placeholder`",
    "content": "### `std::bind` and `std::placeholder`\n\nAnd `std::bind` is used to bind the parameters of the function call.\nIt solves the requirement that we may not always be able to get all the parameters\nof a function at one time. Through this function, we can Part of the call parameters\nare bound to the function in advance to become a new object,\nand then complete the call after the parameters are complete. e.g:\n\n```cpp\nint foo(int a, int b, int c) {\n    ;\n}\nint main() {\n    // bind parameter 1, 2 on function foo,\n    // and use std::placeholders::_1 as placeholder for the first parameter.\n    auto bindFoo = std::bind(foo, std::placeholders::_1, 1,2);\n    // when call bindFoo, we only need one param left\n    bindFoo(1);\n}\n```\n\n> **Tip:** Note the magic of the `auto` keyword. Sometimes we may not be familiar\n> with the return type of a function, but we can circumvent this problem by using `auto`.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 03-runtime.md",
    "title": "3.3 rvalue Reference",
    "content": "## 3.3 rvalue Reference\n\nrvalue references are one of the important features introduced by C++11\nthat are synonymous with Lambda expressions. Its introduction solves\na large number of historical issues in C++.\nEliminating extra overhead such as `std::vector`, `std::string`,\nand making the function object container `std::function` possible.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 03-runtime.md",
    "title": "lvalue, rvalue, prvalue, xvalue",
    "content": "### lvalue, rvalue, prvalue, xvalue\n\nTo understand what the rvalue reference is all about, you must have a clear\nunderstanding of the lvalue and the rvalue.\n\n**lvalue, left value**, as the name implies, is the value to the left of the assignment\nsymbol. To be precise, an lvalue is a persistent object that still exists after\nan expression (not necessarily an assignment expression).\n\n**Rvalue, right value**, the value on the right refers to the temporary object\nthat no longer exists after the expression ends.\n\nIn C++11, in order to introduce powerful rvalue references,\nthe concept of rvalue values is further divided into:\nprvalue, and xvalue.\n\n**pvalue, pure rvalue**, purely rvalue, either purely literal,\nsuch as `10`, `true`; either the result of the evaluation is equivalent to\na literal or anonymous temporary object, for example `1+2`.\nTemporary variables returned by non-references, temporary variables generated\nby operation expressions, original literals, and Lambda expressions\nare all pure rvalue values.\n\nNote that a literal (except a string literal) is a prvalue. However, a string\nliteral is an lvalue with type `const char` array. Consider the following examples:\n\n```cpp\n#include <type_traits>\n\nint main() {\n    // Correct. The type of \"01234\" is const char [6], so it is an lvalue\n    const char (&left)[6] = \"01234\";\n\n    // Assert success. It is a const char [6] indeed. Note that decltype(expr)\n    // yields lvalue reference if expr is an lvalue and neither an unparenthesized\n    // id-expression nor an unparenthesized class member access expression.\n    static_assert(std::is_same<decltype(\"01234\"), const char(&)[6]>::value, \"\");\n\n    // Error. \"01234\" is an lvalue, which cannot be referenced by an rvalue reference\n    // const char (&&right)[6] = \"01234\";\n}\n```\n\nHowever, an array can be implicitly converted to a corresponding pointer.The result, if not an lvalue reference, is an rvalue (xvalue if the result is an rvalue reference, prvalue otherwise):\n\n```cpp\nconst char*   p    = \"01234\"; // Correct. \"01234\" is implicitly converted to const char*\nconst char*&& pr   = \"01234\"; // Correct. \"01234\" is implicitly converted to const char*, which is a prvalue.\n// const char*& pl = \"01234\"; // Error. There is no type const char* lvalue\n```\n\n**xvalue, expiring value** is the concept proposed by C++11 to introduce\nrvalue references (so in traditional C++, pure rvalue and rvalue are the same concepts),\na value that is destroyed but can be moved.\n\nIt would be a little hard to understand the xvalue,\nlet's look at the code like this:\n\n```cpp\nstd::vector<int> foo() {\n    std::vector<int> temp = {1, 2, 3, 4};\n    return temp;\n}\n\nstd::vector<int> v = foo();\n```\n\nIn such code, as far as the traditional understanding is concerned,\nthe return value `temp` of the function `foo` is internally created\nand then assigned to `v`, whereas when `v` gets this object, the entire `temp` is copied.\nAnd then destroy `temp`, if this `temp` is very large, this will cause a lot of extra\noverhead (this is the problem that traditional C++ has been criticized for).\nIn the last line, `v` is the lvalue, and the value returned by `foo()` is\nthe rvalue (which is also a pure rvalue).\n\nHowever, `v` can be caught by other variables, and the return value generated by `foo()`\nis used as a temporary value. Once copied by `v`, it will be destroyed immediately, and\ncannot be obtained or modified. The xvalue defines behavior in which temporary values can be\nidentified while being able to be moved.\n\nAfter C++11, the compiler did some work for us, where the lvalue `temp`\nis subjected to this implicit rvalue conversion,\nequivalent to `static_cast<std::vector<int> &&>(temp)`,\nwhere `v` here moves the value returned by `foo` locally.\nThis is the move semantics we will mention later.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 03-runtime.md",
    "title": "rvalue reference and lvalue reference",
    "content": "### rvalue reference and lvalue reference\n\nTo get a xvalue, you need to use the declaration of the rvalue reference: `T &&`,\nwhere `T` is the type.\nThe statement of the rvalue reference extends the lifecycle of this temporary value,\nand as long as the variable is alive, the xvalue will continue to survive.\n\nC++11 provides the `std::move` method to unconditionally convert\nlvalue parameters to rvalues.\nWith it we can easily get a rvalue temporary object, for example:\n\n```cpp\n#include <iostream>\n#include <string>\n\nvoid reference(std::string& str) {\n    std::cout << \"lvalue\" << std::endl;\n}\nvoid reference(std::string&& str) {\n    std::cout << \"rvalue\" << std::endl;\n}\n\nint main()\n{\n    std::string  lv1 = \"string,\";       // lv1 is a lvalue\n    // std::string&& r1 = lv1;          // illegal, rvalue can't ref to lvalue\n    std::string&& rv1 = std::move(lv1); // legal, std::move can convert lvalue to rvalue\n    std::cout << rv1 << std::endl;      // string,\n\n    const std::string& lv2 = lv1 + lv1; // legal, const lvalue reference can\n                                        // extend temp variable's lifecycle\n    // lv2 += \"Test\";                   // illegal, const ref can't be modified\n    std::cout << lv2 << std::endl;      // string,string,\n\n    std::string&& rv2 = lv1 + lv2;      // legal, rvalue ref extend lifecycle\n    rv2 += \"string\";                    // legal, non-const reference can be modified\n    std::cout << rv2 << std::endl;      // string,string,string,string\n\n    reference(rv2);                     // output: lvalue\n\n    return 0;\n}\n```\n\n`rv2` refers to an rvalue, but since it is a reference,\n`rv2` is still an lvalue.\n\nNote that there is a very interesting historical issue here,\nlet's look at the following code:\n\n```cpp\n#include <iostream>\n\nint main() {\n    // int &a = std::move(1); // illegal, non-const lvalue reference cannot ref rvalue\n    const int &b = std::move(1); // legal, const lvalue reference can\n\n    std::cout << b << std::endl;\n}\n```\n\nThe first question, why not allow non-constant references to bind to non-lvalues?\nThis is because there is a logic error in this approach:\n\n```cpp\nvoid increase(int & v) {\n    v++;\n}\nvoid foo() {\n    double s = 1;\n    increase(s);\n}\n```\n\nSince `int&` can't reference a parameter of type `double`,\nyou must generate a temporary value to hold the value of `s`.\nThus, when `increase()` modifies this temporary value,\n`s` itself is not modified after the call is completed.\n\nThe second question, why do constant references allow binding to non-lvalues?\nThe reason is simple because Fortran needs it.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 03-runtime.md",
    "title": "Move semantics",
    "content": "### Move semantics\n\nTraditional C++ has designed the concept of copy/copy for class objects\nthrough copy constructors and assignment operators,\nbut to implement the movement of resources,\nThe caller must use the method of copying and then destructing first,\notherwise, you need to implement the interface of the mobile object yourself.\nImagine moving your home directly to your new home instead of\ncopying everything (rebuy) to your new home.\nThrowing away (destroying) all the original things is a very anti-human thing.\n\nTraditional C++ does not distinguish between the concepts of \"mobile\" and \"copy\",\nresulting in a large amount of data copying, wasting time and space.\nThe appearance of rvalue references solves the confusion of these two concepts,\nfor example:\n\n```cpp\n#include <iostream>\nclass A {\npublic:\n    int *pointer;\n    A():pointer(new int(1)) {\n        std::cout << \"construct\" << pointer << std::endl;\n    }\n    A(A& a):pointer(new int(*a.pointer)) {\n        std::cout << \"copy\" << pointer << std::endl;\n    } // meaningless object copy\n    A(A&& a):pointer(a.pointer) {\n        a.pointer = nullptr;\n        std::cout << \"move\" << pointer << std::endl;\n    }\n    ~A(){\n        std::cout << \"destruct\" << pointer << std::endl;\n        delete pointer;\n    }\n};\n// avoid compiler optimization\nA return_rvalue(bool test) {\n    A a,b;\n    if(test) return a; // equal to static_cast<A&&>(a);\n    else return b;     // equal to static_cast<A&&>(b);\n}\nint main() {\n    A obj = return_rvalue(false);\n    std::cout << \"obj:\" << std::endl;\n    std::cout << obj.pointer << std::endl;\n    std::cout << *obj.pointer << std::endl;\n    return 0;\n}\n```\n\nIn the code above:\n\n1. First construct two `A` objects inside `return_rvalue`, and get the output of the two constructors;\n2. After the function returns, it will generate a xvalue, which is referenced by the moving structure of `A` (`A(A&&)`), thus extending the life cycle, and taking the pointer in the rvalue and saving it to `obj`. In the middle, the pointer to the xvalue is set to `nullptr`, which prevents the memory area from being destroyed.\n\nThis avoids meaningless copy constructs and enhances performance.\nLet's take a look at an example involving a standard library:\n\n```cpp\n#include <iostream> // std::cout\n#include <utility>  // std::move\n#include <vector>   // std::vector\n#include <string>   // std::string\n\nint main() {\n\n    std::string str = \"Hello world.\";\n    std::vector<std::string> v;\n\n    // use push_back(const T&), copy\n    v.push_back(str);\n    // \"str: Hello world.\"\n    std::cout << \"str: \" << str << std::endl;\n\n    // use push_back(const T&&),\n    // no copy the string will be moved to vector,\n    // and therefore std::move can reduce copy cost\n    v.push_back(std::move(str));\n    // str is empty now\n    std::cout << \"str: \" << str << std::endl;\n\n    return 0;\n}\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 03-runtime.md",
    "title": "Perfect forwarding",
    "content": "### Perfect forwarding\n\nAs we mentioned earlier, the rvalue reference of a declaration is actually an lvalue.\nThis creates problems for us to parameterize (pass):\n\n```cpp\n#include <iostream>\n#include <utility>\nvoid reference(int& v) {\n    std::cout << \"lvalue reference\" << std::endl;\n}\nvoid reference(int&& v) {\n    std::cout << \"rvalue reference\" << std::endl;\n}\ntemplate <typename T>\nvoid pass(T&& v) {\n    std::cout << \"          normal param passing: \";\n    reference(v);\n}\nint main() {\n    std::cout << \"rvalue pass:\" << std::endl;\n    pass(1);\n\n    std::cout << \"lvalue pass:\" << std::endl;\n    int l = 1;\n    pass(l);\n\n    return 0;\n}\n```\n\nFor `pass(1)`, although the value is the rvalue, since `v` is a reference, it is also an lvalue.\nTherefore `reference(v)` will call `reference(int&)` and output lvalue.\nFor `pass(l)`, `l` is an lvalue, why is it successfully passed to `pass(T&&)`?\n\nThis is based on the **reference collapsing rule**: In traditional C++, we are not able to continue to reference a reference type.\nHowever,\nC++ has relaxed this practice with the advent of rvalue references,\nresulting in a reference collapse rule that allows us to reference references,\nboth lvalue and rvalue. But follow the rules below:\n\n| Function parameter type | Argument parameter type | Post-derivation function parameter type |\n| :---------------------: | :---------------------: | :-------------------------------------: |\n|           T&            |       lvalue ref        |                   T&                    |\n|           T&            |       rvalue ref        |                   T&                    |\n|           T&&           |       lvalue ref        |                   T&                    |\n|           T&&           |       rvalue ref        |                   T&&                   |\n\nTherefore, the use of `T&&` in a template function may not be able to make an rvalue reference, and when a lvalue is passed, a reference to this function will be derived as an lvalue.\nMore precisely, **no matter what type of reference the template parameter is, the template parameter can be derived as a right reference type** if and only if the argument type is a right reference.\nThis makes `v` successful delivery of lvalues.\n\nPerfect forwarding is based on the above rules. The so-called perfect forwarding is to let us pass the parameters,\nKeep the original parameter type (lvalue reference keeps lvalue reference, rvalue reference keeps rvalue reference).\nTo solve this problem, we should use `std::forward` to forward (pass) the parameters:\n\n```cpp\n#include <iostream>\n#include <utility>\nvoid reference(int& v) {\n    std::cout << \"lvalue reference\" << std::endl;\n}\nvoid reference(int&& v) {\n    std::cout << \"rvalue reference\" << std::endl;\n}\ntemplate <typename T>\nvoid pass(T&& v) {\n    std::cout << \"          normal param passing: \";\n    reference(v);\n    std::cout << \"       std::move param passing: \";\n    reference(std::move(v));\n    std::cout << \"    std::forward param passing: \";\n    reference(std::forward<T>(v));\n    std::cout << \"static_cast<T&&> param passing: \";\n    reference(static_cast<T&&>(v));\n}\nint main() {\n    std::cout << \"rvalue pass:\" << std::endl;\n    pass(1);\n\n    std::cout << \"lvalue pass:\" << std::endl;\n    int l = 1;\n    pass(l);\n\n    return 0;\n}\n```\n\nThe outputs are:\n\n```\nrvalue pass:\n          normal param passing: lvalue reference\n       std::move param passing: rvalue reference\n    std::forward param passing: rvalue reference\nstatic_cast<T&&> param passing: rvalue reference\nlvalue pass:\n          normal param passing: lvalue reference\n       std::move param passing: rvalue reference\n    std::forward param passing: lvalue reference\nstatic_cast<T&&> param passing: lvalue reference\n```\n\nRegardless of whether the pass parameter is an lvalue or an rvalue, the normal pass argument will forward the argument as an lvalue.\nSo `std::move` will always accept an lvalue, which forwards the call to `reference(int&&)` to output the rvalue reference.\n\nOnly `std::forward` does not cause any extra copies and **perfectly forwards** (passes) the arguments of the function to other functions that are called internally.\n\n`std::forward` is the same as `std::move`, and nothing is done. `std::move` simply converts the lvalue to the rvalue.\n`std::forward` is just a simple conversion of the parameters. From the point of view of the phenomenon,\n`std::forward<T>(v)` is the same as `static_cast<T&&>(v)`.\n\nReaders may be curious as to why a statement can return values for two types of returns.\nLet's take a quick look at the concrete implementation of `std::forward`. `std::forward` contains two overloads:\n\n```cpp\ntemplate<typename _Tp>\nconstexpr _Tp&& forward(typename std::remove_reference<_Tp>::type& __t) noexcept\n{ return static_cast<_Tp&&>(__t); }\n\ntemplate<typename _Tp>\nconstexpr _Tp&& forward(typename std::remove_reference<_Tp>::type&& __t) noexcept\n{\n    static_assert(!std::is_lvalue_reference<_Tp>::value, \"template argument\"\n        \" substituting _Tp is an lvalue reference type\");\n    return static_cast<_Tp&&>(__t);\n}\n```\n\nIn this implementation, the function of `std::remove_reference` is to eliminate references in the type.\nAnd `std::is_lvalue_reference` is used to check if the type derivation is correct, in the second implementation of `std::forward`.\nCheck that the received value is indeed an lvalue, which in turn reflects the collapse rule.\n\nWhen `std::forward` accepts an lvalue, `_Tp` is deduced to the lvalue, so the return value is the lvalue; and when it accepts the rvalue,\n`_Tp` is derived as an rvalue reference, and based on the collapse rule, the return value becomes the rvalue of `&& + &&`.\nIt can be seen that the principle of `std::forward` is to make clever use of the differences in template type derivation.\n\nAt this point, we can answer the question: Why is `auto&&` the safest way to use looping statements?\nBecause when `auto` is pushed to a different lvalue and rvalue reference, the collapsed combination with `&&` is perfectly forwarded.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 03-runtime.md",
    "title": "Conclusion",
    "content": "## Conclusion\n\nThis chapter introduces the most important runtime enhancements in modern C++, and I believe that all the features mentioned in this section are worth knowing:\n\nLambda expression\n\n1. Function object container std::function\n2. rvalue reference\n\n[Table of Content](./toc.md) | [Previous Chapter](./02-usability.md) | [Next Chapter: Containers](./04-containers.md)\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 03-runtime.md",
    "title": "Further Readings",
    "content": "## Further Readings\n\n- [Bjarne Stroustrup, The Design and Evolution of C++](https://www.amazon.com/Design-Evolution-C-Bjarne-Stroustrup/dp/0201543303)\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 03-runtime.md",
    "title": "Licenses",
    "content": "## Licenses\n\n<a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png\" /></a><br />This work was written by [Ou Changkun](https://changkun.de) and licensed under a <a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>. The code of this repository is open sourced under the [MIT license](../../LICENSE).\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 08-filesystem.md",
    "title": "Introduction",
    "content": "---\ntitle: \"Chapter 08 File System\"\ntype: book-en-us\norder: 8\n---\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 08-filesystem.md",
    "title": "Chapter 08 File System",
    "content": "# Chapter 08 File System\n\n[TOC]\n\nThe file system library provides functions related to \nthe operation of the file system, path, regular files, directories, and so on. \nSimilar to the regular expression library, it was one of the first libraries \nto be launched by boost and eventually merged into the C++ standard.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 08-filesystem.md",
    "title": "8.1 Document and Link",
    "content": "## 8.1 Document and Link\n\nTODO:\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 08-filesystem.md",
    "title": "8.2 std::filesystem",
    "content": "## 8.2 std::filesystem\n\nTODO:\n\n[Table of Content](./toc.md) | [Previous Chapter](./07-thread.md) | [Next Chapter: Minor Features](./09-others.md)\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 08-filesystem.md",
    "title": "Further Readings",
    "content": "## Further Readings\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 08-filesystem.md",
    "title": "Licenses",
    "content": "## Licenses\n\n<a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png\" /></a><br />This work was written by [Ou Changkun](https://changkun.de) and licensed under a <a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>. The code of this repository is open sourced under the [MIT license](../../LICENSE).\n"
  },
  {
    "source": "Modern C++ Tutorial - appendix2.md",
    "title": "Introduction",
    "content": "---\ntitle: \"Appendix 2: Modern C++ Best Practices\"\ntype: book-en-us\norder: 12\n---\n\n"
  },
  {
    "source": "Modern C++ Tutorial - appendix2.md",
    "title": "Appendix 2: Modern C++ Best Practices",
    "content": "# Appendix 2: Modern C++ Best Practices\n\nIn this appendix we will briefly talk about the best practices of modern C++. In general, the author's thoughts on C++'s best practices are mainly absorbed from [Effective Modern C++](https://www.amazon.com/dp/1491903996/ref=cm_sw_em_r_mt_dp_U_-ZgjDb81ERBNP) and [C++ Style Guide](https://google.github.io/styleguide/cppguide.html). In this appendix, we will briefly discuss and use the actual examples to illustrate the methods, and introduce some of **the author's personal**, **non-common**, **non-sensible** best practices, and how to ensure the overall quality of the code.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - appendix2.md",
    "title": "Common Tools",
    "content": "## Common Tools\n\nTODO:\n\n"
  },
  {
    "source": "Modern C++ Tutorial - appendix2.md",
    "title": "Coding Style",
    "content": "## Coding Style\n\nTODO:\n\n"
  },
  {
    "source": "Modern C++ Tutorial - appendix2.md",
    "title": "Overall Performance",
    "content": "## Overall Performance\n\nTODO:\n\n"
  },
  {
    "source": "Modern C++ Tutorial - appendix2.md",
    "title": "Code Security",
    "content": "## Code Security\n\nTODO:\n\n"
  },
  {
    "source": "Modern C++ Tutorial - appendix2.md",
    "title": "Maintainability",
    "content": "## Maintainability\n\nTODO:\n\n"
  },
  {
    "source": "Modern C++ Tutorial - appendix2.md",
    "title": "Portability",
    "content": "## Portability\n\nTODO:\n\n[Table of Content](./toc.md) | [Previous Chapter](./appendix1.md)\n\n"
  },
  {
    "source": "Modern C++ Tutorial - appendix2.md",
    "title": "Licenses",
    "content": "## Licenses\n\n<a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png\" /></a><br />This work was written by [Ou Changkun](https://changkun.de) and licensed under a <a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>. The code of this repository is open sourced under the [MIT license](../../LICENSE).\n"
  },
  {
    "source": "Modern C++ Tutorial - 07-thread.md",
    "title": "Introduction",
    "content": "---\ntitle: \"Chapter 07 Parallelism and Concurrency\"\ntype: book-en-us\norder: 7\n---\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 07-thread.md",
    "title": "Chapter 07 Parallelism and Concurrency",
    "content": "# Chapter 07 Parallelism and Concurrency\n\n[TOC]\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 07-thread.md",
    "title": "7.1 Basic of Parallelism",
    "content": "## 7.1 Basic of Parallelism\n\n`std::thread` is used to create an execution thread instance, so it is the basis for all concurrent programming. It needs to include the `<thread>` header file when using it.\nIt provides a number of basic thread operations, such as `get_id()` to get the thread ID of the thread being created, use `join()` to join a thread, etc., for example:\n\n```cpp\n#include <iostream>\n#include <thread>\n\nint main() {\n    std::thread t([](){\n        std::cout << \"hello world.\" << std::endl;\n    });\n    t.join();\n    return 0;\n}\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 07-thread.md",
    "title": "7.2 Mutex and Critical Section",
    "content": "## 7.2 Mutex and Critical Section\n\nWe have already learned the basics of concurrency technology in the operating system, or the database, and `mutex` is one of the cores.\nC++11 introduces a class related to `mutex`, with all related functions in the `<mutex>` header file.\n\n`std::mutex` is the most basic mutex class in C++11, and a mutex can be created by constructing a `std::mutex` object.\nIt can be locked by its member function `lock()`, and `unlock()` can be unlocked.\nBut in the process of actually writing the code, it is best not to directly call the member function,\nBecause calling member functions, you need to call `unlock()` at the exit of each critical section, and of course, exceptions.\nAt this time, C++11 also provides a template class `std::lock_guard` for the RAII mechanism for the mutex.\n\nRAII guarantees the exceptional security of the code while keeping the simplicity of the code.\n\n```cpp\n#include <iostream>\n#include <mutex>\n#include <thread>\n\nint v = 1;\n\nvoid critical_section(int change_v) {\n    static std::mutex mtx;\n    std::lock_guard<std::mutex> lock(mtx);\n\n    // execute contention works\n    v = change_v;\n\n    // mtx will be released after leaving the scope\n}\n\nint main() {\n    std::thread t1(critical_section, 2), t2(critical_section, 3);\n    t1.join();\n    t2.join();\n\n    std::cout << v << std::endl;\n    return 0;\n}\n```\n\nBecause C++ guarantees that all stack objects will be destroyed at the end of the declaration period, such code is also extremely safe.\nWhether `critical_section()` returns normally or if an exception is thrown in the middle, a stack unwinding is thrown, and `unlock()` is automatically called.\n\n> An exception is thrown and not caught (it is implementation-defined whether any stack unwinding is done in this case).\n\n`std::unique_lock` is more flexible than `std::lock_guard`.\nObjects of `std::unique_lock` manage the locking and unlocking operations on the `mutex` object with exclusive ownership (no other `unique_lock` objects owning the ownership of a `mutex` object). So in concurrent programming, it is recommended to use `std::unique_lock`.\n\n`std::lock_guard` cannot explicitly call `lock` and `unlock`, and `std::unique_lock` can be called anywhere after the declaration.\nIt can reduce the scope of the lock and provide higher concurrency.\n\nIf you use the condition variable `std::condition_variable::wait` you must use `std::unique_lock` as a parameter.\n\nFor instance:\n\n```cpp\n#include <iostream>\n#include <mutex>\n#include <thread>\n\nint v = 1;\n\nvoid critical_section(int change_v) {\n    static std::mutex mtx;\n    std::unique_lock<std::mutex> lock(mtx);\n    // do contention operations\n    v = change_v;\n    std::cout << v << std::endl;\n    // release the lock\n    lock.unlock();\n\n    // during this period,\n    // others are allowed to acquire v\n\n    // start another group of contention operations\n    // lock again\n    lock.lock();\n    v += 1;\n    std::cout << v << std::endl;\n}\n\nint main() {\n    std::thread t1(critical_section, 2), t2(critical_section, 3);\n    t1.join();\n    t2.join();\n    return 0;\n}\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 07-thread.md",
    "title": "7.3 Future",
    "content": "## 7.3 Future\n\nThe Future is represented by `std::future`, which provides a way to access the results of asynchronous operations. This sentence is very difficult to understand.\nTo understand this feature, we need to understand the multi-threaded behavior before C++11.\n\nImagine if our main thread A wants to open a new thread B to perform some of our expected tasks and return me a result.\nAt this time, thread A may be busy with other things and have no time to take into account the results of B.\nSo we naturally hope to get the result of thread B at a certain time.\n\nBefore the introduction of `std::future` in C++11, the usual practice is:\nCreate a thread A, start task B in thread A, send an event when it is ready, and save the result in a global variable.\nThe main function thread A is doing other things. When the result is needed, a thread is called to wait for the function to get the result of the execution.\n\nThe `std::future` provided by C++11 simplifies this process and can be used to get the results of asynchronous tasks.\nNaturally, we can easily imagine it as a simple means of thread synchronization, namely the barrier.\n\nTo see an example, we use extra `std::packaged_task`, which can be used to wrap any target that can be called for asynchronous calls. For example:\n\n```cpp\n#include <iostream>\n#include <thread>\n#include <future>\n\nint main() {\n    // pack a lambda expression that returns 7 into a std::packaged_task\n    std::packaged_task<int()> task([](){return 7;});\n    // get the future of task\n    std::future<int> result = task.get_future();    // run task in a thread\n    std::thread(std::move(task)).detach();\n    std::cout << \"waiting...\";\n    result.wait(); // block until future has arrived\n    // output result\n    std::cout << \"done!\" << std:: endl << \"future result is \" \n              << result.get() << std::endl;\n    return 0;\n}\n```\n\nAfter encapsulating the target to be called, you can use `get_future()` to get a `std::future` object to implement thread synchronization later.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 07-thread.md",
    "title": "7.4 Condition Variable",
    "content": "## 7.4 Condition Variable\n\nThe condition variable `std::condition_variable` was born to solve the deadlock and was introduced when the mutex operation was not enough.\nFor example, a thread may need to wait for a condition to be true to continue execution.\nA dead wait loop can cause all other threads to fail to enter the critical section so that when the condition is true, a deadlock occurs.\nTherefore, the `condition_variable` object is created primarily to wake up the waiting thread and avoid deadlocks.\n`notify_one()` of `std::condition_variable` is used to wake up a thread;\n`notify_all()` is to notify all threads. Below is an example of a producer and consumer model:\n\n```cpp\n#include <queue>\n#include <chrono>\n#include <mutex>\n#include <thread>\n#include <iostream>\n#include <condition_variable>\n\n\nint main() {\n    std::queue<int> produced_nums;\n    std::mutex mtx;\n    std::condition_variable cv;\n    bool notified = false;  // notification sign\n\n    auto producer = [&]() {\n        for (int i = 0; ; i++) {\n            std::this_thread::sleep_for(std::chrono::milliseconds(500));\n            std::unique_lock<std::mutex> lock(mtx);\n            std::cout << \"producing \" << i << std::endl;\n            produced_nums.push(i);\n            notified = true;\n            cv.notify_all();\n        }\n    };\n    auto consumer = [&]() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(mtx);\n            while (!notified) {  // avoid spurious wakeup\n                cv.wait(lock);\n            }\n\n            // temporal unlock to allow producer produces more rather than\n            // let consumer hold the lock until its consumed.\n            lock.unlock();\n            // consumer is slower\n            std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n            lock.lock();\n            if (!produced_nums.empty()) {\n                std::cout << \"consuming \" << produced_nums.front() << std::endl;\n                produced_nums.pop();\n            }\n            notified = false;\n        }\n    };\n\n    std::thread p(producer);\n    std::thread cs[2];\n    for (int i = 0; i < 2; ++i) {\n        cs[i] = std::thread(consumer);\n    }\n    p.join();\n    for (int i = 0; i < 2; ++i) {\n        cs[i].join();\n    }\n    return 0;\n}\n```\n\nIt is worth mentioning that although we can use `notify_one()` in the producer, it is not recommended to use it here.\nBecause in the case of multiple consumers, our consumer implementation simply gives up the lock holding, which makes it possible for other consumers to compete for this lock, to better utilize the concurrency between multiple consumers. Having said that, but in fact because of the exclusivity of `std::mutex`,\nWe simply can't expect multiple consumers to be able to produce content in a parallel consumer queue, and we still need a more granular approach.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 07-thread.md",
    "title": "7.5 Atomic Operation and Memory Model",
    "content": "## 7.5 Atomic Operation and Memory Model\n\nCareful readers may be tempted by the fact that the example of the producer-consumer model in the previous section may have compiler optimizations that cause program errors.\nFor example, the compiler may have optimizations for the variable `notified`, such as the value of a register.\nAs a result, the consumer thread can never observe the change of this value. This is a good question. To explain this problem, we need to further discuss the concept of the memory model introduced from C++11. Let's first look at a question. What is the output of the following code?\n\n```cpp\n#include <thread>\n#include <iostream>\n\nint main() {\n    int a = 0;\n    volatile int flag = 0;\n\n    std::thread t1([&]() {\n        while (flag != 1);\n\n        int b = a;\n        std::cout << \"b = \" << b << std::endl;\n    });\n\n    std::thread t2([&]() {\n        a = 5;\n        flag = 1;\n    });\n\n    t1.join();\n    t2.join();\n    return 0;\n}\n```\n\nIntuitively, it  seems that `a = 5;` in `t2` always executes before `flag = 1;` and `while (flag != 1)` in `t1`. It looks like there is a guarantee the line `std ::cout << \"b = \" << b << std::endl;` will not be executed before the mark is changed. Logically, it seems that the value of `b` should be equal to 5.\nBut the actual situation is much more complicated than this, or the code itself is undefined behavior because, for `a` and `flag`, they are read and written in two parallel threads.\nThere has been competition. Also, even if we ignore competing for reading and writing, it is still possible to receive out-of-order execution of the CPU and the impact of the compiler on the rearrangement of instructions.\nCause `a = 5` to occur after `flag = 1`. Thus `b` may output 0.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 07-thread.md",
    "title": "Atomic Operation",
    "content": "### Atomic Operation\n\n`std::mutex` can solve the problem of concurrent read and write, but the mutex is an operating system-level function.\nThis is because the implementation of a mutex usually contains two basic principles:\n\n1. Provide automatic state transition between threads, that is, \"lock\" state\n2. Ensure that the memory of the manipulated variable is isolated from the critical section during the mutex operation\n\nThis is a very strong set of synchronization conditions, in other words when it is finally compiled into a CPU instruction, it will behave like a lot of instructions (we will look at how to implement a simple mutex later).\nThis seems too harsh for a variable that requires only atomic operations (no intermediate state).\n\nThe research on synchronization conditions has a very long history, and we will not go into details here. Readers should understand that under the modern CPU architecture, atomic operations at the CPU instruction level are provided.\nTherefore, the `std::atomic` template is introduced in C++11 for the topic of multi-threaded shared variable reading and writing, which enables us to instantiate atomic types,\nand minimize an atomic read or write operation from a set of instructions to a single CPU instruction. E.g:\n\n```cpp\nstd::atomic<int> counter;\n```\n\nAnd provides basic numeric member functions for atomic types of integers or floating-point numbers, for example,\nIncluding `fetch_add`, `fetch_sub`, etc., and the corresponding `+`, `-` version is provided by overload.\nFor example, the following example:\n\n```cpp\n#include <atomic>\n#include <thread>\n#include <iostream>\n\nstd::atomic<int> count = {0};\n\nint main() {\n    std::thread t1([](){\n        count.fetch_add(1);\n    });\n    std::thread t2([](){\n        count++;        // identical to fetch_add\n        count += 1;     // identical to fetch_add\n    });\n    t1.join();\n    t2.join();\n    std::cout << count << std::endl;\n    return 0;\n}\n```\n\nOf course, not all types provide atomic operations because the feasibility of atomic operations depends on the architecture of the CPU and whether the type structure being instantiated satisfies the memory alignment requirements of the architecture, so we can always pass `std::atomic<T>::is_lock_free` to check if the atom type needs to support atomic operations, for example:\n\n```cpp\n#include <atomic>\n#include <iostream>\n\nstruct A {\n    float x;\n    int y;\n    long long z;\n};\n\nint main() {\n    std::atomic<A> a;\n    std::cout << std::boolalpha << a.is_lock_free() << std::endl;\n    return 0;\n}\n```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 07-thread.md",
    "title": "Consistency Model",
    "content": "### Consistency Model\n\nMultiple threads executing in parallel, discussed at some macro level, can be roughly considered a distributed system.\nIn a distributed system, any communication or even local operation takes a certain amount of time, and even unreliable communication occurs.\n\nIf we force the operation of a variable `v` between multiple threads to be atomic, that is, any thread after the operation of `v`\nOther threads can **synchronize** to perceive changes in `v`, for the variable `v`, which appears as a sequential execution of the program, it does not have any efficiency gains due to the introduction of multithreading. Is there any way to accelerate this properly? The answer is to weaken the synchronization conditions between processes in atomic operations.\n\nIn principle, each thread can correspond to a cluster node, and communication between threads is almost equivalent to communication between cluster nodes.\nWeakening the synchronization conditions between processes, usually we will consider four different consistency models:\n\n1. Linear consistency: Also known as strong consistency or atomic consistency. It requires that any read operation can read the most recent write of a certain data, and the order of operation of all threads is consistent with the order under the global clock.\n\n   ```\n           x.store(1)      x.load()\n   T1 ---------+----------------+------>\n\n\n   T2 -------------------+------------->\n                   x.store(2)\n   ```\n\n   In this case, thread `T1`, `T2` is twice atomic to `x`, and `x.store(1)` is strictly before `x.store(2)`. `x.store(2)` strictly occurs before `x.load()`. It is worth mentioning that linear consistency requirements for global clocks are difficult to achieve, which is why people continue to study other consistent algorithms under this weaker consistency.\n\n2. Sequential consistency: It is also required that any read operation can read the last data written by the data, but it is not required to be consistent with the order of the global clock.\n\n   ```\n           x.store(1)  x.store(3)   x.load()\n   T1 ---------+-----------+----------+----->\n\n\n   T2 ---------------+---------------------->\n                 x.store(2)\n\n   or\n\n           x.store(1)  x.store(3)   x.load()\n   T1 ---------+-----------+----------+----->\n\n\n   T2 ------+------------------------------->\n         x.store(2)\n   ```\n\n   Under the order consistency requirement, `x.load()` must read the last written data, so `x.store(2)` and `x.store(1)` do not have any guarantees, as long as `x.store(2)` of `T2` occurs before `x.store(3)`.\n\n3. Causal consistency: its requirements are further reduced, only the sequence of causal operations is guaranteed, and the order of non-causal operations is not required.\n\n   ```\n         a = 1      b = 2\n   T1 ----+-----------+---------------------------->\n\n\n   T2 ------+--------------------+--------+-------->\n         x.store(3)         c = a + b    y.load()\n\n   or\n\n         a = 1      b = 2\n   T1 ----+-----------+---------------------------->\n\n\n   T2 ------+--------------------+--------+-------->\n         x.store(3)          y.load()   c = a + b\n\n   or\n\n        b = 2       a = 1\n   T1 ----+-----------+---------------------------->\n\n\n   T2 ------+--------------------+--------+-------->\n         y.load()            c = a + b  x.store(3)\n   ```\n\n   The three examples given above are all causal consistent because, in the whole process, only `c` has a dependency on `a` and `b`, and `x` and `y` are not related in this example. (But in actual situations we need more detailed information to determine that `x` is not related to `y`)\n\n4. Final Consistency: It is the weakest consistency requirement. It only guarantees that an operation will be observed at a certain point in the future, but does not require the observed time. So we can even strengthen this condition a bit, for example, to specify that the time observed for an operation is always bounded. Of course, this is no longer within our discussion.\n\n   ```\n       x.store(3)  x.store(4)\n   T1 ----+-----------+-------------------------------------------->\n\n\n   T2 ---------+------------+--------------------+--------+-------->\n            x.read()      x.read()           x.read()   x.read()\n   ```\n\n   In the above case, if we assume that the initial value of x is 0, then the four times ``x.read()` in `T2` may be but not limited to the following:\n\n   ```\n   3 4 4 4 // The write operation of x was quickly observed\n   0 3 3 4 // There is a delay in the observed time of the x write operation\n   0 0 0 4 // The last read read the final value of x, \n           // but the previous changes were not observed.\n   0 0 0 0 // The write operation of x is not observed in the current time period, \n           // but the situation that x is 4 can be observed \n           // at some point in the future.\n   ```\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 07-thread.md",
    "title": "Memory Orders",
    "content": "### Memory Orders\n\nTo achieve the ultimate performance and achieve consistency of various strength requirements, C++11 defines six different memory sequences for atomic operations. The option `std::memory_order` expresses four synchronization models between multiple threads:\n\n1. Relaxed model: Under this model, atomic operations within a single thread are executed sequentially, and instruction reordering is not allowed, but the order of atomic operations between different threads is arbitrary. The type is specified by `std::memory_order_relaxed`. Let's look at an example:\n\n   ```cpp\n   std::atomic<int> counter = {0};\n   std::vector<std::thread> vt;\n   for (int i = 0; i < 100; ++i) {\n       vt.emplace_back([&](){\n           counter.fetch_add(1, std::memory_order_relaxed);\n       });\n   }\n\n   for (auto& t : vt) {\n       t.join();\n   }\n   std::cout << \"current counter:\" << counter << std::endl;\n   ```\n\n2. Release/consumption model: In this model, we begin to limit the order of operations between processes. If a thread needs to modify a value, but another thread will have a dependency on that operation of the value, that is, the latter depends on the former. Specifically, thread A has completed three writes to `x`, and thread `B` relies only on the third `x` write operation, regardless of the first two write behaviors of `x`, then `A ` When active `x.release()` (ie using `std::memory_order_release`), the option `std::memory_order_consume` ensures that `B` observes `A` when calling `x.load()` Three writes to `x`. Let's look at an example:\n\n   ```cpp\n   // initialize as nullptr to prevent consumer load a dangling pointer\n   std::atomic<int*> ptr(nullptr);\n   int v;\n   std::thread producer([&]() {\n       int* p = new int(42);\n       v = 1024;\n       ptr.store(p, std::memory_order_release);\n   });\n   std::thread consumer([&]() {\n       int* p;\n       while(!(p = ptr.load(std::memory_order_consume)));\n\n       std::cout << \"p: \" << *p << std::endl;\n       std::cout << \"v: \" << v << std::endl;\n   });\n   producer.join();\n   consumer.join();\n   ```\n\n3. Release/Acquire model: Under this model, we can further tighten the order of atomic operations between different threads, specifying the timing between releasing `std::memory_order_release` and getting `std::memory_order_acquire`. **All** write operations before the release operation is visible to any other thread, i.e., happens before.\n\n   As you can see, `std::memory_order_release` ensures that a write before a release does not occur after the release operation, which is a **backward barrier**, and `std::memory_order_acquire` ensures that a subsequent read or write after a acquire does not occur before the acquire operation, which is a **forward barrier**.\n   For the `std::memory_order_acq_rel` option, combines the characteristics of the two barriers and determines a unique memory barrier, such that reads and writes of the current thread will not be rearranged across the barrier.\n\n   Let's check an example:\n\n   ```cpp\n   std::vector<int> v;\n   std::atomic<int> flag = {0};\n   std::thread release([&]() {\n       v.push_back(42);\n       flag.store(1, std::memory_order_release);\n   });\n   std::thread acqrel([&]() {\n       int expected = 1; // must before compare_exchange_strong\n       while(!flag.compare_exchange_strong(expected, 2, std::memory_order_acq_rel)) \n           expected = 1; // must after compare_exchange_strong\n       // flag has changed to 2\n   });\n   std::thread acquire([&]() {\n       while(flag.load(std::memory_order_acquire) < 2);\n\n       std::cout << v.at(0) << std::endl; // must be 42\n   });\n   release.join();\n   acqrel.join();\n   acquire.join();\n   ```\n\n   In this case we used `compare_exchange_strong`, which is the Compare-and-swap primitive, which has a weaker version, `compare_exchange_weak`, which allows a failure to be returned even if the exchange is successful. The reason is due to a false failure on some platforms, specifically when the CPU performs a context switch, another thread loads the same address to produce an inconsistency. In addition, the performance of `compare_exchange_strong` may be slightly worse than `compare_exchange_weak`. However, in most cases, `compare_exchange_weak` is discouraged due to the complexity of its usage.\n\n4. Sequential Consistent Model: Under this model, atomic operations satisfy sequence consistency, which in turn can cause performance loss. It can be specified explicitly by `std::memory_order_seq_cst`. Let's look at a final example:\n\n   ```cpp\n   std::atomic<int> counter = {0};\n   std::vector<std::thread> vt;\n   for (int i = 0; i < 100; ++i) {\n       vt.emplace_back([&](){\n           counter.fetch_add(1, std::memory_order_seq_cst);\n       });\n   }\n\n   for (auto& t : vt) {\n       t.join();\n   }\n   std::cout << \"current counter:\" << counter << std::endl;\n   ```\n\n   This example is essentially the same as the first loose model example. Just change the memory order of the atomic operation to `memory_order_seq_cst`. Interested readers can write their own programs to measure the performance difference caused by these two different memory sequences.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 07-thread.md",
    "title": "Conclusion",
    "content": "## Conclusion\n\nThe C++11 language layer provides support for concurrent programming. This section briefly introduces `std::thread`/`std::mutex`/`std::future`, an important tool that can't be avoided in concurrent programming.\nIn addition, we also introduced the \"memory model\" as one of the most important features of C++11.\nThey provide a critical foundation for standardized high-performance computing for C++.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 07-thread.md",
    "title": "Exercises",
    "content": "## Exercises\n\n1. Write a simple thread pool that provides the following features:\n\n   ```cpp\n   ThreadPool p(4); // specify four work thread\n\n   // enqueue a task, and return a std::future\n   auto f = pool.enqueue([](int life) {\n       return meaning;\n   }, 42);\n\n   // fetch result from future\n   std::cout << f.get() << std::endl;\n   ```\n\n2. Use `std::atomic<bool>` to implement a mutex.\n\n[Table of Content](./toc.md) | [Previous Chapter](./06-regex.md) | [Next Chapter: File System](./08-filesystem.md)\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 07-thread.md",
    "title": "Further Readings",
    "content": "## Further Readings\n\n- [C++ Concurrency in Action](https://www.amazon.com/dp/1617294691/ref=cm_sw_em_r_mt_dp_U_siEmDbRMMF960)\n- [Thread document](https://en.cppreference.com/w/cpp/thread)\n- Herlihy, M. P., & Wing, J. M. (1990). Linearizability: a correctness condition for concurrent objects. ACM Transactions on Programming Languages and Systems, 12(3), 463492. https://doi.org/10.1145/78969.78972\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 07-thread.md",
    "title": "Licenses",
    "content": "## Licenses\n\n<a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png\" /></a><br />This work was written by [Ou Changkun](https://changkun.de) and licensed under a <a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>. The code of this repository is open sourced under the [MIT license](../../LICENSE).`\n\n"
  },
  {
    "source": "Modern C++ Tutorial - appendix1.md",
    "title": "Introduction",
    "content": "---\ntitle: \"Appendix 1: Further Study Materials\"\ntype: book-en-us\norder: 11\n---\n\n"
  },
  {
    "source": "Modern C++ Tutorial - appendix1.md",
    "title": "Appendix 1: Further Study Materials",
    "content": "# Appendix 1: Further Study Materials\n\nFirst of all, congratulations  on reading this book! I hope this book has raised your interest in modern C++.\n\nAs mentioned in the introduction to this book, this book is just a book that takes you quickly to the new features of modern C++ 11/14/17/20, rather than the advanced learning practice of C++ \"Black Magic\". The author of course also thinks about this demand, but the content is very difficult and there are few audiences. Here, the author lists some materials that can help you learn more about modern C++ based on this book. I hope I can help you:\n\n- [C++ Reference](https://en.cppreference.com/w)\n- [CppCon YouTube Channel](https://www.youtube.com/user/CppCon/videos)\n- [Ulrich Drepper. What Every Programmer Should Know About Memory. 2007](https://people.freebsd.org/~lstewart/articles/cpumemory.pdf)\n- to be added\n\n[Table of Content](./toc.md) | [Previous Chapter](./10-cpp20.md) | [Next Chapter](./appendix2.md)\n\n"
  },
  {
    "source": "Modern C++ Tutorial - appendix1.md",
    "title": "Licenses",
    "content": "## Licenses\n\n<a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png\" /></a><br />This work was written by [Ou Changkun](https://changkun.de) and licensed under a <a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>. The code of this repository is open sourced under the [MIT license](../../LICENSE).\n"
  },
  {
    "source": "Modern C++ Tutorial - 00-preface.md",
    "title": "Introduction",
    "content": "---\ntitle: Preface\ntype: book-en-us\norder: 0\n---\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 00-preface.md",
    "title": "Preface",
    "content": "# Preface\n\n[TOC]\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 00-preface.md",
    "title": "Introduction",
    "content": "## Introduction\n\nThe C++ programming language owns a fairly large user group. From the advent of C++98 to the official finalization of C++11, it has continued to stay relevant. C++14/17 is an important complement and optimization for C++11, and C++20 brings this language to the door of modernization. The extended features of all these new standards are integrated into the C++ language and infuse it with new vitality.\nC++ programmers who are still using **traditional C++** (this book refers to C++98 and its previous standards as traditional C++) may even amazed by the fact that they are not using the same language while reading modern C++ code.\n\n**Modern C++** (this book refers to C++11/14/17/20) introduces many features into traditional C++ which bring the entire language to a new level of modernization. Modern C++ not only enhances the usability of the C++ language itself, but the modification of the `auto` keyword semantics gives us more confidence in manipulating extremely complex template types. At the same time, a lot of enhancements have been made to the language runtime. The emergence of Lambda expressions has given C++ the \"closure\" feature of \"anonymous functions\", which are  in almost all modern programming languages (such as Python, Swift, etc). It has become commonplace, and the emergence of rvalue references has solved the problem of temporary object efficiency that C++ has long been criticized for.\n\nC++17 is the direction that has been promoted by the C++ community in the past three years. It also points out an important development direction of **modern C++** programming. Although it does not appear as much as C++11, it contains a large number of small and beautiful languages and features (such as structured binding), and the appearance of these features once again corrects our programming paradigm in C++.\n\nModern C++ also adds a lot of tools and methods to its standard library such as `std::thread` at the level of the language itself, which supports concurrent programming and no longer depends on the underlying system on different platforms. The API implements cross-platform support at the language level; `std::regex` provides full regular expression support and more. C++98 has been proven to be a very successful \"paradigm\", and the emergence of modern C++ further promotes this paradigm, making C++ a better language for system programming and library development. Concepts verify the compile-time of template parameters, further enhancing the usability of the language.\n\nIn conclusion, as an advocate and practitioner of C++, we always maintain an open mind to accept new things, and we can promote the development of C++ faster, making this old and novel language more vibrant.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 00-preface.md",
    "title": "Targets",
    "content": "## Targets\n\n- This book assumes that readers are already familiar with traditional C++ (i.e. C++98 or earlier), at least they do not have any difficulty in reading traditional C++ code. In other words, those who have long experience in traditional C++ and people who desire to quickly understand the features of modern C++ in a short period are well suited to read the book;\n\n- This book introduces to a certain extent of the dark magic of modern C++. However, these magics are very limited, they are not suitable for readers who want to learn advanced C++. The purpose of this book is to offer a quick start for modern C++. Of course, advanced readers can also use this book to review and examine themselves on modern C++.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 00-preface.md",
    "title": "Purpose",
    "content": "## Purpose\n\nThe book claims \"On the Fly\". It intends to provide a comprehensive introduction to the relevant features regarding modern C++ (before the 2020s).\nReaders can choose interesting content according to the following table of contents to learn and quickly familiarize themselves with the new features that are available.\nReaders should aware that all of these features are not required. It should be learned when you need it.\n\nAt the same time, instead of grammar-only, the book introduces the historical background as simple as possible of its technical requirements, which provides great help in understanding why these features come out.\n\nAlso, the author would like to encourage that readers should be able to use modern C++ directly in their new projects and migrate their old projects to modern C++ gradually after reading the book.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 00-preface.md",
    "title": "Code",
    "content": "## Code\n\nEach chapter of this book has a lot of code. If you encounter problems when writing your own code with the introductory features of the book, you might as well read the source code attached to the book. You can find the book [here](../../code). All the code is organized by chapter, the folder name is the chapter number.\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 00-preface.md",
    "title": "Exercises",
    "content": "## Exercises\n\nThere are few exercises At the end of each chapter of the book. It is for testing whether you can use the knowledge points in the current chapter. You can find the possible answer to the problem from [here](../../exercise). The folder name is the chapter number.\n\n[Table of Content](./toc.md) | [Next Chapter: Towards Modern C++](./01-intro.md)\n\n"
  },
  {
    "source": "Modern C++ Tutorial - 00-preface.md",
    "title": "Licenses",
    "content": "## Licenses\n\n<a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png\" /></a><br />This work was written by [Ou Changkun](https://changkun.de) and licensed under a <a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>. The code of this repository is open sourced under the [MIT license](../../LICENSE).\n\n"
  }
]